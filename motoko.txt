(Files content cropped to 300k characters)

================================================
FILE: README.md
================================================
# [Motoko](https://internetcomputer.org/docs/current/motoko/main/about-this-guide) &middot; [![Release](https://img.shields.io/github/v/release/dfinity/motoko.svg)](https://github.com/dfinity/motoko/releases) [![GitHub license](https://img.shields.io/badge/license-Apache%202.0-blue.svg)](https://opensource.org/licenses/Apache-2.0) [![Tests](https://img.shields.io/github/actions/workflow/status/dfinity/motoko/release.yml?branch=master&logo=github)](https://github.com/dfinity/motoko/actions?query=workflow:"release") [![PRs Welcome](https://img.shields.io/badge/PRs-welcome-brightgreen.svg)](https://github.com/dfinity/motoko/blob/master/.github/CONTRIBUTING.md)


A safe, simple, actor-based programming language for building [Internet Computer](https://internetcomputer.org/) (ICP) canister smart contracts.

![Motoko Logo](https://github.com/user-attachments/assets/844ca364-4d71-42b3-aaec-4a6c3509ee2e)

## User Documentation & Samples

* [Introduction](https://internetcomputer.org/docs/current/motoko/main/getting-started/motoko-introduction)
* [Basic concepts and terms](https://internetcomputer.org/docs/current/motoko/main/getting-started/basic-concepts)
* [Sample code](samples)
* [Language manual](doc/md/reference/language-manual.md)
* [Concrete syntax](doc/md/examples/grammar.txt)
* [Documentation sources](doc/md/)
* [Base package documentation](doc/md/base/index.md)
* [_Motoko-san_: a prototypical deductive verifier](src/viper/README.md)

## Introduction

### Motivation and Goals

* High-level programming language for ICP smart contracts

* Simple design and familiar syntax

* Convenient support for the [actor model](https://en.wikipedia.org/wiki/Actor_model)

* Good fit for underlying Wasm and ICP execution model

### Key Design Points

* Object-based language with actors, classes, modules, etc. as closures

* Classes can be actors

* Async construct for direct-style programming of asynchronous messaging

* Structurally typed with simple generics and subtyping

* Overflow-checked number types, explicit conversions

* JavaScript/TypeScript-style syntax but without the JavaScript madness

* Inspirations from Java, C#, JavaScript, Swift, Pony, ML, Haskell

## Related Repositories

* Next-Gen [Core package](https://github.com/dfinity/motoko-core)
* Legacy [Base package](https://github.com/dfinity/motoko-base)
* [Vessel package manager](https://github.com/dfinity/vessel)
* [Example projects](https://github.com/dfinity/examples/tree/master/motoko)
* [ICP Ninja, online authoring of canisters](https://icp.ninja)
* [Motoko Playground](https://github.com/dfinity/motoko-playground) &middot; (DEPRECATED — [online IDE](https://play.motoko.org))
* [Embed Motoko code snippets](https://github.com/dfinity/embed-motoko) &middot; ([online interpreter](https://embed.smartcontracts.org/))
* [VS Code extension](https://github.com/dfinity/vscode-motoko) &middot; ([install](https://marketplace.visualstudio.com/items?itemName=dfinity-foundation.vscode-motoko))
* [Browser and Node.js bindings](https://github.com/dfinity/node-motoko) &middot; ([npm package](https://www.npmjs.com/package/motoko))

## Community Resources

* [Awesome Motoko](https://github.com/motoko-unofficial/awesome-motoko#readme)
* [Blocks - an online low-code editor for Motoko](https://github.com/Blocks-Editor/blocks)
* [MOPS - a Motoko package manager hosted on the IC](https://j4mwm-bqaaa-aaaam-qajbq-cai.ic0.app/)
* [Motoko Bootcamp](https://www.motokobootcamp.com) &middot; ([YouTube channel](https://www.youtube.com/channel/UCa7_xHjvOESf9v281VU4qVw))
* [Motoko library starter template](https://github.com/ByronBecker/motoko-library-template)

## Contributing

See our [contribution guidelines](.github/CONTRIBUTING.md), [code of conduct](.github/CODE_OF_CONDUCT.md) and [build instructions](Building.md) to get started.



================================================
FILE: Building.md
================================================
- [Nix setup](#nix-setup)
- [Installation using Nix](#installation-using-nix)
  - [Other tools](#other-tools)
- [Development using Nix](#development-using-nix)
- [Replicating CI locally](#replicating-ci-locally)
- [Making releases](#making-releases)
  - [1. Update Changelog](#1-update-changelog)
  - [2. Open a release PR](#2-open-a-release-pr)
  - [3. Wait for the release to complete, and verify it](#3-wait-for-the-release-to-complete-and-verify-it)
  - [4. Update `motoko-core`](#4-update-motoko-core)
  - [5. Update `motoko-base`](#5-update-motoko-base)
  - [Downstream](#downstream)
- [Making draft / pre-releases](#making-draft--pre-releases)
  - [Version suffix](#version-suffix)
- [Coverage report](#coverage-report)
- [Profile the compiler](#profile-the-compiler)
- [Benchmarking the RTS](#benchmarking-the-rts)

## Nix setup

The Motoko build system relies on [Nix](https://nixos.org/) to manage
dependencies, drive the build and run the test suite. You should install `nix` by
running, as a normal user with `sudo` permissions,
```
sh <(curl -L https://nixos.org/nix/install) --daemon
```

This repository is also a Nix Flake which means you need to
allow this feature by making sure the following is present in `/etc/nix/nix.conf`:
```
extra-experimental-features = nix-command flakes
```

You should also enable a nix cache to get all dependencies pre-built.

The `cachix` command also requires `sudo` permissions.
```
nix profile install --accept-flake-config nixpkgs#cachix
cachix use ic-hs-test
```
Technically, this is optional, but without this you will build lots of build
dependencies manually, which can take several hours.

## Installation using Nix

If you want just to _use_ `moc`, you can install the `moc` binary into your `nix`
environment by running
```
$ nix profile install .#release.moc
```
in a check-out of the `motoko` repository.

### Other tools

Similarly the other tools can be installed using
```
$ nix profile install .#release.mo-doc
```
etc.

## Development using Nix

To enter a shell with the necessary dependencies available,
either run:

```
$ nix develop
```

Or use `direnv` by:

* Installing: [direnv](https://direnv.net/).

* Installing: [nix-direnv](https://github.com/nix-community/nix-direnv).

* `cd` to this directory.

* `direnv allow` (only needs to be done once).

Then all tools to develop Motoko will be loaded automatically everytime you `cd`
to this directory or everytime you update `flake.{nix,lock}`.

(The first shell start may take several minutes, afterwards being much faster.)

Within this shell you can run
 * `make` in `src/` to build all binaries,
 * `make moc` in `src/` to build just the `moc` binary,
 * `make DUNE_OPTS=--watch moc` to keep rebuilding as source files are changing
 * `make` in `rts/` to build the Motoko runtime
 * `make` in `test/` to run the test suite.

This invokes `dune` under the hood, which will, as a side effect, also create
`.merlin` files for integration with Merlin, the Ocaml Language Server

## Replicating CI locally

A good way to check that everything is fine, i.e. if this will pass CI, is to run
```
$ nix build --no-link
```

For more details on our CI and CI setup, see `CI.md`.


## Making releases

We make frequent releases, at least weekly. The steps to make a release are:

Before starting the release process, ensure you are working with the latest version of the codebase. Run the following commands:

```bash
git switch master
git pull
```

Make sure the markdown doc for base is up-to-date:
For now, in a nix shell `$ nix develop` (or _re-enter_ if you already have one open):

```bash
  make -C rts
  make -C src
  make -C doc base
  git diff
```

If not, create and merge a separate PR to update the doc (adding any new files) and goto step 0.

### 1. Update Changelog

Check the recent changes from the last release:
```bash
git log --first-parent $(git describe --abbrev=0)..HEAD
```
Or, on macOS, in a browser:
```bash
open "https://github.com/dfinity/motoko/compare/$(git describe --abbrev=0)...master"
```

Look at changes and check that everything relevant is mentioned in the changelog section,
and possibly clean it up a bit, curating the information for the target audience.

You can get the latest released version with:

```bash
git describe --abbrev=0
```

Make sure that the very top of `Changelog.md` **exactly** matches the following format (otherwise the release extraction script will fail):

```markdown
# Motoko compiler changelog

## X.Y.Z (YYYY-MM-DD)

...changelog content for this version...

## ...previous version...
```

### 2. Open a release PR

Define a shell variable `NEXT_MOC_VERSION` with the next version number.
The following command will automatically calculate a patch bump.
Verify the version is correct. If you need a minor or major version bump, set the variable manually.

```bash
export LAST_MOC_VERSION=$(git describe --abbrev=0)
export NEXT_MOC_VERSION=$(echo $LAST_MOC_VERSION | awk -F. -v OFS=. '{$3++; print}')
echo "Last version: $LAST_MOC_VERSION"
echo "Next version: $NEXT_MOC_VERSION"
```

Run the following command pipeline to create the release PR:

```bash
(test -n "$NEXT_MOC_VERSION" || (echo "NEXT_MOC_VERSION is not set" && false)) && \
git switch -c $USER/$NEXT_MOC_VERSION && \
git add Changelog.md && \
git commit -m "chore: Releasing $NEXT_MOC_VERSION" && \
git push --set-upstream origin $USER/$NEXT_MOC_VERSION && \
gh pr create --title "chore: Releasing $NEXT_MOC_VERSION" --label "release" --base master --head $USER/$NEXT_MOC_VERSION --body "" && \
gh pr merge --auto
```

<details>
<summary>Or click here for detailed steps:</summary>

Switch to a new release branch (creating it if it doesn't exist):

```bash
git switch -c $USER/$NEXT_MOC_VERSION
```

Commit the changes with exactly the following message:

```bash
git add Changelog.md
git commit -m "chore: Releasing $NEXT_MOC_VERSION"
```

Push the branch:

```bash
git push --set-upstream origin $USER/$NEXT_MOC_VERSION
```

Create a PR from this commit:
- Make sure the **PR title** is the same as the **commit message**.
- Label the PR with `release` (to mark it as a release PR) and enable auto-merge on it. It will not get merged into `master` without additional approval, and it may take some time as the title (version number) enters into the `nix` dependency tracking.

To create the PR, you can use `gh` CLI:
```bash
gh pr create --title "chore: Releasing $NEXT_MOC_VERSION" --label "release" --base master --head $USER/$NEXT_MOC_VERSION --body "" && gh pr merge --auto
```
</details>

The PR will be merged automatically once the CI passes.
You can check the status of the PR on GitHub with
```bash
gh pr view --web
```

After the PR is merged, the `release-pr.yml` workflow should automatically create a tag and push it to the remote repository starting the release process.

### 3. Wait for the release to complete, and verify it

Verify that the release is complete and go to the next step if the release was successful.
Otherwise, fix the issue and push the tags manually as described below:

<details>
<summary>Click here for manual tag-pushing steps if the automated release fails.</summary>

After the PR is merged: Pull the latest `master` and verify you are at the right commit:

```bash
git switch master; git pull --rebase
git show
```

Push the tag:

```bash
git tag $NEXT_MOC_VERSION -m "Motoko $NEXT_MOC_VERSION"
git push origin $NEXT_MOC_VERSION
```

Pushing the tag should cause GitHub Actions to create a "Release" on the GitHub
project. This will fail if the changelog is not in order (in this case, fix and
force-push the tag).  It will also fail if the nix cache did not yet contain
the build artifacts for this revision. In this case, restart the GitHub Action
on GitHub's UI.
</details>

### 4. Update `motoko-core`

From the `main` branch, push a tag for the new `moc` version:

```bash
git checkout main
git pull
git tag moc-$NEXT_MOC_VERSION
git push origin moc-$NEXT_MOC_VERSION
```

### 5. Update `motoko-base`

From the `master` branch, push a tag for the new `moc` version:

```bash
git checkout master
git pull
git tag moc-$NEXT_MOC_VERSION
git push origin moc-$NEXT_MOC_VERSION
```

<details>
<summary>Click here for legacy `motoko-base` update steps.</summary>

After releasing the compiler, update `motoko-base`'s `master` branch to the `next-moc` branch.

* Wait ca. 5min after releasing to give the CI/CD pipeline time to upload the release artifacts
* Change into `motoko-base` and pull the latest `next-moc`
```bash
git switch next-moc; git pull
```
* Revise and update the `CHANGELOG.md`, by adding a top entry for the release

* Bump `moc` and create a PR:
```bash
# Create a new branch for the update
git switch -c $USER/update-moc-$NEXT_MOC_VERSION && \

# Update the `moc_version` env variable in `.github/workflows/{ci, package-set}.yml` and `mops.toml` to the new released version
perl -pi -e "s/moc_version: \"\\d+\.\\d+\.\\d+\"/moc_version: \"$NEXT_MOC_VERSION\"/g" .github/workflows/ci.yml .github/workflows/package-set.yml && \
perl -pi -e "s/moc = \"\\d+\.\\d+\.\\d+\"/moc = \"$NEXT_MOC_VERSION\"/g; s/version = \"\\d+\.\\d+\.\\d+\"/version = \"$NEXT_MOC_VERSION\"/g" mops.toml && \

# Add the changed files and commit the changes
git add .github/ CHANGELOG.md mops.toml && git commit -m "Motoko $NEXT_MOC_VERSION" && \

# Push the branch
git push --set-upstream origin $USER/update-moc-$NEXT_MOC_VERSION && \

# Create a PR targeting `master`
gh pr create --title "Motoko $NEXT_MOC_VERSION" --base master --head $USER/update-moc-$NEXT_MOC_VERSION --body ""

```
* You can check the status of the PR on GitHub with
```bash
gh pr view --web
```
* Once CI passes, merge the PR using the _normal merge_ (not squash merge).
  > **Note:** To allow merge commits, go to the repository settings and enable merge commits. Remember to **disable it after the merge**. Unfortunately, `gh` CLI cannot update this setting without admin permissions.

It will eventually be imported into this repo by a scheduled `niv-updater-action`.

Finally tag the base release (so the documentation interpreter can do the right thing):
First, switch to `master`, pull the latest changes and verify we are at the right commit:
```bash
git switch master && git pull
git show
```
* Tag and push the release
```bash
git tag moc-$NEXT_MOC_VERSION
git push origin moc-$NEXT_MOC_VERSION
```

</details>

### Downstream

There are a few dependent actions to follow-up the release, e.g.
- `motoko` NPM package
- `vessel` package set
- `vscode` plugin
- ICP Ninja

These are generally triggered by mentioning the release in Slack.

Announcing the release towards SDK happens by triggering this GitHub action:
https://github.com/dfinity/sdk/actions/workflows/update-motoko.yml
Press the "Run workflow" button, filling in
- Motoko version: `latest`
- Open PR against this sdk branch: `master`

and then hitting the green button. This will create a PR with all necessary hash changes against that branch. There is no
need to do this immediately, you can leave the release soaking a few days. Use your own jugdement w.r.t. risk, urgency etc.

If you want to update the portal documentation, typically to keep in sync with a `dfx` release, follow the instructions in https://github.com/dfinity/portal/blob/master/MAINTENANCE.md.

## Making draft / pre-releases

To make a draft / pre-release, you can use the GitHub Actions workflow:
https://github.com/dfinity/motoko/actions/workflows/release.yml

1. Press the **"Run workflow"** button
2. Select the branch for which you want to make the draft / pre-release
3. Fill in the **"Version suffix"** that will be used to contruct the version name, e.g. `alpha-1` version suffix could produce a version like `0.16.3-alpha-1`
4. Hit the green button to run the workflow and wait for it to complete.
5. View the draft release at https://github.com/dfinity/motoko/releases once the workflow is complete.
6. To make a pre-release:
   1. Edit the draft release
   2. Make sure the tag and the name of the release are the same as the generated version, e.g. `0.16.3-alpha-1`. Note that there is no need to manually push the tag, it should be created automatically when publishing the pre-release.
   3. Scroll down to the bottom and publish the pre-release.
7. Remember to delete the draft release after testing!

### Version suffix

The version is generated by concatenating the 'latest `moc` version' with the version suffix, e.g. `0.16.3-alpha-1` for the version suffix `alpha-1`.
The 'latest `moc` version' is taken from the first matching entry in `Changelog.md` **on the selected branch**. Source code: [nix/releaseVersion.nix](nix/releaseVersion.nix).

The workflow should upload the artifacts with correct names according to the generated version.

The generated version (e.g. `0.16.3-alpha-1`) should be used as the name of the release and the tag.
Artifacts should be uploaded with the correct names according to the generated version, e.g. `motoko-Darwin-arm64-0.16.3-alpha-1.tar.gz` -- This is necessary for `mops toolchain` to fetch the correct file.

## Coverage report

To build with coverage enabled, compile the binaries in `src/` with
```
make DUNE_OPTS="--instrument-with bisect_ppx"`
```
and then use `bisect-ppx-report html` to produce a report.

The full report can be built with
```
nix build .#tests.coverage
```
and the report for latest `master` can be viewed at
[https://dfinity.github.io/motoko/coverage/](https://dfinity.github.io/motoko/coverage/).

## Profile the compiler

(This section is currently defunct, and needs to be update to work with the dune
build system.)

1. Build with profiling within nix-shell (TODO: How to do with dune)
   ```
   make -C src clean
   make BUILD=p.native -C src moc
   ```
2. Run `moc` as normal, e.g.
   ```
   moc -g -c foo.mo -o foo.wasm
   ```
   this should dump a `gmon.out` file in the current directory.
3. Create the report, e.g. using
   ```
   gprof --graph src/moc
   ```
   (Note that you have to _run_ this in the directory with `gmon.out`, but
   _pass_ it the path to the binary.)


## Benchmarking the RTS

Specifically some advanced techniques to obtain performance deltas for the
GC can be found in `rts/Benchmarking.md`.



================================================
FILE: CI.md
================================================
Motoko CI and CD setup
======================

This file gives a comprehensive overview of our CI and CD setup. Target
audience are developers working on Motoko (to know what services and behaviours
they can expect), and engineers who support the setup.

This document distinguishes use-cases (requirements, goals) from
implementations, to allow evaluating alternative implementations.

The implementation is currently a careful choreography between Github, Github
Actions, and the Cachix nix cache.

Knowing if it is broken
-----------------------

**Use-case:**
Everything is built and tested upon every push to a branch of the repository,
and the resulting status is visible (at derivation granularity) to developers.

**Implementation:**
All pushes to any branch are built by a Github Action job, on Linux and Darwin.

The build status is visible via the Github status (coarsely: only evaluation,
`{debug,release}-systems-go`).

This includes linux and darwin builds.

Preventing `master` from breaking
---------------------------------

**Use-case:**
A PR that breaks requires jobs (`all-systems-go`) cannot be merged into `master`.

**Implementation (external):**
Github branch protection is enabled for `master`, and requires the
Github Action jobs (Linux and Darwin) to succeed.

Require a second pair of eyeballs
---------------------------------

**Use-case:**
A PR needs to be approved by any other developer in order to be merged (with
the exceptions listed below).

**Implementation:**
Github branch protection requires a review.

Warm cache
----------

**Use-case:**
Developers can rely on all build artifacts (espcially, but not exclusively, the
dependencies of the nix shell) being present in a nix cache.

**Implementation (external):**
Github Actions pushes all builds to the public cachix.org-based nix cache.

**Implementation (internal):**
Hydra pushes all builds to the internal nix cache.

Push releases
-------------

**Use-case:**
Tagged versions cause a tarball with a Motoko release to be pushed to
https://github.com/dfinity/motoko/releases

**Implementation (external):**
A github action creates Github releases and includes the build artifacts there.

Automatically merge when ready
------------------------------

**Use-case:**
Developers can indicate that a PR should be merged as soon as all requirements
pass, using the PR description as the commit message.

This can be done before approvals are in and/or CI has turned green, and will
reliably be acted on once requirements are fulfilled.

**Implementation:**
Use the "Enable auto-merge (squash)" button of the GitHub PR web page.
Alternatively from the CLI `gh pr merge --auto` will do. Note that you have to update
the PR with `master` first, so that the tests can run on the most recent codebase.
From the command line issue `gh pr update-branch` to that effect.

Render and provide various reports
----------------------------------
**Use-case:**
Various build artifacts are most useful when available directly in the browser, namely:

 * The motoko user guide
 * The “overview slides”
 * The documentation for `motoko-base`, in the version pinned by motoko
 * Flamegraphs for the programs in `tests/perf`
 * A coverage report

A stable link to these should exist for `master`, and an easy-to-find link for each PR.

**Implementation (internal):**
Hydra hosts the build products of the relevant jobs, and can be found via the
Hydra job status page, and the there is a stable link for the latest build of
`master` and of each PR.

**Implementation (external):**
The latest `master` version of the file is availble at
[https://dfinity.github.io/motoko/](https://dfinity.github.io/motoko/).
The reports are calculated in PRs (so failures would be caught), but are not
hosted anywhere.

Performance changes are known
-----------------------------

**Use-case:**
For every PR, the developer is told about performance changes relative to the
merge point, via an continuously updated comment on the PR.

**Implementation (external):**
 * Steps in the Github Action calculates the correct merge base using
   `git-merge-base` (_not_ the latest version of the target branch) and passes
   the correct git revisions to the `./perf-delta.nix` nix derivation.
 * Building that derivations compares metrics and generates a report.
 * A Github Action updates the comment upon every new push to the PR.

**Implementation (internal):**
 * Hydra calculates the correct merge base using `git-merge-base` (_not_ the
   latest version of the target branch) and passes a checkout of that revision
   as `src.mergeBase` to `ci-pr.nix`.
 * The job `perf-delta` compares metrics and generates a report.
 * The hydra Github commenter plugin updates the comment upon every new push to
   the PR.

Dependencies are updated automatically
--------------------------------------

**Use-case:**
Several dependencies, as pinned by `flake.nix`, should be updated without
human intervention. Some dependencies are updated daily, others weekly. For
some dependency, it should only be _tested_ if it builds, but not merged.

**Implementation:**
 * Multiple files (with different settings) in `.github/workflows/` use
   flake-updater to create
   pull requests with the version bumps, as `dfinity-bot`, setting
   `automerge-squash` or `autoclose`.
 * (obsolete) Mergify automatically approves PRs from `dfinity-bot`.
 * Once CI passes, the `test.yml` GitHub action merges or closes PRs, as per label.

(obsolete) Updates to the Changelog require no review
------------------------------------------

**Use-case:**
To make releasing releases frictionless (see section in `Building.md`), PRs
that only update `Changelog.md` do not require a human approver.

**Implementation:**
Mergify approves PRs that only change the `Changelog.md` file.



================================================
FILE: flake.lock
================================================
{
  "nodes": {
    "candid-src": {
      "flake": false,
      "locked": {
        "lastModified": 1759412512,
        "narHash": "sha256-7/aBuCJUtH5nofVfgyedqI6t7a21H+14kwmYOGFbO8g=",
        "owner": "dfinity",
        "repo": "candid",
        "rev": "1725ea211e928a4dc18c4147d27ed5764f00df5c",
        "type": "github"
      },
      "original": {
        "owner": "dfinity",
        "repo": "candid",
        "type": "github"
      }
    },
    "esm": {
      "flake": false,
      "locked": {
        "lastModified": 499162500,
        "narHash": "sha256-OP2ddzMmLhqXrcKsJlS9d4oqcx+9vZWevd+DnTAI04Q=",
        "type": "tarball",
        "url": "https://registry.npmjs.org/esm/-/esm-3.2.25.tgz"
      },
      "original": {
        "type": "tarball",
        "url": "https://registry.npmjs.org/esm/-/esm-3.2.25.tgz"
      }
    },
    "flake-parts": {
      "inputs": {
        "nixpkgs-lib": [
          "nix-update-flake",
          "nixpkgs"
        ]
      },
      "locked": {
        "lastModified": 1754420989,
        "narHash": "sha256-3e4wHzNwTMg7GaeLH9A091DMaO9AfFxUjpfqbddCUeo=",
        "owner": "hercules-ci",
        "repo": "flake-parts",
        "rev": "7f38f25a44023a21a504bd3fd9d4f41c4a39f55c",
        "type": "github"
      },
      "original": {
        "owner": "hercules-ci",
        "repo": "flake-parts",
        "type": "github"
      }
    },
    "flake-utils": {
      "inputs": {
        "systems": "systems"
      },
      "locked": {
        "lastModified": 1731533236,
        "narHash": "sha256-l0KFg5HjrsfsO/JpG+r7fRrqm12kzFHyUHqHCVpMMbI=",
        "owner": "numtide",
        "repo": "flake-utils",
        "rev": "11707dc2f618dd54ca8739b309ec4fc024de578b",
        "type": "github"
      },
      "original": {
        "owner": "numtide",
        "repo": "flake-utils",
        "type": "github"
      }
    },
    "ic-src": {
      "flake": false,
      "locked": {
        "lastModified": 1755350517,
        "narHash": "sha256-i0QngtC8mVTzp5xNV3/GIbgfB8Vkd7gfg0L78AHf1oI=",
        "owner": "dfinity",
        "repo": "ic",
        "rev": "b6cf1a858dfa1634e763eff203a709afbd1d8bb0",
        "type": "github"
      },
      "original": {
        "owner": "dfinity",
        "repo": "ic",
        "type": "github"
      }
    },
    "ic-wasm-src": {
      "flake": false,
      "locked": {
        "lastModified": 1759325426,
        "narHash": "sha256-PTwtdFVGGofm934tlikb2cNq932yuBjXYtN5TKXfwmg=",
        "owner": "dfinity",
        "repo": "ic-wasm",
        "rev": "d61f15ea363eebb952195f57cf9c5db3b2cade21",
        "type": "github"
      },
      "original": {
        "owner": "dfinity",
        "repo": "ic-wasm",
        "type": "github"
      }
    },
    "libtommath-src": {
      "flake": false,
      "locked": {
        "lastModified": 1571737484,
        "narHash": "sha256-zpnCm1EpaoeMzdJVYMS2LARSJn5eqtQhipAcBFfrRDI=",
        "owner": "libtom",
        "repo": "libtommath",
        "rev": "6ca6898bf37f583c4cc9943441cd60dd69f4b8f2",
        "type": "github"
      },
      "original": {
        "owner": "libtom",
        "ref": "v1.2.0",
        "repo": "libtommath",
        "type": "github"
      }
    },
    "motoko-base-src": {
      "flake": false,
      "locked": {
        "lastModified": 1757712160,
        "narHash": "sha256-gS3T/REhM5IhkMhrV3D4ljOyfm4DK3+d9wYB98kYei4=",
        "owner": "dfinity",
        "repo": "motoko-base",
        "rev": "df67035eb1d4a116ce684f1dcdad892c91273886",
        "type": "github"
      },
      "original": {
        "owner": "dfinity",
        "ref": "next-moc",
        "repo": "motoko-base",
        "type": "github"
      }
    },
    "motoko-core-src": {
      "flake": false,
      "locked": {
        "lastModified": 1759425490,
        "narHash": "sha256-eStzhPscP3QvVcml3RQpYRVmnbhw9EVkJYX4XhbrQ50=",
        "owner": "dfinity",
        "repo": "motoko-core",
        "rev": "e47c1231a54d03ac17736cb9f2fe9afcc7e2f583",
        "type": "github"
      },
      "original": {
        "owner": "dfinity",
        "repo": "motoko-core",
        "type": "github"
      }
    },
    "motoko-matchers-src": {
      "flake": false,
      "locked": {
        "lastModified": 1740991650,
        "narHash": "sha256-SXw1rO/IWHS9kjySy/u6HbEHYWn7JeQkK2IVI5TLCWA=",
        "owner": "kritzcreek",
        "repo": "motoko-matchers",
        "rev": "5ba5f52bd9a5649dedf5e2a1ccd55d98ed7ff982",
        "type": "github"
      },
      "original": {
        "owner": "kritzcreek",
        "repo": "motoko-matchers",
        "rev": "5ba5f52bd9a5649dedf5e2a1ccd55d98ed7ff982",
        "type": "github"
      }
    },
    "nix-update-flake": {
      "inputs": {
        "flake-parts": "flake-parts",
        "nixpkgs": [
          "nixpkgs"
        ],
        "treefmt-nix": "treefmt-nix"
      },
      "locked": {
        "lastModified": 1754421367,
        "narHash": "sha256-zumHGR/7NqlkSi8W7Vvdka/l/8x1aenpINg2jqepyeo=",
        "owner": "Mic92",
        "repo": "nix-update",
        "rev": "09aadb5d6d9e1fc57df0b61def4bdd8b43ea47a1",
        "type": "github"
      },
      "original": {
        "owner": "Mic92",
        "repo": "nix-update",
        "rev": "09aadb5d6d9e1fc57df0b61def4bdd8b43ea47a1",
        "type": "github"
      }
    },
    "nixpkgs": {
      "locked": {
        "lastModified": 1751274312,
        "narHash": "sha256-/bVBlRpECLVzjV19t5KMdMFWSwKLtb5RyXdjz3LJT+g=",
        "owner": "NixOS",
        "repo": "nixpkgs",
        "rev": "50ab793786d9de88ee30ec4e4c24fb4236fc2674",
        "type": "github"
      },
      "original": {
        "owner": "NixOS",
        "ref": "nixos-24.11",
        "repo": "nixpkgs",
        "type": "github"
      }
    },
    "ocaml-recovery-parser-src": {
      "flake": false,
      "locked": {
        "lastModified": 1742444578,
        "narHash": "sha256-RFRI7VoHd7GceIQnzN1FQYfR/5nbrU/t1pLTbURE6PY=",
        "owner": "serokell",
        "repo": "ocaml-recovery-parser",
        "rev": "b8207b0c919b84d5096486e59985d0137c0c4d82",
        "type": "github"
      },
      "original": {
        "owner": "serokell",
        "repo": "ocaml-recovery-parser",
        "type": "github"
      }
    },
    "ocaml-vlq-src": {
      "flake": false,
      "locked": {
        "lastModified": 1629909858,
        "narHash": "sha256-et4gfL9IVNkmTLp/S03eAQuRifsuxexvABdC3G7t1MU=",
        "owner": "flowtype",
        "repo": "ocaml-vlq",
        "rev": "66238f9539292b5e0cf73cb8d80dbd3f41732c27",
        "type": "github"
      },
      "original": {
        "owner": "flowtype",
        "repo": "ocaml-vlq",
        "type": "github"
      }
    },
    "pocket-ic-src": {
      "flake": false,
      "locked": {
        "lastModified": 1757573980,
        "narHash": "sha256-yOjLoRCMsi29tEK8M1XNC8AaU1ixkHE3B5sdGSr6u6s=",
        "owner": "dfinity",
        "repo": "ic",
        "rev": "861616d46ded00091fecbfe01f441b38b56b483c",
        "type": "github"
      },
      "original": {
        "owner": "dfinity",
        "ref": "master",
        "repo": "ic",
        "type": "github"
      }
    },
    "root": {
      "inputs": {
        "candid-src": "candid-src",
        "esm": "esm",
        "flake-utils": "flake-utils",
        "ic-src": "ic-src",
        "ic-wasm-src": "ic-wasm-src",
        "libtommath-src": "libtommath-src",
        "motoko-base-src": "motoko-base-src",
        "motoko-core-src": "motoko-core-src",
        "motoko-matchers-src": "motoko-matchers-src",
        "nix-update-flake": "nix-update-flake",
        "nixpkgs": "nixpkgs",
        "ocaml-recovery-parser-src": "ocaml-recovery-parser-src",
        "ocaml-vlq-src": "ocaml-vlq-src",
        "pocket-ic-src": "pocket-ic-src",
        "rust-overlay": "rust-overlay",
        "viper-server": "viper-server",
        "wasm-spec-src": "wasm-spec-src"
      }
    },
    "rust-overlay": {
      "inputs": {
        "nixpkgs": [
          "nixpkgs"
        ]
      },
      "locked": {
        "lastModified": 1755311859,
        "narHash": "sha256-NspGtm0ZpihxlFD628pvh5ZEhL/Q6/Z9XBpe3n6ZtEw=",
        "owner": "oxalica",
        "repo": "rust-overlay",
        "rev": "07619500e5937cc4669f24fec355d18a8fec0165",
        "type": "github"
      },
      "original": {
        "owner": "oxalica",
        "repo": "rust-overlay",
        "type": "github"
      }
    },
    "systems": {
      "locked": {
        "lastModified": 1681028828,
        "narHash": "sha256-Vy1rq5AaRuLzOxct8nz4T6wlgyUR7zLU309k9mBC768=",
        "owner": "nix-systems",
        "repo": "default",
        "rev": "da67096a3b9bf56a91d16901293e51ba5b49a27e",
        "type": "github"
      },
      "original": {
        "owner": "nix-systems",
        "repo": "default",
        "type": "github"
      }
    },
    "treefmt-nix": {
      "inputs": {
        "nixpkgs": [
          "nix-update-flake",
          "nixpkgs"
        ]
      },
      "locked": {
        "lastModified": 1754061284,
        "narHash": "sha256-ONcNxdSiPyJ9qavMPJYAXDNBzYobHRxw0WbT38lKbwU=",
        "owner": "numtide",
        "repo": "treefmt-nix",
        "rev": "58bd4da459f0a39e506847109a2a5cfceb837796",
        "type": "github"
      },
      "original": {
        "owner": "numtide",
        "repo": "treefmt-nix",
        "type": "github"
      }
    },
    "viper-server": {
      "flake": false,
      "locked": {
        "narHash": "sha256-lP7CFmug2kecogQ+qFS2GzxNQEzBVODw7xXmTHmxblQ=",
        "type": "file",
        "url": "https://github.com/viperproject/viperserver/releases/download/v.22.11-release/viperserver.jar"
      },
      "original": {
        "type": "file",
        "url": "https://github.com/viperproject/viperserver/releases/download/v.22.11-release/viperserver.jar"
      }
    },
    "wasm-spec-src": {
      "flake": false,
      "locked": {
        "lastModified": 1588580907,
        "narHash": "sha256-7Ew7V63uzGhwrPLUa6+4OG4GwkuggmtJiuaESbYX584=",
        "owner": "WebAssembly",
        "repo": "spec",
        "rev": "65a37e19b4aa4ffb76034ad6727bab74b071df9d",
        "type": "github"
      },
      "original": {
        "owner": "WebAssembly",
        "ref": "opam-1.1.1",
        "repo": "spec",
        "type": "github"
      }
    }
  },
  "root": "root",
  "version": 7
}



================================================
FILE: flake.nix
================================================
{
  description = "The Motoko compiler";

  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-24.11";

    flake-utils.url = "github:numtide/flake-utils";

    nix-update-flake.url = "github:Mic92/nix-update/09aadb5d6d9e1fc57df0b61def4bdd8b43ea47a1";
    nix-update-flake.inputs.nixpkgs.follows = "nixpkgs";

    rust-overlay.url = "github:oxalica/rust-overlay";
    rust-overlay.inputs.nixpkgs.follows = "nixpkgs";

    esm = {
      url = "https://registry.npmjs.org/esm/-/esm-3.2.25.tgz";
      flake = false;
    };
    viper-server = {
      url = "https://github.com/viperproject/viperserver/releases/download/v.22.11-release/viperserver.jar";
      flake = false;
    };

    candid-src = {
      url = "github:dfinity/candid";
      flake = false;
    };
    ic-src = {
      url = "github:dfinity/ic";
      flake = false;
    };
    pocket-ic-src = {
      url = "github:dfinity/ic/master";
      flake = false;
    };
    ic-wasm-src = {
      url = "github:dfinity/ic-wasm";
      flake = false;
    };
    libtommath-src = {
      url = "github:libtom/libtommath/v1.2.0";
      flake = false;
    };
    motoko-base-src = {
      url = "github:dfinity/motoko-base/next-moc";
      flake = false;
    };
    motoko-core-src = {
      url = "github:dfinity/motoko-core";
      flake = false;
    };
    motoko-matchers-src = {
      url = "github:kritzcreek/motoko-matchers/5ba5f52bd9a5649dedf5e2a1ccd55d98ed7ff982";
      flake = false;
    };
    ocaml-vlq-src = {
      url = "github:flowtype/ocaml-vlq";
      flake = false;
    };
    wasm-spec-src = {
      url = "github:WebAssembly/spec/opam-1.1.1";
      flake = false;
    };
    ocaml-recovery-parser-src = {
      url = "github:serokell/ocaml-recovery-parser";
      flake = false;
    };
  };

  outputs =
    { self
    , nixpkgs
    , flake-utils
    , nix-update-flake
    , rust-overlay
    , esm
    , viper-server
    , candid-src
    , ic-src
    , pocket-ic-src
    , ic-wasm-src
    , libtommath-src
    , motoko-base-src
    , motoko-core-src
    , motoko-matchers-src
    , ocaml-vlq-src
    , wasm-spec-src
    , ocaml-recovery-parser-src
    }: flake-utils.lib.eachDefaultSystem (system:
    let
      pkgs = import ./nix/pkgs.nix {
        inherit nixpkgs system rust-overlay;
        sources = {
          inherit
            candid-src
            ic-src
            pocket-ic-src
            ic-wasm-src
            libtommath-src
            motoko-base-src
            motoko-core-src
            motoko-matchers-src
            ocaml-vlq-src
            wasm-spec-src
            ocaml-recovery-parser-src;
        };
      };

      llvmEnv = ''
        # When compiling to wasm, we want to have more control over the flags,
        # so we do not use the nix-provided wrapper in clang
        export WASM_CLANG="clang-18"
        export WASM_LD=wasm-ld
        # because we use the unwrapped clang, we have to pass in some flags/paths
        # that otherwise the wrapped clang would take care for us
        export WASM_CLANG_LIB="${pkgs.llvmPackages_18.clang-unwrapped.lib}"

        # When compiling natively, we want to use `clang` (which is a nixpkgs
        # provided wrapper that sets various include paths etc).
        # But for some reason it does not handle building for Wasm well, so
        # there we use plain clang-18. There is no stdlib there anyways.
        export CLANG="${pkgs.clang_18}/bin/clang"
      '';

      rts = import ./nix/rts.nix { inherit pkgs llvmEnv; };

      commonBuildInputs = pkgs: with pkgs; [ dune_3 obelisk perl removeReferencesTo ] ++ (with ocamlPackages; [
        ocaml
        checkseum
        findlib
        menhir
        menhirLib
        menhirSdk
        ocaml-recovery-parser
        cow
        num
        stdint
        wasm_1
        vlq
        zarith
        yojson
        ppxlib
        ppx_blob
        ppx_inline_test
        ppx_expect
        bisect_ppx
        uucp
      ]);

      moPackages = officialRelease: import ./nix/mo-packages.nix { inherit pkgs commonBuildInputs rts officialRelease; };
      releaseMoPackages = moPackages true;
      debugMoPackages = moPackages false;
      buildableMoPackages = moPackages: { inherit (moPackages) moc mo-ld mo-doc didc deser; };
      buildableReleaseMoPackages = buildableMoPackages releaseMoPackages;
      buildableDebugMoPackages = buildableMoPackages debugMoPackages;

      # Common cargo lock configuration for test-runner packages.
      test-runner-cargo-lock = {
        lockFile = ./test-runner/Cargo.lock;
        outputHashes = {
          "pocket-ic-10.0.0" = "sha256-Y71hDHsqxcDlUzKBP9fd9HyO1L51kqwTbIyTrGMRftk=";
        };
      };

      # Define test-runner package.
      test-runner = pkgs.rustPlatform-stable.buildRustPackage {
        pname = "test-runner";
        version = "0.1.0";
        src = ./test-runner;
        cargoLock = test-runner-cargo-lock;
        buildInputs = [
          pkgs.pocket-ic.server
        ];
        POCKET_IC_BIN = "${pkgs.pocket-ic.server}/bin/pocket-ic-server";
        SSL_CERT_FILE = "${pkgs.cacert}/etc/ssl/certs/ca-bundle.crt";
        
        # Enable tests when building the package.
        doCheck = true;
      };

      tests = import ./nix/tests.nix { 
        inherit pkgs llvmEnv esm viper-server commonBuildInputs debugMoPackages test-runner; 
      };

      filterTests = type:
        pkgs.lib.mapAttrsToList (_name: drv: drv) (pkgs.lib.filterAttrs
          (name: _drv:
            let
              matchDebug = builtins.match ".*-debug$" name;
              matchRelease = builtins.match ".*-release$" name;
              matchGC = builtins.match ".*-gc$" name;
              matchPerf = builtins.match ".*(bench|perf)$" name;
              # Common tests are those that do not match -debug, -release, -gc, or -bench, -perf.
              matchCommon = matchDebug == null &&
                matchRelease == null &&
                matchGC == null &&
                matchPerf == null;
            in {
              debug = matchDebug != null;
              release = matchRelease != null;
              gc = matchGC != null;
              common = matchCommon;
            }.${type})
          tests);

      base-src = pkgs.symlinkJoin {
        name = "base-src";
        paths = [ "${pkgs.sources.motoko-base-src}/src" ];
      };

      core-src = pkgs.symlinkJoin {
        name = "core-src";
        paths = [ "${pkgs.sources.motoko-core-src}/src" ];
      };

      js = import ./nix/moc.js.nix { inherit pkgs commonBuildInputs rts; };

      docs = import ./nix/docs.nix { inherit pkgs js base-src core-src; };

      checks = {
        check-formatting = import ./nix/check-formatting.nix { inherit pkgs; };
        check-rts-formatting = import ./nix/check-rts-formatting.nix { inherit pkgs; };
        check-grammar = import ./nix/check-grammar.nix { inherit pkgs; };
        check-error-codes = import ./nix/check-error-codes.nix { inherit pkgs; };
      };

      nix-update = nix-update-flake.packages.${system}.default;

      shell = import ./nix/shell.nix {
        inherit pkgs nix-update base-src core-src llvmEnv esm viper-server commonBuildInputs rts js debugMoPackages docs test-runner;
        inherit (checks) check-rts-formatting;
      };

      common-constituents = rec {
        samples = import ./nix/samples.nix { inherit pkgs; inherit (debugMoPackages) moc; };
        # TODO: Re-enable base tests once we recalibrate them so they
        # don't OOM anymore.
        # base-tests = import ./nix/base-tests.nix { inherit pkgs; inherit (debugMoPackages) moc; };
        base-doc = import ./nix/base-doc.nix { inherit pkgs; inherit (debugMoPackages) mo-doc; };
        report-site = import ./nix/report-site.nix { inherit pkgs base-doc docs; inherit (tests) coverage; };

        inherit rts base-src core-src docs shell;
      };
    in
    {
      packages = checks // common-constituents // rec {
        release = buildableReleaseMoPackages;
        debug = buildableDebugMoPackages;

        inherit nix-update tests js test-runner;

        inherit (pkgs) nix-build-uncached ic-wasm pocket-ic;

        # Get pocket-ic server.
        pocket-ic-server = pkgs.pocket-ic.server;



        # Platform-specific release files.
        release-files-ubuntu-latest = import ./nix/release-files-ubuntu-latest.nix { inherit self pkgs; };
        "release-files-ubuntu-24.04-arm" = import ./nix/release-files-ubuntu-24.04-arm.nix { inherit self pkgs; };
        release-files-macos-13 = import ./nix/release-files-macos-13.nix { inherit self pkgs; };
        release-files-macos-latest = import ./nix/release-files-macos-latest.nix { inherit self pkgs; };

        # Common tests version - includes non-GC, non-release/debug specific tests.
        common-tests = pkgs.releaseTools.aggregate {
          name = "common-tests";
          constituents = filterTests "common";  # Only include common tests.
        };

        # GC tests version - only includes GC tests.
        gc-tests = pkgs.releaseTools.aggregate {
          name = "gc-tests";
          constituents = filterTests "gc";  # Only include GC tests.
        };

        # Release version - excludes debug tests.
        release-systems-go = pkgs.releaseTools.aggregate {
          name = "release-systems-go";
          constituents =
            pkgs.lib.attrValues common-constituents ++
              pkgs.lib.attrValues checks ++
              pkgs.lib.attrValues buildableReleaseMoPackages ++
              filterTests "release" # Only include release tests.
              ++ builtins.attrValues js;
        };

        # Debug version - only includes debug tests.
        debug-systems-go = pkgs.releaseTools.aggregate {
          name = "debug-systems-go";
          constituents =
            pkgs.lib.attrValues common-constituents ++
              pkgs.lib.attrValues checks ++
              pkgs.lib.attrValues buildableDebugMoPackages ++
              filterTests "debug"  # Only include debug tests
              ++ builtins.attrValues js;
        };

        inherit (debug) moc;

        default = release-systems-go;
      };

      checks = checks // tests;

      devShells.default = shell;

      formatter = pkgs.writeShellScriptBin "formatter" ''
        if [[ $# = 0 ]]; then set -- .; fi
        exec "${pkgs.nixpkgs-fmt}/bin/nixpkgs-fmt" "$@"
      '';
    });
}



================================================
FILE: LICENSE
================================================
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

1. Definitions.

   "License" shall mean the terms and conditions for use, reproduction, and
   distribution as defined by Sections 1 through 9 of this document.

   "Licensor" shall mean the copyright owner or entity authorized by the
   copyright owner that is granting the License.

   "Legal Entity" shall mean the union of the acting entity and all other
   entities that control, are controlled by, or are under common control with
   that entity. For the purposes of this definition, "control" means (i) the
   power, direct or indirect, to cause the direction or management of such
   entity, whether by contract or otherwise, or (ii) ownership of fifty percent
   (50%) or more of the outstanding shares, or (iii) beneficial ownership of
   such entity.

   "You" (or "Your") shall mean an individual or Legal Entity exercising
   permissions granted by this License.

   "Source" form shall mean the preferred form for making modifications,
   including but not limited to software source code, documentation source, and
   configuration files.

   "Object" form shall mean any form resulting from mechanical transformation
   or translation of a Source form, including but not limited to compiled
   object code, generated documentation, and conversions to other media types.

   "Work" shall mean the work of authorship, whether in Source or Object form,
   made available under the License, as indicated by a copyright notice that is
   included in or attached to the work (an example is provided in the Appendix
   below).

   "Derivative Works" shall mean any work, whether in Source or Object form,
   that is based on (or derived from) the Work and for which the editorial
   revisions, annotations, elaborations, or other modifications represent, as a
   whole, an original work of authorship. For the purposes of this License,
   Derivative Works shall not include works that remain separable from, or
   merely link (or bind by name) to the interfaces of, the Work and Derivative
   Works thereof.

   "Contribution" shall mean any work of authorship, including the original
   version of the Work and any modifications or additions to that Work or
   Derivative Works thereof, that is intentionally submitted to Licensor for
   inclusion in the Work by the copyright owner or by an individual or Legal
   Entity authorized to submit on behalf of the copyright owner. For the
   purposes of this definition, "submitted" means any form of electronic,
   verbal, or written communication sent to the Licensor or its
   representatives, including but not limited to communication on electronic
   mailing lists, source code control systems, and issue tracking systems that
   are managed by, or on behalf of, the Licensor for the purpose of discussing
   and improving the Work, but excluding communication that is conspicuously
   marked or otherwise designated in writing by the copyright owner as "Not a
   Contribution."

   "Contributor" shall mean Licensor and any individual or Legal Entity on
   behalf of whom a Contribution has been received by Licensor and subsequently
   incorporated within the Work.

2. Grant of Copyright License. Subject to the terms and conditions of this
   License, each Contributor hereby grants to You a perpetual, worldwide,
   non-exclusive, no-charge, royalty-free, irrevocable copyright license to
   reproduce, prepare Derivative Works of, publicly display, publicly perform,
   sublicense, and distribute the Work and such Derivative Works in Source or
   Object form.

3. Grant of Patent License. Subject to the terms and conditions of this
   License, each Contributor hereby grants to You a perpetual, worldwide,
   non-exclusive, no-charge, royalty-free, irrevocable (except as stated in
   this section) patent license to make, have made, use, offer to sell, sell,
   import, and otherwise transfer the Work, where such license applies only to
   those patent claims licensable by such Contributor that are necessarily
   infringed by their Contribution(s) alone or by combination of their
   Contribution(s) with the Work to which such Contribution(s) was submitted.
   If You institute patent litigation against any entity (including a
   cross-claim or counterclaim in a lawsuit) alleging that the Work or a
   Contribution incorporated within the Work constitutes direct or contributory
   patent infringement, then any patent licenses granted to You under this
   License for that Work shall terminate as of the date such litigation is
   filed.

4. Redistribution. You may reproduce and distribute copies of the Work or
   Derivative Works thereof in any medium, with or without modifications, and
   in Source or Object form, provided that You meet the following conditions:

   a. You must give any other recipients of the Work or Derivative Works a
      copy of this License; and

   b. You must cause any modified files to carry prominent notices stating
      that You changed the files; and

   c. You must retain, in the Source form of any Derivative Works that You
      distribute, all copyright, patent, trademark, and attribution notices
      from the Source form of the Work, excluding those notices that do not
      pertain to any part of the Derivative Works; and

   d. If the Work includes a "NOTICE" text file as part of its distribution,
      then any Derivative Works that You distribute must include a readable
      copy of the attribution notices contained within such NOTICE file,
      excluding those notices that do not pertain to any part of the Derivative
      Works, in at least one of the following places: within a NOTICE text file
      distributed as part of the Derivative Works; within the Source form or
      documentation, if provided along with the Derivative Works; or, within a
      display generated by the Derivative Works, if and wherever such
      third-party notices normally appear. The contents of the NOTICE file are
      for informational purposes only and do not modify the License. You may
      add Your own attribution notices within Derivative Works that You
      distribute, alongside or as an addendum to the NOTICE text from the Work,
      provided that such additional attribution notices cannot be construed as
      modifying the License.

      You may add Your own copyright statement to Your modifications and may
      provide additional or different license terms and conditions for use,
      reproduction, or distribution of Your modifications, or for any such
      Derivative Works as a whole, provided Your use, reproduction, and
      distribution of the Work otherwise complies with the conditions stated in
      this License.

5. Submission of Contributions. Unless You explicitly state otherwise, any
   Contribution intentionally submitted for inclusion in the Work by You to the
   Licensor shall be under the terms and conditions of this License, without
   any additional terms or conditions. Notwithstanding the above, nothing
   herein shall supersede or modify the terms of any separate license agreement
   you may have executed with Licensor regarding such Contributions.

6. Trademarks. This License does not grant permission to use the trade names,
   trademarks, service marks, or product names of the Licensor, except as
   required for reasonable and customary use in describing the origin of the
   Work and reproducing the content of the NOTICE file.

7. Disclaimer of Warranty. Unless required by applicable law or agreed to in
   writing, Licensor provides the Work (and each Contributor provides its
   Contributions) on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
   KIND, either express or implied, including, without limitation, any
   warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or
   FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining
   the appropriateness of using or redistributing the Work and assume any risks
   associated with Your exercise of permissions under this License.

8. Limitation of Liability. In no event and under no legal theory, whether in
   tort (including negligence), contract, or otherwise, unless required by
   applicable law (such as deliberate and grossly negligent acts) or agreed to
   in writing, shall any Contributor be liable to You for damages, including
   any direct, indirect, special, incidental, or consequential damages of any
   character arising as a result of this License or out of the use or inability
   to use the Work (including but not limited to damages for loss of goodwill,
   work stoppage, computer failure or malfunction, or any and all other
   commercial damages or losses), even if such Contributor has been advised of
   the possibility of such damages.

9. Accepting Warranty or Additional Liability. While redistributing the Work or
   Derivative Works thereof, You may choose to offer, and charge a fee for,
   acceptance of support, warranty, indemnity, or other liability obligations
   and/or rights consistent with this License. However, in accepting such
   obligations, You may act only on Your own behalf and on Your sole
   responsibility, not on behalf of any other Contributor, and only if You
   agree to indemnify, defend, and hold each Contributor harmless for any
   liability incurred by, or claims asserted against, such Contributor by
   reason of your accepting any such warranty or additional liability.

END OF TERMS AND CONDITIONS

LLVM EXCEPTIONS TO THE APACHE 2.0 LICENSE

As an exception, if, as a result of your compiling your source code, portions
of this Software are embedded into an Object form of such source code, you may
redistribute such embedded portions in such Object form without complying with
the conditions of Sections 4(a), 4(b) and 4(d) of the License.

In addition, if you combine or link compiled forms of this Software with
software that is licensed under the GPLv2 ("Combined Software") and if a court
of competent jurisdiction determines that the patent provision (Section 3), the
indemnity provision (Section 9) or other Section of the License conflicts with
the conditions of the GPLv2, you may retroactively and prospectively choose to
deem waived or otherwise exclude such Section(s) of the License, but only in
their entirety and only with respect to the Combined Software.

END OF LLVM EXCEPTIONS



================================================
FILE: NOTICE
================================================
Copyright 2020 DFINITY Stiftung

Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed
under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
CONDITIONS OF ANY KIND, either express or implied. See the License for the
specific language governing permissions and limitations under the License.



================================================
FILE: perf-delta.nix
================================================
# This nix derivation calculates a comparison between the performance numbers of two commits.
# This is used on CI (see CI.md).
#
# It runs the old and the new moc on all tests files. If the output is
# identical, it reports that no changes happened.
#
# Else it compares the performance statistics from the `tests.perf` derivation.

{ ref, from, to }:
let
  flake = builtins.getFlake (toString ./.);
  system = builtins.currentSystem;
  pkgs = import flake.inputs.nixpkgs { inherit system; };

  # Wrap in a derivation to fix path to perl in shebang
  diff-stats = pkgs.stdenvNoCC.mkDerivation {
    name = "diff-stats";
    src = ./test/diff-stats.pl;
    phases = [ "installPhase fixupPhase" ];
    buildInputs = [ pkgs.perl ];
    installPhase = ''
      mkdir -p $out/bin
      cp $src $out/bin/diff-stats
    '';
  };

  wasm-hash-for = moc:
    pkgs.stdenvNoCC.mkDerivation {
      name = "wasm-hash";
      src = ./test;
      buildInputs = [ moc ];
      buildPhase = ''
        moc --version
        for file in */*.mo
        do
          # ignore all errors
          echo -n $file
          if timeout 10s moc $file --omit-metadata motoko:compiler -no-check-ir -ref-system-api -o $file.wasm 2>/dev/null
          then echo " ok"
          else echo " failed (ignored)"
          fi
        done

        if ! test -n "$(find . -name \*.wasm -print -quit)"
        then
          echo "No wasm files generated. wasm-hash-for broken?"
          exit 1
        fi
      '';
      installPhase = ''
        sha256sum **/*.wasm > $out
      '';
    };

  checkout = rev: builtins.fetchGit { url = ./.; ref = ref; inherit rev; };

  flakeOf = dir:
    let
      flakePath = builtins.unsafeDiscardStringContext "${dir}";
    in
    builtins.getFlake flakePath;

  baseFlake = flakeOf (checkout from);
  prFlake = flakeOf (checkout to);

  baseMoc = baseFlake.packages.${system}.debug.moc;
  prMoc = prFlake.packages.${system}.debug.moc;

  baseWasm = wasm-hash-for baseMoc;
  prWasm = wasm-hash-for prMoc;

  basePerf = baseFlake.checks.${system}.perf;
  prPerf = prFlake.checks.${system}.perf;
in
pkgs.runCommandNoCC "perf-delta"
{
  nativeBuildInputs = [ pkgs.coreutils diff-stats ];
} ''
  echo "Comparing from ${from} to ${to}:" > $out
  if cmp -s ${baseWasm} ${prWasm}
  then
    echo "The produced WebAssembly code seems to be completely unchanged." >> $out
  fi
  diff-stats \
    ${basePerf}/stats.csv \
    ${prPerf}/stats.csv >> $out;
''



================================================
FILE: .envrc
================================================
# To use this install and setup:
# * direnv: https://direnv.net
# * nix-direnv: https://github.com/nix-community/nix-direnv
# * `cd` to this directory
# * run `direnv allow` (only needs to be done once)
# Then the tools to develop motoko will be loaded automatically.
watch_file nix/*.nix
use flake



================================================
FILE: .mergify.yml
================================================
queue_rules:
  - name: default
    queue_conditions:
      - "#approved-reviews-by>=1"
      - "#changes-requested-reviews-by=0"
      - status-success=verify-common-gc
      - status-success=verify-main-tests
      - base=master
      - label=automerge-squash
    merge_conditions:
      - "#approved-reviews-by>=1"
      - "#changes-requested-reviews-by=0"
      - status-success=verify-common-gc
      - status-success=verify-main-tests
      - base=master
      - label=automerge-squash
    merge_method: squash
    commit_message_template: |
      {{ title }} (#{{ number }})

      {{ body }}

pull_request_rules:
  - name: Automatic merge (squash)
    conditions:
      - "#approved-reviews-by>=1"
      - "#changes-requested-reviews-by=0"
      - status-success=verify-common-gc
      - status-success=verify-main-tests
      - base=master
      - label=automerge-squash
    actions:
      delete_head_branch: {}
      queue:
  - name: Clean up automerge tags
    conditions:
      - closed
    actions:
      label:
        remove:
          - automerge-squash
  - name: Auto-approve auto-PRs
    conditions:
      - author=pr-automation-bot-public[bot]
      - label=automerge-squash
    actions:
      review:
        type: APPROVE
        message: This bot trusts that bot
  - name: Auto-approve changelog/release PR
    conditions:
      - files=Changelog.md
      - "#files=1"
      - label=automerge-squash
    actions:
      review:
        type: APPROVE
        message: A change to `Changelog.md`? I can handle that!
  - name: Auto-approve dependabot PR
    conditions:
      - -merged
      - -closed
      - files=doc/docusaurus/package-lock.json
      - "#files=1"
    actions:
      review:
        type: APPROVE
        message: A change to `doc/docusaurus/package-lock.json`? I can handle that!
      label:
        add:
          - automerge-squash



================================================
FILE: design/asynccps.md
================================================
# Async Await Translation

Based on

"A Selective CPS Transformation",
Lasse R.Nielsen, BRICS1
Department of Computer Science, University of Aarhus, Building 540, Ny Munkegade, DK-8000 Aarhus C, Denmark

https://doi.org/10.1016/S1571-0661(04)80969-1

We start with following (typed) term language:

```
e = x
  | c
  | e @ e
  | \x.e
  | let x = e in e
  | if e then e else e
  | async e
  | await e                // may throw
  | async* e
  | await* e               // may throw
  | while e do e
  | label l e
  | break l e
  | return e
  | try e with x -> e     // evaluate e, handling error x using e.
  | throw e               // throw error e to nearest enclosing handler or async block
```


The aim of the game is to remove async and await and try catch/throw  by a source-to-source translation, leaving as much code as possible in direct-style.

Terms have effect `T` (trivial) or `A` (await) with `T` < `A`. A term has effect `A` if any subterm not enclosed by `async` or `async*` is `await` or `await*`.

The only terms that introduce effect `A` is `await`, `await*`, `try` or `throw` - the effect is masked by its innermost enclosing `async` or `async*` (if any).

Note `await`, `await*`, `try` and `throw` may only occur within an `async` or `async*` block.

The body of every lambda must be trivial.

We write `t` for trivial terms and `e` otherwise. Every trival term is also a non-trivial term since `T` < `A`.

Terms `t` are `await/try/throw` free terms (in the sense that await can only occur within a nested async (with no intervening lambdas)).

Trivial terms can be compiled in direct style by translation `T[t]`.

Non-trivial terms must be cps-converted by translations `C r [e]` and `CPS[e] r`.
Their translations expect a pair `r = (reply,reject)` and `reply` and `reject` continuations (for interpreting early `return` and `throw`). We write `r.reply` and `r.reject` for the obvious projections.
The `reply` continuation only changes when we enter an async block.
The `reject` continuation changes when we enter a `async` or `try`.

The translation `C r [e]` produces a term in cps, taking a single continuation argument.

Since `async` and `try catch` are block structured, we can record the
`reply/reject` continuation in an environment argument, simplifying
the translation by not threading two continuations throughout.


```JS
CPS[ e ] = \\r.C r [e] @ r.reply

where

C r [ t ] =
   \\k. k @ T[ t ]
C r [ t1 e2 ] =
   \\k. let f = T[ t1 ] in C r [ e2 ] @ \\v. k @ (f @ v))
C r [ e1 e2 ] =
   \\k. C r [ e1 ] @ (\\f.C r [ e2 ] @ (\\v. k @ (f @ v))
C r [ let x = t1 in e2 ] =
   \\k.let x = T[t1] in C r [e2] @ k
C r [ let x = e1 in e2 ] =
   \\k.C r [ t1 ] @ (\\x. C r [e2] @ k)
C r [ await t ] =
   \\k.await(T[t1], (k, r.reject))
C r [ await e ] =
   \\k.C r [e] @ (\\v.await(v,(k, r.reject))
C r [ await* t ] =
   \\k.T[t1] (k, r.reject)
C r [ await* e ] =
   \\k.C r [e] @ (\\v.v (k, r.reject))
C r [ if e1 then e2 else e3 ]  =
   \\k.C r [e1] @ (\\b.if b then C r [e1] @ k else C r [e2] @ k)
C r [ if t1 then e2 else e3 ]  =
   \\k.if T[t1] then C r [e1] @ k else C r [e2] @ k
C r [ if e1 then t2 else t3 ]  =
   \\k.C r [e1] @ (\\b.k @ (if b then T[t1] else T[t2])))
C r [ while t1 do e2 ] =
  \\k.
    let rec l = \u. if T[t1] then C r [e2] @ l else k @ u in
    l@()
C r [ while e1 do t2 ] =
  \\k.
    let rec l = \u. C r [e1](\\v.if v then T[t2] ; l @ u else k @ u) in
    l @ ()
C r [ while e1 do e2 ] =
  \\k.
    let rec l = \u. C r [e1] (\\v.if v then C r [e2] @ l else k @ ()) in
    l @ ()
C r [ label l e ] = \\l. C r [e] @ l                 // we use label l to name the success continuation
C r [ break l e ] = \\k. C r [e] @ l                 // discard k, continue from l
C r [ return e ] = \\k. C r [e] @ r.reply      // discard k, exit via r.reply
C r [ try e1 with x -> e2 ] =
  let reject' = \\x. C r [e2] @ k in
  \\k. C (r.reply,reject') [e1] @ k
C r [ throw e] = \\k. C r [e] @ r.reject      // discard k, exit async or try via reject
```

In `C`, an `await` is translated by passing the current continuation `k` and reject continuation `r.reject` (both returning answer type `()`) in the promise and yielding if necessary.

The translation of trivial terms, `T[ _ ]`, is  homomorphic on all terms but `async _` and `async * _`, at which point we switch to the `CPS[-]` translation.
Note `T[await _]`, `T[throw _]` and `T[try _ with _ -> _]`, are (deliberately) undefined (since they cannot have trivial effect `T`.)

```JS
T[ async e ] = spawn (\t.CPS[e] @ ((\v.complete(t,v)),(\e.reject(t,e)))
T[ async* e ] = CPS[e]
T[ x ]= x
T[ c ] = c
T[ \x.t ] = \x.T[t]
T[ t1 t1 ] = T[t1] T[t2]
T[ let x = t1 in t2 ] = let x = T[t1]  in T[t2]
T[ if t1 then t2 else t3] =
   if T[t1] then T[t2] else T[t3]
T[ while t1 do t1 ] =
   while T[t1] do T[t2]
T[ break l t ] =
   break l T[t]
T[ label l t ] =
   label l T[t]
T[ return T[t] ] =
   return T[t]
// if we allow effect(do async e) = effect e (see above), then add case
T[ do async t ] =
   CPS*[e] (\v.completedAsync(v), \e.rejectedAsync(e))
```

We use the following primitives for scheduling actions (that complete asyncs).

```JS
type 'a cont = 'a -> unit;

type 'a result =
    Pending
  | Rejected of error
  | Completed of 'a

type error = ...;

type 'a async = { mutable result : 'a result; mutable waiters: ('a cont * error cont) list }

spawn(f) = let t = async { result = Pending; waiters = [] } in
           schedule (\u.f(t));
           t

yield() = schedule.Next()

// meta-operations for interpreting `async e`

await(t,(k,r)) = match t with
             | {result = Completed v} ->
               schedule (\u.k v);
               yield();
             | {result = Rejected e} -> r e
               schedule (\u.r e);
               yield();
             | {result = Pending} ->
               t.waiters <- (k,r)::t.waiters;
               yield()

complete(t,v) = match t with
             | {result = Pending; waiters} ->
               t.result <- Completed v;
               foreach (reply,_reject) in waiters do
                 schedule(\u.reply(v))
             | {result = _ } -> assert(false)

reject(t,v) = match t with
             | { result = Pending; waiters} ->
               t.result <- Rejected v;
               foreach (_reply,reject) in waiters do
                 schedule(\u.reject(v))
             | { result = _ } -> assert(false)

```

The above translations are flawed:

Consider:

```
async {
  label l
  let x = break l 1 in
    break l (await {2})
}
```

The first call to break occurs in a trivial sub-expression and is compiled to `break l T[1]`
However, the second call to `break l (await{2})` is a non-trivial expression (due to the await()) and compiled as the application to a continuation `C[await{2}] @ l`.

Our remedy is to track the target representation of a source label as either target label (Label) or target continuation (Cont) and
translate accordingly. To handle the translation of (source) `return` to (target) `reply` or `return`, we use a distinguished label `l_ret`.

Thus extend the translations `C[]`, `CPS[]` and `T[]` with an implicit environment argument,`env`, classifying labels and
consulted and modified in select rules. The other cases are unchanged (apart from propagating the `env` argument).

```
C env r [ label l e ] =
  let env' = env[l->Cont] in
  \\l. C env' r [e] @ l        // we use label l to name the success continuation

C env r [ break l e ] =
  assert(env[l] = Cont)
  \\k. C env r [e] @ l        // discard k, continue from l

C env r [ return e ] =
  assert(env[kret] = Cont)
  \\k. C env r [e] @ r.reply   // discard k, using reply

T env [ async e ] =
  let env' = [l_ret->Cont] in
  spawn (\t.CPS env' [e] @ ((\v.complete(t,v)),(\e.reject(t,e)))

T env [ async* e ] =
  let env' = [l_ret->Cont] in
  CPS env' [e]

T env [\x.t] =
  let env' = [l_ret->Label]
  \x.T env' [t]

T env [ break l t ] =
  match env[t] with
  | Cont ->  l @ (T env [t])
  | Label -> break l (T env [t])

T env [ label l t ] =
  let env' = env[l->Label]
  label l (T env' [t])

T env [ return t ] =
  match env[l_ret] with
  | Cont ->  l_ret @ (T env [t])
  | Label -> return (T env [t])
```


Returning to the problematic example, we should now have that label `l` is compiled and used as a continuation in both cases:

```
async {
  label l
  let x = break l 1 in
  break l (await {2})
}
```


AS syntax

```
<exp> ::=
  throw <exp>
  try <exp> { (catch <pat> <exp>)+ }
```



================================================
FILE: design/ContextualDot.md
================================================
# Contextual dot resolution

## Motivation
There is a schism in Motoko between object-oriented (using classes and methods) vs procedural/functional (using types and functions) patterns for defining abstractions. Both have pros and cons that cannot be reconciled in the language as is.

We have special rules for treating arrays, blobs, and text as pseudo objects when used with dot notation. Besides being super ad-hoc, the special status of these functions has repeatedly confused users who tried to find them, e.g., in the Array module.

Functional notation, as required for most of our library functions, has a well-known UX disadvantage in that e.g. code completion does not apply.


## Design
The basic idea is to generalise the typing rule for the dot operator. Given the expression `e.x(args)`:

If e does not have object type, or it is an object with no field `x`, then the field is searched for in the environment.

The search looks for a module that (1) has a (possibly parameterized) type member named `Self` that (can be instantiated such that it) is a supertype of `e`'s type, and (2) has a value member `x` with a function type `x : (t_arg, ...) -> t_res` where `t_arg` (can be instantiated such that it) is a supertype of `e`'s type. Notably these two instantiations do _not_ need to be the same, so a module can export functions with more specialized arguments than its `Self` type.

In case there are multiple modules in the context satisfying these two conditions, we report an ambiguity error. This is to avoid "spooky action at a distance" when reordering definitions/imports.

If a suitable module, say `M`, is found, then the expression is typed as if it was the application `M.x(e, args)` (including possible inference for omitted type arguments).

## Implementation
The resolution happens during type-checking and is completely eliminated when lowering to IR.



================================================
FILE: design/Custom-Sections.md
================================================
== Motoko specific Wasm custom sections

The Motoko compiler produces its own optional custom section named "motoko".

When present, Motoko subsection 0 contains a non-empty vector of UTF-8 encoded
strings in the ASCII subset. It lists the set of record field names or
variant tags, sans further distinction, used by the program.

A tool, such as debugger or decompiler, may use the field names to
construct a map from field/tag hashes occurring in object
representations to symbolic field/tag names.
Due to rare hash collisions, this map may be ambiguous.

Using the notation and definitions of the Wasm reference implementation in OCaml:

```ocaml
let motoko_section_body labels =
  section 0 (vec string) labels (labels <> [])

let motoko_sections motoko =
  custom_section "motoko" motoko_section_body motoko.labels (motoko.labels <> [])
```

The hash function on ASCII strings results in values [0..2^31-1], is given by the following OCaml code:

```ocaml
let hash : string -> int32 = fun s ->
  let open Int32 in

  logand (shift_right_logical minus_one 1) (
    List.fold_left
      (fun s c -> add (mul s (of_int 223)) (of_int (Char.code c)))
      zero
      (Lib.String.explode s)
  )
```

Motoko generates an additional `"enhanced-orthogonal-persistence"` private custom section to
mark Motoko Wasm binaries that rely on IC's support to retain the main Wasm memory on an upgrade, 
cf. [Orthogonal Persistence](OrthogonalPersistence.md).



================================================
FILE: design/DFX-Interface.md
================================================
Stable CLI for dfx
==================

An important way of using the Motoko compiler is via the the `dfx` command,
provided by the [IC SDK](https://internetcomputer.org/docs/current/developer-docs/setup/install), which provides project and package management
support.

This document describes the interface that `moc` and related tools provide to
`dfx`. The goal is that
 * the Motoko developers know which command line flags have to
   be kept stable in order to not break `dfx`, and that
 * the SDK developers have a single place to read about the `moc` interface, and
   a place to express additional requirements (by collaborating on a PR against
   this document.)

This interface includes:
 * nix derivations imported by the IC SDK
 * binaries executed
 * command line arguments and environment variables passed to these binaries
 * where these binaries read files and
 * where these binaries write files, output or temporary
 * where they do _not_ write to, so that upgrading `moc` doesn’t suddenly leave
   artifacts where `dfx` does not expect them

It does not replace proper documentation, but should be kept rather concise.

Nix derivations
---------------

The `motoko` repository defines the following nix derivations, as attributes of
the top-level `default.nix`:

* `moc`: contains `bin/moc`
* `mo-doc`: contains `bin/mo-doc`
* `didc`: contains `bin/didc`
* `base-src`: contains the base package, directly in the top level directory,
  as `*.mo` files. It does not contain extra files (test files, for example)


The `default.nix` file itself takes an optional `system` parameter which is
either `"x86_64-linux"` or `"x86_64-darwin"`, and defaults to
`builtins.currentSystem`.

All binaries are either built statically (Linux) or only use system libraries (macOS).

Compiling Motoko Files to Wasm
------------------------------

In order to compile a Motoko file, `dfx` invokes `moc` with
```
moc some/path/input.mo            \
    -o another/path/output.wasm   \
    { --package pkgname pkgpath } \
    { --actor-alias alias url }   \
    [ --actor-idl actorpath ]     \
    { --public-metadata name }
```
This _reads_ the following files
 * `some/path/input.mo`
 * any `.mo` file referenced by `some/path/input.mo`, either relatively, absolutely or via the provided package aliases
 * for every actor import `ic:⟨canisterid⟩` imported by any of the Motoko files, it reads `actorpath/⟨canisterid⟩.did`, see section “Resolving Canister aliases” below. Here `⟨canisterid⟩` is the textual representation (e.g. `em77e-bvlzu-aq`).

The package name `prim` is special and should not be set using `--package`.

No constraints are imposed where imported files reside (this may be refined to prevent relative imports from looking outside the project and the declared packages)

This _writes_ to `another/path/output.wasm`, but has no other effect. It does
not create `another/path/`.

Compiler warnings and errors are reported to `stderr`. Nothing writes to `stdout`.

Resolving Canister aliases
--------------------------

For every actor imported using `import "canister:alias"`, the Motoko compiler treats that as `import "ic:⟨canisterid⟩"`, if the command line flag `--actor-alias alias ⟨canisterid⟩` is given. Here, `⟨canisterid⟩` is the textual representation (e.g. `em77e-bvlzu-aq`).

The first argument to `--actor-alias` is the alias without the URL scheme. The second argument must be a [textual representation] of the canister id.

The given aliases must be unique (i.e. no `--actor-alias a aaaaa-aa --actor-alias a em77e-bvlzu-aq`).

[textual representation]: https://sdk.dfinity.org/docs/interface-spec/index.html#textual-ids

Resolving Canister types
------------------------

For every actor imported using `import "ic:⟨canisterid⟩"` (or `import "canister:alias"` if `alias` resolves to `ic:⟨canisterid⟩` as described above), the Motoko compiler assumes the presence of a file `⟨canisterid⟩.did` in the actor idl path specified by `--actor-idl`. This file informs Motoko about the interface of that canister, e.g. the output of `moc --idl` for a locally known canister, or the IDL file as fetched from the Internet Computer.

The `⟨canisterid⟩` here refers to the “textual representation“, e.g. `em77e-bvlzu-aq`.

This file informs Motoko about the interface of that canister. It could be the output of `moc --idl` for a locally known canister, or the IDL file as fetched from the Internet Computer, or created any other way.

Open problem: how to resolve mutual canister imports.

Exporting Canister Metadata
---------------------------

The compiler generates various metadata about the canister via command line flags.
The compiled Wasm module also includes these metadata in the custom sections.
The compiler flag `--public-metadata <name>` controls if the custom section is publicly accessible.
If `<name>` is in the `public-metadata` flag, the custom section name will be `icp:public <name>`.
Otherwise, it will be `icp:private <name>`. The `--public-metadata` flag applies to the imported actor classes as well.
In case the emission of a certain metadata section is not desired (e.g. to suppress discoverability, or to make the build
product more reproducible), `--omit-metadata <name>` can be applied to refrain from emitting it. This option should  be
used only in very specific cases.

* Candid interface.
  + Compiler flag `--idl` generates the Candid interface for the entry actor. The main service
    is always a service constructor, which contains the initialization arguments for installing the canister.
  + Custom section `candid:service` stores the interface for the running (initialized) canister, which removes
    the initialization arguments.
  + Custom section `candid:args` stores the initialization arguments. The argument types can refer to
    types defined in the `candid:service` custom section.
* Stable variable.
  + Compiler flag `--stable-types` generates the signatures for stable variables for the entry actor.
  + Custom section `motoko:stable-types` stores the signatures for stable variables.

The above metadata is stored in the Wasm module, and is only accessible by the controllers of the canister, unless the
metadata name is specified in the `--public-metadata` flag.

Moreover, the compiler generates a special marker custom section `"enhanced-orthogonal-persistence"` if the new orthogonal 
persistence support is enabled, see [Orthogonal Persistence](OrthogonalPersistence.md). This section is always private and
always emited independent of the compiler flags `--public-metadata` or `--public-metadata`.

Checking stable type compatibility
----------------------------------

The command
```
moc --stable-compatible old.most new.most
```
checks if the stable interface can evolve from `old.most` to `new.most` in
a type safe way without unintentional data loss.

If the check succeeds, nothing will be printed. 
If the check fails, the error message will be printed in stderr and the command returns with exit code 1.
The check can also emit warning messages, e.g. if stable variables are dropped.

With [enhanced orthogonal persistence](OrthogonalPersistence.md), the stable compatibility is also integrated in the runtime
system, to atomically guarantee memory compatibility during an upgrade.

Listing dependencies
--------------------

The command
```
moc --print-deps some/path/input.mo
```
prints to the standard output all URLs _directly_ imported by
`some/path/input.mo`, one per line. Each line outputs the original
URL, and optionally a full path if `moc` can resolve the URL, separated by a space.
For example,
```
mo:base/List
mo:other_package/Some/Module
ic:em77e-bvlzu-aq
canister:alias
./local_import some/path/local_import.mo
./runtime some/path/runtime.wasm
```
This _reads_ only `some/path/input.mo`, and writes no files.

By transitively exploring the dependency graph using this command (and
resolving URLs appropriately before passing them as files to `moc`), one can
determine the full set of set of `.mo` files read by the two compilation modes
described above (to wasm and to IDL).

Generating documentation
------------------------

In order to generate documentation for a given Motoko package `dfx` invokes
```
mo-doc
    [ --source source_dir ]
    [ --output output_dir ]
    [ --format html|adoc ]
```
The default source directory is `src`, the default output is `docs`, and the default format is `html`.
`mo-doc` will then generate documentation in the output directory mirroring the directory/file structure of the source directory.



================================================
FILE: design/FAQ.md
================================================
> 1. Why would I want an `actor class` versus just a `class`?

An actor is instantiated as a separate wasm instance, with isolated state. Classes can capture (mutable) free variables state, actor classes should not (but currently can because the typechecker is too liberal).

> 2. Where am I permitted to place `async` blocks?

At the moment, anywhere - they get compiled to async message sends to the enclosing (perhaps implicit) actor that return a promise. You might, however, not be able to await the result unless you are in an outer async context! But you could pass in into another async block that can await it.

> 3. What kinds of datatypes are permitted to be declared with the `share` qualifier; and why some but not others (what’s the source of the distinction, and its role in writing motoko-based systems)

Shared means transmittable without losing identity, essentially. So scalars, immutable data, option of shared, shared (immutable objects), shared functions and actor references can be sent/received, but nothing else that might contain or close over mutable state. That's the idea, assuming it isn't broken. Not all restrictions are currently checked (i.e. escape of shared state into actors and shared functions for instance.) Note that serialization is mostly by value, apart from actors and shared functions, which are by reference, so identity can't be preserved for most values, ruling out them containing state.

> 4. Where would I want to define a `class` versus an `object`? (explain that distinction, if possible)

A class is a family of objects of the same type. There used to be support for checked down-casting (instance of) on classes but we got rid of that, so really a class is just a type def plus constructor function (that's actually what it desugars to as well).

> 5. Where would I want to define an `object` versus a `record` (explain that distinction, if possible)

I guess an object would typically encapsulate state, and fields would be private by default (eventhough they aren't currently). Records would have fields public by default. In the end, an object really is just a record of values and any state encapsulation is by virtue of the object having fields that are functions that close over state in their environments. The distinction between shared objects and non-shared ones is that we don't want an object that has a mutable field, and thus isn't sharable, to become sharable just by virtue of forgetting that field through subtyping. That was the intention anyway.

> 6. What types permit mutation and how is that expressed; what restrictions come with using mutable memory?

Just mutable arrays, mutable fields of objects and mutable locals. Mutable types can't be transmitted or received in messages (shared function calls). There's no first class ref type but one can simulate that with an object with a single mutable field.



================================================
FILE: design/GraphCopyStabilization.md
================================================
# Graph-Copy-Based Stabilization

This is part of the enhanced orthogonal persistence support, see [Orthogonal Persistence](OrthogonalPersistence.md).

## Purpose
This allows future potentially radical changes of the persistent memory layout, such as introducing a new GC, rearranging persistent metadata, or specializing arrays for small element types etc. 
This also relies on precise value tagging to allow more advanced changes that require value metadata, e.g. specializing arrays for small value element types or even downgrading to 32-bit heap layouts (provided that the amount of live data fits into a 32-bit memory).

## Design
Graph copy of sub-graph of stable objects from main memory to stable memory and vice versa on upgrades.

## Properties
* Preserve sharing for all objects like in the heap.
* Allow the serialization format to be independent of the main memory layout.
* Limit the additional main memory needed during serialization and deserialization.
* Avoid deep call stack recursion (stack overflow).
* Allows arbitrarily long large stabilization/destabilization due to incremental mechanism (see below).

## Memory Compatibility Check
Apply a memory compatibility check analogous to the enhanced orthogonal persistence, since the upgrade compatibility of the graph copy is not identical to the Candid subtype relation.

## Incremental Upgrade
Supporting arbitrarily large upgrades beyond the instruction limit:
* Splitting the stabilization/destabilization in multiple asynchronous messages.
* Limiting the stabilization work units to fit the update or upgrade messages.
* Blocking other messages during the explicit incremental stabilization.
* Restricting the upgrade functionality to the canister owner and controllers.
* Stopping the GC during the explicit incremental upgrade process.

**Note**: Graph copying needs to be explicitly initiated as the usual upgrade engages enhanced orthogonal persistence, simply retaining main memory with compatibility check.

### Usage
When upgrading to a Motoko version that is not compatible with the current enhanced orthogonal persistence:

1. Initiate the explicit stabilization before the upgrade:
    
```
dfx canister call CANISTER_ID __motoko_stabilize_before_upgrade "()"
```

* An assertion first checks that the caller is the canister owner or a canister controller.
* All other messages to the canister will be blocked until the upgrade has been successfully completed.
* The GC is stopped.
* If defined, the actor's pre-upgrade function is called before the explicit stabilization.
* The stabilzation runs in possibly multiple asynchronous messages, each with a limited number of instructions.

2. Run the actual upgrade:

```
dfx deploy CANISTER_ID
```

* Completes the explicit stabilization if not yet done before this call.
* Perform the actual upgrade of the canister on the IC.
* Detects that graph-copying is in use.
* Clears the heap if enhanced orthogonal persistence is active.
* Start the destabilization with a limited number of steps to fit into the upgrade message.
* If destabilization cannot be completed, the canister does not start the GC and does not accept messages except step 3.

3. Complete the explicit destabilization after the upgrade:

```
dfx canister call CANISTER_ID __motoko_destabilize_after_upgrade "()"
```

* An assertion checks that the caller is the canister owner or a canister controller.
* All other messages remain blocked until the successful completion of the destabilization.
* The destabilzation runs in possibly multiple asynchronous messages, each with a limited number of instructions.
* If defined, the actor's post-upgrade function is called at the end of the explicit destabilization.
* The GC is restarted.

### Remarks
* When receiving the `dfx` error "The request timed out." during explicit stabilization, upgrade, or destabilization, one can simply repeat the call until it completes.
* Steps 3 (explicit destabilization) may not be needed if the corresponding operation fits into the upgrade message.
* Stabilization and destabilization steps are limited to the increment limits:

    Operation | Message Type | IC Instruction Limit | **Increment Limit**
    ----------|--------------|----------------------|--------------------
    **Explicit (de)stabilization step** | Update | 20e9 | **16e9**
    **Actual upgrade** | Upgrade | 200e9 | **160e9**

* The graph copy steps also limit the amount of processed stable data (read or write), in order not to exceed the 
IC's stable memory access limits.

    Operation | Message Type | IC Stable Access Limit | **Increment Limit**
    ----------|--------------|----------------------|--------------------
    **Explicit (de)stabilization step** | Update | 2 GB | **1 GB**
    **Actual upgrade** | Upgrade | 8 GB | **6 GB**

## Graph-Copy Algorithm
Applying Cheney’s algorithm [1, 2] for both serialization and deserialization:

### Serialization
* Cheney’s algorithm using main memory as from-space and stable memory as to-space: 
* Focusing on stable variables as root (sub-graph of stable objects).
* The target pointers and Cheney’s forwarding pointers denote the (skewed) offsets in stable memory.
* Using streaming reads for the `scan`-pointer and streaming writes for the `free`-pointer in stable memory.

### Deserialization
* Cheney’s algorithm using stable memory as from-space and main memory as to-space: 
* Starting with the stable root created during the serialization process.
* A scan stack is used in the main memory to remember the deserialized objects for later scanning.
* Objects are allocated in main memory using the default allocator.
* Using random read/write access on the stable memory.

## Stable Format
For a long-term perspective, the object layout of the serialized data in the stable memory is fixed and independent of the main memory layout.
* Pointers are represented in 64-bit like main memory in enhanced orthogonal persistence.
* The Brooks forwarding pointer used by the incremental GC is omitted.
* The pointers encode skewed stable memory offsets to the corresponding target objects.
* References to the null objects are encoded by a defined null sentinel value.
* `BigInt` are explicitly serialized in a defined portable little endian representation, without that the serialization or deserialization allocates temporary objects.
The format is also versioned to allow future refinements of the graph copy algorithm.

## Specific Aspects
* Field hashes in objects are serialized in a blob. On deserialization, the hash blob is allocated in the dynamic heap. Same-typed objects that have been created by the same program version share the same hash blob.
* Stable records can dynamically contain non-stable fields due to structural sub-typing. A dummy value can be serialized for such fields as a new program version can no longer access this field through the stable types.
* For backwards compatibility, old Candid destabilization is still supported when upgrading from a program that used older compiler version.
* Incremental GC: Serialization needs to consider Brooks forwarding pointers (not to be confused with the Cheney's forwarding information), while deserialization can deal with partitioned heap that can have internal fragmentation (free space at partition ends).
* The partitioned heap prevents linear scanning of the heap, especially in the presence of large objects that can be placed at a higher partition than subsequently allocated normal-sized objects. For this reason, a scan stack is allocated in the main memory, remembering the deserialized objects that still need to be scanned. With this, the deserialization does not need to make any assumptions of the heap structure (e.g. monotonically increasing allocations, free space markers, empty heap on deserialization start etc.).
* If actor fields are promoted to the `Any` type in a new program version, their content is released in that variable to allow memory reclamation.
* Both stabilization and destabilization read and write data linearly, which is beneficial for guarding a work set limit (number of accessed pages) per IC message. Destabilization is also linear because it deserializes objects in the same order back as they have been serialized.

## Open Aspects
* Unused fields in stable records that are no longer declared in a new program versions should be removed. This could be done during garbage collection, when objects are moved/evacuated. This scenario equally applies to enhanced orthogonal persistence.
* The scan stack used during destabilization involves dynamic allocations.

## References

[1] C. J. Cheney. A Non-Recursive List Compacting Algorithm. Communications of the ACM, 13(11):677-8, November 1970.

[2] R. Jones and R. Lins. Garbage Collection: Algorithms for Automatic Dynamic Memory Management. Wiley 2003. Algorithm 6.1: Cheney's algorithm, page 123.



================================================
FILE: design/IDL-Motoko.md
================================================
The IDL-Motoko integration
===============================

## Goals

This document specifies the integration of the IDL with the Motoko
language, in particular:

 * How to translate between an Motoko `actor` type and an IDL `service`
   description in both ways (i.e. _exporting_ IDL from Motoko, and _importing_
   IDL into Motoko), and how to translate between the values of these types.

 * The supported work-flows, including a sketch of the involved tools.

We try to achieve the following goals (but do not achieve them completely)

 * We can round-trip all Motoko values of sharable type. More precisely:

   When exporting an Motoko type `ta` into an IDL type `ti`, then
   round-tripping a value `va : ta` through `ti` yields a value that is
   indistinguishable from `va` at type `ta`.

 * Motoko can receive all IDL types: The type export has an inverse, the
   type import mapping, which is injective (up-to IDL type equivalence via
   shorthands).

 * Motoko can receive all IDL values when importing an IDL:

   When importing an IDL type `ti` into `ta`, then every IDL value `vi : ti`
   will successfully translated to an Motoko value of type `ta`.

The following are not necessary true:

 * The type export mapping is not total: there are Motoko types that cannot
   be exported, such as mutable arrays.

 * The type export mapping is not injective: there may be different
   Motoko types that map to the same IDL type, e.g. `Char`, `Nat32` and
   `Nat32`.

   This implies that round-tripping an Motoko type via the IDL can yield
   different types.

 * The type export mapping is not surjective: there are Candid types that
   cannot be imported, in particular types with `service` types with methods
   names that are no valid identifiers in Motoko.

 * For some types, not all IDL values may be accepted: for example, `Char` is
   may be exported as `nat32`, but not all `nat32` values can be read as
   `Char`. This can only be the case for types not in the image of the type
   import mapping.

NB: These properties (and non-properties) are not specific to Motoko, and
we expect that they will hold similarly for interfaces to other typed languages
with seamless serialization (e.g. built-in, macro or type class based
integration). In this sense, this document serves as a blueprint. Untyped
languages or languages with a code-generation workflow may have a different
story.

## The type mappings

We define
 * a partial function `e` from Motoko types to IDL types.
   Types that are not in the domain of `e` cannot be exported.
 * a partial function `i` from IDL types to Motoko types.
   Types that are not in the domain of `i` cannot be imported.

These definition treats Motoko types and IDL types as structural and
infinite; a concrete implementation will have to look through type constructors
in Motoko and introduce type definitions in the IDL as necessary.

It assumes that the IDL short-hands (e.g. named or anonymous fields)
are part of the grammar of types, and that `i` is allowed to make difference
choices for types that are short-hands.

The function is defined with regard to the grammars in [IDL.md](IDL.md) and [Syntax.md](Syntax.md).

### Type export

```
e : <typ> -> <datatype>
e(Null) = null
e(Bool) = bool
e(Nat) = nat
e(Int) = int
e(Nat<n>) = nat<n> for n = 8, 16, 32, 64
e(Int<n>) = int<n> for n = 8, 16, 32, 64
e(Float) = float64
e(Char) = nat32
e(Text) = text
e(Blob) = blob
e(Principal) = principal
e({ <typ-field>;* }) = record { ef(<typ-field>);* }
e(variant { <typ-field>;* }) = variant { ef(<typ-field>);* }
e([<typ>]) = vec (e(<typ>))
e(? <typ>) = opt (e(<typ>))
e(shared <typ1> -> <typ2>) = func (efn(shared <typ1> -> <typ2>))
e(actor { <typ-field>;* }) = service { em(<typ-field>);* }
e( () ) = null
e( ( <typ>,+ ) ) = record { e(<typ>);+ }
e(Any) = reserved
e(None) = empty

ef : <typ-field> -> <fieldtype>
ef (<id> : <typ>) = unescape(<id>) : e(<typ>)

efn : <typ> -> <functype>
efn(shared <typ> -> ()) = ea(<typ>) -> () oneway
efn(shared query? <typ1> -> async <typ2>) = ea(<typ1>) -> ea(<typ2>) query?

ea : <typ> -> <argtype>,*
ea( ( <typ>,* ) ) = e(<typ>);*
ea(<typ>) = ( e(<typ>) )  otherwise

em : <typ-field> -> <methtype>
em(<id> : <typ>) = unescape_method(<id>) : efn(<typ>)

unescape : <id> -> <nat>|<name>
unescape("_" <nat> "_") = <nat>  if <nat> is 32-bit
unescape(<id> "_") = <id>
unescape(<id>) = <id>

unescape_method : <id> -> <name>
unescape_method(<id> "_") = <id>
unescape_method(<id>) = <id>
```

### Type import

```
i : <datatype> -> <typ>
i(null) = Null
i(bool) = Bool
i(nat) = Nat
i(int) = Int
i(nat<n>) = Nat<n> for n = 8, 16, 32, 64
i(int<n>) = Int<n> for n = 8, 16, 32, 64
// i(float32) not defined
i(float64) = Float
i(text) = Text
i(reserved) = Any
i(empty) = None
i(opt <datatype>) = ? i(<datatype>)
i(vec <datatype>) = [ i(<datatype>) ]
i(blob) = Blob
i(record { <datatype>;^N }) = ( i(<datatype>),^N ) if n > 1 // matches tuple short-hand
i(record { <fieldtype>;* }) = { if(<fieldtype>);* }
i(variant { <fieldtype>;* }) = variant { ivf(<fieldtype>);* }
i(func <functype>) = ifn(<functype>)
i(service { <methtype>;* }) = actor { im(<methtype>);* }
i(principal) = Principal

if : <fieldtype> -> <typ>
if(<name> : <datatype>) = escape(<name>) : i(<datatype>)
if(<nat> : <datatype>) = escape_number(<nat>) : i(<datatype>) // also for implicit labels

ivf : <fieldtype> -> <typ>
ivf(<name> : null) = escape(<name>) : ()
ivf(<nat> : null) = "_" <nat> "_": ()
ivf(<fieldtype> = if(<fieldtype>) otherwise

ifn : <functype> -> <typ>
ifn((<datatype>,*) -> () oneway) = shared ia(<datatype>) -> ()
ifn((<datatype1>,*) -> (<datatype2>,*) query?) = shared query? ia(<datatype1>,*) -> async ia(<datatype2>,*)

ia : <argtype>,* -> <typ>
ia(<argtype>,) = i(<argtype>)
ia(<argtype>,*) = ( i(<argtype>),* )  otherwise

im : <methtype> -> <typ>
im(<name> : <functype>) = escape_method(<name>) : ifn(<functype>)

escape_number <nat> = "_" <nat> "_"

escape : <name> -> <id>
escape <name> = <name> "_"  if <name> is a reserved identifier in Motoko
escape <name> = <name> "_"  if <name> is a valid Motoko <id> ending in "_"
escape <name> = <name>  if <name> is a valid Motoko <id> not ending in "_"
escape <name> = escape_number(hash(<name>))  otherwise

escape_method : <name> -> <id>
escape_method <name> = <name> "_"  if <name> is a reserved identifier in Motoko
escape_method <name> = <name> "_"  if <name> is a valid Motoko <id> ending in "_"
escape_method <name> = <name>  if <name> is a valid Motoko <id> not ending in "_"
escape_method <name> = (* failure, unsupported *)
```

### Notes:

 * Up-to short-hands, `i` is injective and the right-inverse of `e`.

   Formally: For all IDL types `t ∈ dom i`, we have that `e(i(t))` is equivalent to
   `t`, i.e. either they are the same types, or short-hands of each other.

 * Non-empty tuples are exported using the unnamed field short-hand, which is how tuples
   are idiomatically expressed in the IDL:
   ```
   e((Int, Nat)) = record {int;nat}
   e({i:Int, n:Nat}) = record {i:int; n:nat}
   e({_0_:Int, _1_:Nat}) = record {0:int; 1:nat}
   ```

 * The mapping `i` tries to detect types that can be expressed as
   tuples in Motoko.
   ```
   i(record {int;nat}) = (Int, Nat)
   i(record {int; nat; foo:text}) = {_0_:Int; _1_:Nat; foo:Text}
   i(record {0:int, 1:nat}) = {_0_:Int; _1_:Nat}
   ```

   But note that

   * `i(record {}) ≠ ()` because `e(()) = null` and we want
     `e(i(record {})) = record {}`.

   * `i(record {int}) ≠ (int,)` because we do not have unary tuples in AS.
     Instead, `i(record {int}) = { _0_ : int}` so that `e(i(record {int})) =
     record {int}`.

 * The `escape` and `unescape` functions allow round-tripping of IDL field
   names that are not valid Motoko names (fake hash values):
   ```
   i(record {int; if:text; foobar_:nat; "_0_":bool})
     = {_0_:Int; if_:Text; _1234_:Nat; _4321_:Bool}
   ```
   This is another source of partiality for `e`:
   ```
   e({clash_ : Nat; clash : Int})
   ```
   is undefined, because `unescape(clash_) = unescape(clash)`.

 * Similarly, the `escape_method` and `unescape_method` functions append `_` to
   method names in Candid that happen to be reserved keywords in Motoko.

   Candid method names that are _not_ valid identifiers in Motoko are
   unsupported.

 * Motoko functions with type parameters are not in the domain of `e`.

 * Abstract Motoko types are not in the domain of `e`

 * The translation produces IDL functions without parameter names.  But both
   the IDL and Motoko conveniently support non-significant  names in
   parameter lists. These are essentially comments, and do not affect, for
   example, the type section in a message, so it is not necessary to specify
   them here.

   But tooling (e.g. `moc` exporting an IDL from an Motoko type) is of
   course free to use any annotations in the Motoko type (or even names
   from pattern in function definitions) also in the exported IDL.

 * The soundness of the Motoko type system, when it comes to higher-order
   use of actor and function references, relies on
   ```
   ∀ t1 t2 : dom(e), t1 <: t2 ⟹ e(t1) <: e(t2)
   ```
   In other words: Motoko subtyping must be contained in IDL subtyping.

 * There is no way to produce `float32`.
   Importing interfaces that contain `float32` types fails.

 * The functions `escape`/`unescape` ensure round-tripping of IDL field names
   through Motoko types. See `IDL-Motoko.proofs.md` for details.

## The value mappings

For each Motoko type `t` in the domain of `e`, we need mapping from
Motoko value of type `t` to an IDL value of type `e(t)`, and vice-versa.

Note that decoding may only fail for those `t` that are not in the range of `i`.

These mappings should be straight-forward, given the following clarifications:

* Characters (of type `Char`) are mapped to their Unicode scalar as a `nat32`.
  Decoding a `nat32` that is not a valid Unicode scalar fails.

## Type name mangling

The name of type definition or services are irrelevant with regard to whether
the resulting imported/exported types are correct, as both Motoko and IDL
employ structural typing. Nevertheless, when the type export or import has to
produce such identifiers, it tries to preserve the original name. This is a
best effort approach.

If it happens that such a name is invalid (e.g. reserved) in the target
language, a `"_"` is appended during translation.

Conversely, a name of the form `<id> "_"` is translated  to `<id>`, if the
latter is legal in the target language.

## Work flows

The mapping specified here can be used to support the following use-cases. The
user interfaces (e.g. flag names, or whether `moc`, `didc`, `dfx` is used) are
just suggestions.

* Generating IDL from Motoko

  If `foo.mo` is an Motoko `actor` compilation unit, then

      moc --idl foo.mo -o foo.did

  will type-check `foo.mo` as `t = actor { … }`, map the Motoko type `t`
  to an IDL type `e(t)` of the form `service <actortype>`, and produce a
  textual IDL file `foo.did` that ends with a `service n : <actortype>`,
  where `n` is the name of the actor class, actor, or basename of the source
  file.

* Checking Motoko against a given IDL

  If `foo.mo` is an Motoko `actor` compilation unit and `foo.did` a
  textual IDL file, then

      moc --check-idl foo.did foo.mo -o foo.wasm

  will import the type service `t_spec` specified in `foo.did`, using the
  mapping `i`, will generate an IDL type `e(t)` as in the previous point, and
  and check that `e(t) <: t_spec` (using IDL subtyping).

* Converting IDL types to Motoko types

  If `foo.did` a textual IDL file, then

      didc foo.did -o foo.mo

  will create an Motoko library unit `foo.mo` that consists of type
  definitions.
  All `<def>`s and the final `<actor>` from `foo.did` is turned into a `type`
  declaration in Motoko, according to `i`.
  Imported IDL files are recursively inlined.

  Variant: Imported IDL files are translated separately and included via
  `import` in Motoko.

* Importing IDL types from the Motoko compiler

  If `path/to/foo.did` a textual IDL file, then a declaration

      import Foo "path/to/foo"

  is treated by `moc` by reading `foo.did` as if  the developer had
  run `didc path/to/foo.did -o path/to/foo.mo`.



================================================
FILE: design/IDL-Motoko.proofs.md
================================================
Proofs related to IDL-Motoko.md
===============================

Field name escaping
-------------------

### Assumptions

```
isReserved : String -> Bool
isValid : String -> Bool

A1: ∀s. isReserved s -> isValid s
A2: ∀s. ¬isReserved (s "_")
A3: ∀s. isValid s -> isValid (s "_")
A4: ∀n. isValid ("_" n "_")
A5: ∀s. ¬isReserved ("_" s)
A6: ∀n. ¬isValid ("")
```

### Definitions

```
escape_number <nat> = "_" <nat> "_"

// IDL name to Motoko
escape : <name> -> <id>
escape <name> = <name> "_"  if <name> is a reserved identifier in Motoko
escape <name> = <name> "_"  if <name> is a valid Motoko <id> ending in "_"
escape <name> = <name>  if <name> is a valid Motoko <id> not ending in "_"
escape <name> = escape_number(hash(<name>))   otherwise

// Motoko to IDL
unescape : <id> -> <nat>|<name>
unescape("_" <nat> "_") = <nat>
unescape(<id> "_") = <id>
unescape(<id>) = <id>
```

### Properties

**Prop 1**: The range of escape is in the set of valid Motoko field names.
`∀ s. isValid(escape(s)) ∧ ¬ isReserved(escape(s))`

**Proof**: Case analysis according to the definition of `escape`:
1. If `s` is a reserved identifier, then `isValid(s)` by A1 and `isValid(escape(s))` by A3, and also `¬ isReserved(escape(s))` by A2.
2. If `isValid(s)` and `s` ends in `"_"`, then `isValid(escape(s))` by A3 and `¬ isReserved(escape(s))` by A2.
3. If `isValid(s)` and `¬ isReserved(escape(s))`, then the thesis follows from `escape(s) = s`.
4. by A4 and A2

**Prop 2**: `∀s1 s2, escape(s1) = escape(s2) → hash(s1) = hash(s2)`
**Proof**: The four equations of `escape` have disjoint ranges: Only equation 3 produces output not ending in `"_"`, only equation 4 produces output beginning in `"_"` and ending in exactly one `"_"` (due to A6, A1), only equation 1 produces output beginning with no `"_"` and ending with exactly one `"_"` (due to A2, A5, A6), only equation 2 produces output ending in more than one `"_"`.

Therefore it suffices to look at each equation separately. Equations 1-3 are injective, and equation 4 is injective up-to `hash(…)`, because `escape_number` is injective.

**Prop 3**: If `unescape(escape_number(n)) = m:nat`, then `n = m`.

**Proof**: By definition.

**Prop 4**: If `unescape(escape_number(n)) = i:id`, then `hash(i) = n`.

**Proof**: The assumption is never true, by definition.

**Prop 5**: If `unescape(escape(i)) = m:nat`, then `hash(i) = m`.

**Proof**: By construction of `escape`, `unescape(escape(i))` is only a number in the fourth case of `i`, so we have `m = unescape(escape_number(hash(i))) = hash(i)`.

**Prop 6**: If `unescape(escape(i1)) = i2:id`, then `hash(i1) = hash(i2)`.

**Proof**: By cases on `escape`.
1. `escape(i1)` does not match the first equation of `unescape` (by A5), but the second, so we have `i2 = unescape(i1 "_") = i1`.
2. `escape(i1)` does not match the first equation of `unescape` (by construction), but the second, so we have `i2 = unescape(i1 "_") = i1`.
3. `escape(i1)` does not match the first or second equation of `unescape` (by construction), but the second, so we have `i2 = unescape(i1) = i1`.
3. `escape(i1)` matches the first equation of `unescape`, so the output is a number, not an id, so the assumption of the proposition is false.

**Prop 7**: The range of `unescape` contains all `<nat>`

**Proof**: For all `n`, `unescape("_" n "_") = n`.



================================================
FILE: design/Implementation.md
================================================
# Motoko Implementation Strategy

## Subtyping

* All subtyping is non-coercive and thus zero-cost and higher-order.

* Q: Also have first-order implicit coercibility?


## Heap

* Uniform representation with a defined word size. 
For [enhanced orthogonal persistence](OrthogonalPersistence.md), 64-bit words are used, while for classical persistence, the word size is 32-bit.

* Use pointer tagging in the LSB:
  - 1 for pointers, 0 for scalars.
  - Scalars are real value shifted left by 1, lowest bit clear.
  For [enhanced orthogonal persistence](OrthogonalPersistence.md), the types of scalars are additionally tagged.
  
* Garbage collected.


## Primitive types

* Nat and Int compile to heap-allocated big nums; unboxed for small numbers `<= 31` bit.

* Nat8/16 compile to unboxed scalars; 
  On a 32-bit heap, Nat32/64 are boxed. 
  On a 64-bit heap, only Nat64 is boxed, while Nat32 remains unboxed.
  - May unbox locally.

* Characters are scalars (unicode code points).

* Text is heap-allocated. Using ropes for concatenations.


## Tuples

* Heap-allocated when first-class.

* Flattened when used as function parameter or result.

* Q: How to avoid calling convention mismatch when instantiating polymorphic function with tuple type?
  - Don't make tuples subtypes of Any, thereby disallowing their use in instantiation?


## Options

* Represent null as null pointer.

* Q: union or sum?
  - If union, don't make it subtype of Any?
  - If sum, use coercibility?


## Objects

* Compile to heap-allocated lookup table over field name hashes.
  - Either as hash table or ordered list.

* Records of closures and regular public fields; private fields are closed over.

* Field names are hashed; hashes are required to be unique per type.


## Functions

* Compile to heap-allocated closures as usual.

* Definitions lifted to the surrounding actor.

* Closed-over locals need indirection through heap if mutable or if definedness cannot be proved.


## Actor Objects

* Compile to immediately instantiated modules.

* Private fields become regular globals or functions.

* Public methods become exported functions.
  - In general, have to generate wrapper functions to forward external calls to pre-existing local closure.

* Instantiate via hypervisor; build record of functions forwarding to extracted funcrefs.

* Closed-over definitions must be turned into imports.
  - Types directly mapping to Wasm types become (immutable) global imports.
  - Q: What about heap-allocated types? Serialise?
  - Q: What about functions?
  - Q: Disallow closing over mutable definitions?
  - Q: What about definedness checks?

* Closure imports are pre-bound via hypervisor interface.


## Actor Classes

* Constructor compiles to function instantiating the actor object.


## Async

TODO


## Serialisation

TODO

## Persistence

Different * [persistence modes](OrthogonalPersistence.md):
* [Enhanced orthogonal persistence](OrthogonalPersistence.md).
* [Classical persistence](OldStableMemory.md).

# Hypervisor Extensions needed

* Closures as funcrefs?

* Binding imports for modulerefs

* Efficiently extract all exports from an actor
  - as sequence of reference in an elembuf?



================================================
FILE: design/Memory.md
================================================
# Memory Management and Persistence in Wasm/IC/Motoko

## Preliminaries

### Wasm

#### Values

Wasm has two kinds of data (assuming the upcoming reference type proposal):

* *Numerics* (int32/64, float32/64): *transparent* data; bit pattern observable; can be stored in memory
* *References* (anyref, funcref, ...): *opaque* data; representation not exposed, usually implemented as pointers; can be stored in tables but not memory

#### State

Wasm currently has 3 forms of mutable state, all of which can be ex/imported from a module as concrete entities:

* *Globals*: can each store a single value; can be mutated (if defined as mutable)
* *Memory*: an array of raw bytes; can be mutated and grown; can store numeric values
* *Tables*: an array of references; can be mutated and grown; can store reference values

A reference can also point to *host objects* provided by the embedder, which could introduce additional forms of state at the embedder's discretion.

#### Further Evolution

In the future (with the GC proposal), Wasm will have a 4th form of mutable state:

* *Heap*: memory area used for allocating GCed structures; distinct from Memory; controlled by VM

The Heap is *not* an explicit entity that can be im/exported, only individual references to structures on the heap can be passed.

Note: It is highly likely that several managed languages implemented on Wasm will eventually use Wasm GC.
However, in our case, it would require snapshotting the Wasm managed heap which is currently not possible for `wasmtime`.
Moreover, the GC implemented on the managed heap does probably not fit the IC with hard instruction limits. 
A fully incremental GC would be needed, which is currently not implemented in any Wasm engine (often only using reference counting or a GC that has worst-case unbounded pauses).
Conceptually, enhanced orthogonal persistence could be implemented on Wasm GC.

### Internet Computer (IC)

#### API Types

The Hypervisor API introduces a set of Wasm host reference types to represent actors, functions, and their arguments:

* *Modules*: a reference to a compiled but not yet instantiated actor (Wasm module); can be linked and instantiated multiple times
* *Actors*: a reference to an instantiated and active actor
* *Functions*: a reference to an exported actor method; invoking it initiates an asynchronous message send
* *Data buffers*: a reference to an immutable array of bytes; used to pass binary data or aggregates of numeric values along messages
* *Element buffers*: a reference to an immutable array of references; used to pass aggregates of references along messages

All references are *sharable*, i.e., can be passed between actors as message arguments.
Other than actors, all reference types must be pure (immutable and without identity) to prevent shared state and allow transparent copying by the implementation.
Element buffers can encode arbitrary object trees.

## Language Implementation Rationales

### Representing Data Structures

There are 3 possible ways of representing structured data in Wasm/IC.

#### Using Wasm Memory <- Chosen Design

All data structures are laid out and managed in Wasm memory by the compiler and the runtime system.
Function references are stored via indirections through a Wasm table.

   Pros:
   1. local data access maximally efficient
   2. may ease transparent persistence (see below)

   Cons:
   1. message arguments require de/serialisation into IC buffers on both ends (in addition to the de/serialisation steps already performed by IC)
   2. each actor must ship its own instance of a GC (for both memory and table) and de/serialisation code
   3. all function references require an indirection
   4. more implementation effort

#### Using IC API

All data structures are mapped to element and data buffers created through the API.

   Pros:
   1. quickest to implement and get off the ground
   2. no extra de/serialisation step for message sends
   3. easy transition path to Wasm Heap

   Cons:
   1. local access to data involves system call overhead
   2. requires adding mutable buffer types to IC API
   3. mixed numeric/reference structures must be split into data and element buffers
   4. IC-only solution unlikely to be adopted by other languages

#### Using Wasm Heap

All data structures are represented as Wasm GCed objects.

   Pros:
   1. local access should be as fast as Memory
   2. GC is handled by VM
   3. no extra de/serialisation step for message args (provided IC API can handle Wasm structs)
   4. can freely mix numerics and references
   5. this is likely the route most future languages compiling to Wasm will take

   Cons:
   1. Wasm GC is 1-2 years out
   2. unclear how to implement transparent persistence (see below)

## Persistence

Different * [persistence modes](OrthogonalPersistence.md):
* [Enhanced orthogonal persistence](OrthogonalPersistence.md).
* [Classical persistence](OldStableMemory.md).



================================================
FILE: design/Mixins.md
================================================
# Mixins

Mixins allow defining parts of an actor in their own file and then _including_ it into another actor.

## Mixed counter example

``` motoko
// File mixins/CounterMixin.mo
mixin(incAmount : Nat) {
  var counter : Nat = 0;
  public func inc() : async () {
    counter += incAmount;
  };
};
```

``` motoko
import CounterMixin "mo:mixins/CounterMixin";

persistent actor {
  include CounterMixin(2);
  public func incAndGet() : async Nat {
    await inc();
    counter
  };
}
```

When an actor includes a mixin it adds its declarations to its body. `public` definitions of the mixin also become part of the interface of the including actor. The actor has access to the `private` fields, types and methods of the mixin. Access to private fields is required, so that a migration expression on the main actor can migrate the composition of actor and mixin.

The fields of an actor are `stable` by default, even when included in legacy, non-persistent actors.

Mixins can be parameterized over arguments that are bound as transient lets (with renaming so they don't conflict with existing definitions). This means that if you want the mixin to have access to state of the including actor you can't just pass a variable reference, but need to wrap it up in an object. Passing already mutable objects like `core/Map`, `core/List`, `[var A]` works just fine.



================================================
FILE: design/OldStableMemory.md
================================================
# Old Stable Memory API

This describes the legacy stable memory mechanism intended to be replaced by 
true orthogonal persistence where the main memory is retained across upgrades.
See `OrthogonalPersistence.md`.

The current implementation of stable variables is based on
serialization and deserialization of all stable data on upgrade. This
clearly doesn't scale to large amounts of stable data as there may not
be enough cycles to perform (de)serialization.

To avoid this upgrade hazard, some canisters with low-level API
access, and large stable memory footprints, arrange to store their
persistent data in stable memory at all times, using either a custom
binary encoding or a mixture of candid and raw binary.

To provide more fine-grained access to stable memory we propose
extending the existing stable variable implementation with an orthogonal,
library providing (almost) direct access to the IC Stable Memory API.

Since the implementation of stable variables itself makes temporary use of
stable memory, some coordination between these two alternative, co-existing
interfaces to IC stable memory is required.


# The IC's Stable Memory API

The IC provides a very small set of functions for operating on stable memory:

```
ic0.stable_size : () -> (page_count : i32);                                 // *
ic0.stable_grow : (new_pages : i32) -> (old_page_count : i32);              // *
ic0.stable_write : (offset : i32, src : i32, size : i32) -> ();             // *
ic0.stable_read : (dst : i32, offset : i32, size : i32) -> ();              // *
```

(see https://sdk.dfinity.org/docs/interface-spec/index.html#system-api-stable-memory)

These grow memory and do bulk transfers between Wasm and stable
memory.  The `// *` means that they can be called in all contexts
(e.g. init, update, query etc).  Direct reads and writes of word-sized
data to/from the stack are not supported but can be emulated at cost.
The initial size of the stable memory is zero. The contents of fresh pages (after grow) is initially zero.

Note that, in this API, the client is responsible for growing (both
stable and wasm) memory before access by read or write (out-of-bounds
access will trap).

# A minimal Stable Memory API

The minimal Motoko prims could be:

```
module StableMemory {
  size : () -> (logical_page_count : i32); // <= ic0.stable_size()
  grow : () -> (new_pages : i32) -> (old_logical_page_count : i32);
  loadNat8 : (offset : Nat32) -> Nat8;
    // traps outside logical address space
  storeNat8 : (offset : Nat32, n : Nat8) -> ();
    // traps outside logical address space
  ...
  loadBlob : (offset : Nat32, size : Nat) -> Blob
     // read Blob contents from memory at [offset,..,offset+size-1] into fresh blob, trapping if exceeding logical address space
  storeBlob : (offset : Nat32, b : Blob) -> (); // write contents of blob to memory, trapping if exceeding logical address space
}
```

NOTE: Motoko's `Nat32` value are always boxed - it might be more efficient to use [`Nat`](https://internetcomputer.org/docs/motoko/base/Nat.md) which is unboxed for 30(?)-bit values.


```
fun loadNat8(offset, b) =
   assert (offset < StableMemory.size() * wasm_page_size);
   mem[offset]

fun storeNat8(offset, b) =
   assert (offset < StableMemory.size() * wasm_page_size);
   mem[offset] := b

```

(To avoid overflow on the rhs, we could implement the check as `assert ((offset >> 16) < StableMemory.size())`.)

On top of this basic API, users should be able to build more
interesting higher-level APIs for pickling user-defined data.

REMARK:

Actually implementing the sketched assignments using the existing IC
API involves writing the contents to memory and then copying stable
memory - even for individual words - this could be optimized by an
improved system API offering direct load and stores from/to the stack:

```
ic0.stable_write_i32 : (offset : i32, val: i32) -> ();   // *
ic0.stable_read_i32 : (offset : i32, size : i32) -> i32; // *
// similarly for i64, f32, f64
```

## Bikeshedding:

It might be preferable to arrange the API by type, with one nested
module per type:

```
module StableMemory {
  Nat8 : module {
    load : (offset : Nat32) -> Nat8;
    store : (offset : Nat32, n : Nat8) -> ();
  };
  Nat16 : module {
    load : (offset : Nat32) -> Nat16;
    store : (offset : Nat32, n : Nat16) -> ();
  };
  // uniformly for all scalar prim types.
  ...
  Blob : module {
    read: (offset : Nat32, size : i32) -> Blob
    write : (offset : Nat32, b : Blob) -> ();
  }
}
```

(I think the compiler will still optimize these nested calls to known
function calls, but it would be worth checking).

# Maintaining existing Stable Variables (Legacy Persistence).

In classical persistence, stable memory is hidden behind the abstraction of stable
variables, which we will still need to maintain. This old
implementation of stable variables stores all variables as a
Candidish record of _stable_ fields, starting at stable memory address 0 with
initial word encoding size (in bytes?) followed by contents.
(Candidish is the Motoko extension of Candid to support mutable data.)

Starting from a clean slate, we would extend this so all user-defined StableMemory is
stored at a low address, with _stable variable_ data stored just
beyond the currently used StableMemory content on canister_pre_upgrade
and canister_post_upgrade. That way the StableMemory area need not
move, with stable variables simply serialized and appended in
`canister_pre_upgrade` and deserialized and discarded in
`canister_post_upgrade`, leaving the manual StableMemory unchanged.

For backwards compatibility reasons, we can't do that.

Luckily, stable variables always require non-zero bytes to encode, so we
can devise a backwards compatible scheme for upgrading
from pre-StableMemory canisters to post-StableMemory
canisters, as follows.

During execution, abstract stable memory (StableMemory) is aligned
with IC stable memory, at address 0, for reasonable efficiency (apart
from bound checks against logical `size()`).

During upgrade, if StableMemory has zero pages, we use the existing format, writing
(non_zero) length and content of any stable variables from address 0 or leaving ic0.stable_mem()
at zero with no pages allocated (if there are no stable variables).
Otherwise, we compute the length and data of the stable variable encoding;
save the first word of StableMemory at a known offset from the end of stable memory;
write a 0x00 marker to the first word; and append length (even if zero) and
data (if any) to the end of StableMem.
The logical size of StableMemory and a version number are also written at
known offsets from the end of StableMemory.

In post_upgrade, we reverse this process to recover the size of StableMemory,
restore the displaced first word of StableMemory and deserialize any stable vars,
taking care to zero the (logically) free StableMemory occupied by any encoded stable variables
and other metadata (so that initial reads after growing beyond page `size`  always return 0).

This scheme avoids relocating most of StableMem and is constant time when
there are no stable variables.

[Enhanced orthogonal persistence](OrthogonalPersistence.md) introduces a new peristence implementation.
The old mechanism is only supported for backwards compatibility.

# Details:

Stable memory layout (during execution):

*  aligned with stable-memory, with global word `size` holding logical page count (initially 0 < !size < 2^16).
*  user are responsible for allocating logical pages.
*  each load/store does a `size`-related bounds check.

During execution, stable variables aren't maintained in stable memory - they are on the Motoko heap.

Stable memory layout (between upgrades), assuming stable variable encoding `v == {fs:vs}`, a record value of record type `{fs:Ts}`.

NOTE: A program with no stable variables still writes an empty record value `v = {}`.

```
(case !size == 0) // hence N = 0
  [0..3] StableVariable data len
  [4..4+len-1] StableVariable data
  [len+4..len+12-1] instruction costs of stabilization (optional)
  [len+12,..M-1] 0...0 // zero padding
(case !size > 0)
[0..3]  0...0
[4..N-1]  StableMemory bytes
[N..N+3]  StableVariable data len
[N+4..(N+4)+len-1] StableVariable data
[(N+4)+len..M-20] 0...0 // zero padding
[M-20..M-13] instruction costs of stabilization (optional)
[M-12..M-9] value N/64Ki = !size
[M-8..M-5] saved StableMemory bytes
[M-4..M-1]  version word

where N = !size * pagesize // logical memory size
      M = ic0.stable_size() * pagesize // physical memory size
      pagesize = 64Kb (2^16 bytes)
where (len, data) = serialize<Ts>(v,data)

```

On pre_upgrade

```ocaml
func stabilise {fs:Ts} v : value =
  let len, data = serialize<Ts>(v)
  in
  if !size == 0 then
    mem[0,..,3] := len
    mem[4,...,4+len-1] := data
  else
    let N = !size * page_size in
    // if necessary, grow mem to page including address N + 4 + len + 4 + 4 + 4
    let M = pagesize * ic0.stable_size() in
    mem[N,..,N+3] := len
    mem[N+4,..,N+4+len-1] := data
    mem[M-12..M-9] := !size
    men[M-8..M-5] := mem[0,...,3] // save StableMemory bytes 0-3
    mem[0,..,3] := 0..0 // write marker
    mem[M-4..M-1] := version
```
on post_upgrade

```ocaml
// restores StableMemory (size and memory) and deserializes any stable variables, zeroing their storage
fun destabilize {fs:Ts} : value =
  let pages = ic0.stable_size() in
  if pages == 0 then
    size := 0;
    {fs = nulls}
  else
    let marker = mem[0,..,3] in // read zero or size of stable value
    mem[0,..,3] = 0;
    let (offset, len) =
      if marker == 0x0 then
        let M = pages * pagesize in
        let ver = mem[M-4,..,M-1] in
        mem[M-4,..,M-1] := 0;
        if (ver > version) assert false
        mem[0,..,3] = mem[M-8,..,M-5]; // restore StableMemory bytes 0-3
        size := mem[M-12,..,M-9];
        mem[M-12,..,M-9] := 0;
        N = size * pagesize;
        let len = mem[N,..,N+3] in
        mem[N,..,N+3] := 0;
        assert len > 0
        assert (N+4+len-1 <= ic0.stable_size() * pagesize)
        (N+4, len)
      else
        (4, marker)
    in
    assert (0 < len <= ic0.stable_size() * pagesize)
    let v = deserialise<Ts>(offset, len) in
    mem[offset,..,offset+len-1] := 0 // clear serialization memory
    v
```

We explicitly clear memory used by stable variables so StableMem
doesn't need to clear memory when grabbing logical pages from already
existing physical ones.


NOTE: We still need to do some work during updgrade and postupgrade,
but if stable variables and user-defined pre/post upgrade hooks are
avoided, then the work is minimal and highly unlikely to exhaust cycle
budget.

REMARK:

* An actor that has no stable variables and allocates no StableMem
  should require no physical stable memory

* An actor that has n > 0 pages of StableMem will (unfortunately)
  require at least n+1 pages of physical memory since we need at least
  one extra bit to encode the presence or absence of stable variables
  (there is no other preserved state that could record this bit).

FURTHER CONSIDERATIONS: It would be nice if there was some way to
allow a Motoko actor (perhaps intended to upgrade from a foreign
canister with foreign stable memory format) to have unadulterated,
full-speed access to stable memory, without the protocol required by
the possibility of stable variables.  Perhaps we could special case
programs that have *no* stable variables to support this raw
semantics.  I.e. if the program declares no stable variables, we
install and upgrade by simply setting `(StableMemory.)size :=
ic0.stable_size()`, never consulting or altering physical memory and
(ideally) omitting the additional bounds checking.



================================================
FILE: design/OrthogonalPersistence.md
================================================

# Enhanced Orthogonal Persistence

This implements the vision of **enhanced orthogonal persistence** in Motoko that combines:
* **Stable heap**: Persisting the program main memory across canister upgrades.
* **64-bit heap**: Extending the main memory to 64-bit for large-scaled persistence.

As a result, the use of secondary storage (explicit stable memory, dedicated stable data structures, DB-like storage abstractions) will no longer be necessary: Motoko developers can directly work on their normal object-oriented program structures that are automatically persisted and retained across program version changes.

## Activation
Enhanced orthogonal persistence is offered via the compiler flag `--enhanced-orthogonal-persistence`.
Classical persistence with 32-bit main memory and Candid stabilization currently remains the default mode.
See `design/PersistenceModes.md` for more information.

## Advantages
Compared to the existing orthogonal persistence in Motoko, this design offers:
* **Performance**: New program versions directly resume from the existing main memory and have access to the memory-compatible data.
* **Scalability**: The upgrade mechanism scales with larger heaps and in contrast to serialization, does not hit IC instruction limits.

Compared to the explicit use of stable memory, this design improves:
* **Simplicity**: Developers do not need to deal with explicit stable memory.
* **Performance**: No copying to and from the separate stable memory is necessary.

## Design
The enhanced orthogonal persistence is based on the following main properties:
* Extension of the IC to retain main memory on upgrades.
* Supporting 64-bit main memory on the IC.
* A long-term memory layout that is invariant to new compiled program versions.
* A fast memory compatibility check performed on each canister upgrade.
* Incremental garbage collection using a partitioned heap.

## IC Main Memory Retention

The IC introduces a new upgrade option `wasm_memory_persistence` to control the retention of the canister's Wasm main memory.
* `wasm_memory_persistence = opt keep` retains the Wasm main memory and is required for Motoko's enhanced orthogonal persistence. The IC prevents using this options for canisters with classical persistence.
* `wasm_memory_persistence = null` uses the classical persistence, replacing the main memory. However, a safety check is implemented to prevent that main memory is not accidentally dropped for enhanced orthogonal persistence.
* The other option `replace` is not recommended as it drops main memory, even for enhanced orthogonal persistence.

### Memory Layout
In a co-design between the compiler and the runtime system, the main memory is arranged in the following structure, invariant of the compiled program version:
* Lower 4MB: Rust call stack.
* Space between 4MB and 4.5MB: Limited reserved space Wasm data segments, only used for the Motoko runtime system.
* Between 4.5MB and 5MB: Persistent metadata.
* Thereafter: Dynamic heap space. Fix start address at 5MB.

### Persistent Metadata
The persistent metadata describes all anchor information for the program to resume after an upgrade. 

More specifically, it comprises:
* A stable heap version that allows evolving the persistent memory layout in the future.
* The stable subset of the main actor, containing all stable variables declared in the main actor.
* A descriptor of the stable static types to check memory compatibility on upgrades.
* The runtime state of the garbage collector, including the dynamic heap metadata and memory statistics.
* A reserve for future metadata extensions.

### Compatibility Check
Upgrades are only permitted if the new program version is compatible with the old version, such that the runtime system guarantees a compatible memory structure.

Compatible changes for immutable types are largely analogous to the allowed Motoko subtype relation, e.g.
* Adding or removing actor fields.
* Removing object fields.
* Adding variant fields.
* `Nat` to `Int`.
* Shared function parameter contravariance and return type covariance.

The existing IDL-subtype functionality is reused with some adjustments to check memory compatibility: The compiler generates the type descriptor, a type table, that is recorded in the persistent metadata. Upon an upgrade, the new type descriptor is compared against the existing type descriptor, and the upgrade only succeeds for compatible changes.

This compatibility check serves as an additional safety measure on top of the DFX Candid subtype check that can be bypassed by users (when ignoring a warning). Moreover, in some aspects, the memory compatibility rules differ to the Candid sub-type check:
* Top-level actor fields (`stable` fields) can change mutability (`let` to `var` and vice-versa).
* Support of variable (MutBox) with type invariance.
* Types cannot be made optional (no insertion of Option).
* Same arity for function parameters and function return types (no removed optional parameters, no additional optional results).
* Records cannot introduce additional optional fields.
* Same arity for tuple types (no insertion of optional items).
* Records and tuples are distinct.

### Garbage Collection
The implementation focuses on the incremental GC and abandons the other GCs because the GCs use different memory layouts. For example, the incremental GC uses a partitioned heap with objects carrying a forwarding pointer.

The incremental GC is chosen because it is designed to scale on large heaps and the stable heap design also aims to increase scalability.

The garbage collection state needs to be persisted and retained across upgrades. This is because the GC may not yet be completed at the time of an upgrade, such that object forwarding is still in use. The heap partition structure is described by a linked list of partition tables that is reachable from the GC state.

The garbage collector uses two kinds of roots:
* Persistent roots: These refer to root objects that need to survive canister upgrades.
* Transient roots: These cover additional roots that are only valid in a specific version of a program and are discarded on an upgrade.

The persistent roots are registered in the persistent metadata and comprise:
* All stable variables of the main actor, only stored during an upgrade.
* The stable type table.

The transient roots are referenced by the Wasm data segments and comprise:
* All canister variables of the current version, including flexible variables.

### Main Actor
On an upgrade, the main actor is recreated and existing stable variables are recovered from the persistent root. The remaining actor variables, the flexible fields as well as new stable variables, are (re)initialized. 

As a result, the GC can collect unreachable flexible objects of previous canister versions. Unused stable variables of former versions can also be reclaimed by the GC.

### No Static Heap
The static heap is abandoned and former static objects need to be allocated in the dynamic heap. This is because these objects may also need to survive upgrades and the persistent main memory cannot accommodate a growing static heap of a new program version in front of the existing dynamic heap. The incremental GC also operates on these objects, meaning that forwarding pointer resolution is also necessary for these objects. 

For memory and runtime efficiency, object pooling is implemented for compile-time-known constant objects (with side-effect-free initialization), i.e. those objects are already created on program initialization/upgrade in the dynamic heap and thereafter the reference to the corresponding prefabricated object is looked up whenever the constant value is needed at runtime.

The runtime system avoids any global Wasm variables for state that needs to be preserved on upgrades. Instead, such global runtime state is stored in the persistent metadata.

### Wasm Data Segments
Only passive Wasm data segments are used by the Motoko compiler and runtime system. In contrast to ordinary active data segments, passive segments can be explicitly loaded to a dynamic address.

This simplifies two aspects: 
* The generated Motoko code can contain arbitrarily large data segments (to the maximum that is supported by the IC). The segments can be loaded to the dynamic heap when needed.
* The IC can simply retain the main memory on an upgrade without needing to patch any active data segments of the new program version to the persistent main memory.

However, more specific handling is required for the Rust-implemented runtime system (RTS): The Rust-generated active data segment of the runtime system is changed to the passive mode and loaded to the expected static address on the program start (canister initialization and upgrade). The location and size of the RTS data segments is therefore limited to a defined reserve of 512 KB, see above. This is acceptable because the RTS only requires a controlled small amount of memory for its data segments, independent of the compiled Motoko program.

### Null Sentinel
As an optimization, the top-level `null` pointer is represented as a constant sentinel value pointing to the last unallocated Wasm page. This allows fast null tests without involving forwarding pointer resolution of potential non-null comparand pointers.

### Memory Capacity
The canister has no upfront knowledge of the maximum allocatable Wasm main memory in 64-bit address space, as there is no IC API call to query the main memory limit. This limit may also be increased in future IC releases.

Therefore, a mechanism is implemented to deal with an unknown and dynamically increasable main memory capacity offered by the IC. This is needed in two cases:

* GC reserve (strict): The runtime system ensures sufficient free space to allow garbage collection at all times, even if the heap is full. For this purpose, the runtime system already pre-allocates the reserve, to be sure that the reserve is available despite the unknown capacity. As an optimization, this pre-allocation is skipped when the memory demand including the GC reserve is below a guaranteed minimum Wasm memory limit of the IC, e.g. 4GB or 6GB.
* GC scheduling (heuristic): The GC schedules at high frequency when memory is becoming scarce. For this purpose, the GC maintains an assumption of the minimum memory limit and probes the supposed limit when the heap size approaches this limit. If the allocation succeeds, the assumed limit is increased. Otherwise, the critical high-frequency GC scheduling rate is activated.

In both cases, the runtime system tries to reduce Wasm memory allocations as much as possible, i.e. not pre-allocating memory for small heap sizes, and not probing an allocation in certain memory ranges by assuming that the IC only offers main memory of a certain granularity, e.g. multiples of 2GB. To save instructions, the critical GC scheduling is only activated when reaching the actual memory limit. Moreover, the mechanism can handle an increased memory capacity at runtime, e.g. when the IC is upgraded to a new release with a higher memory limit.

### Migration Path
When migrating from the old serialization-based stabilization to the new persistent heap, the old data is deserialized one last time from stable memory and then placed in the new persistent heap layout. Once operating on the persistent heap, the system should prevent downgrade attempts to the old serialization-based persistence. 

Assuming that the persistent memory layout needs to be changed in the future, the runtime system supports serialization and deserialization to and from stable memory in a defined data format using graph copy. 

### Graph Copy
The graph copy is an alternative persistence mechanism that will be only used in the rare situation when the persistent memory layout will be changed in the future. Arbitrarily large data can be serialized and deserialized beyond the instruction and working set limit of upgrades: Large data serialization and deserialization is split in multiple messages, running before and/or after the IC upgrade to migrate large heaps. Of course, other messages will be blocked during this process and only the canister owner or the canister controllers are permitted to initiate this process. 

Graph copying needs to be explicitly initiated before an upgrade to new Motoko version that is incompatible to the current enhanced orthogonal persistent layout. For large data, the graph copy needs to be manually completed after the actual upgrade.

```
dfx canister call CANISTER_ID __motoko_stabilize_before_upgrade "()"
dfx deploy CANISTER_ID
dfx canister call CANISTER_ID __motoko_destabilze_after_upgrade "()"
```

More detailed information and instructions on graph copy are contained in `design/GraphCopyStabilization.md`.

### Old Stable Memory
The old stable memory remains equally accessible as secondary (legacy) memory with the new support.

## Current Limitations
* The memory footprint of a program increases with 64 bit as the word size for scalars and pointers are doubled. In turn, in some cases, boxing can be avoided due to larger word size which again reduces memory demand.
* Freeing old object fields: While new program versions can drop object fields, the runtime system should also delete the redundant fields of persistent objects of previous program versions. This could be realized during garbage collection when objects are copied. For this purpose, the runtime system may maintain a set of field hashes in use and consult this table during garbage collection. Another, probably too restrictive solution could be to disallow field removal (subtyping) on object upgrades during the memory compatibility check.



================================================
FILE: design/PersistenceModes.md
================================================
# Persistence Modes

This Motoko build includes two substantially different persistence modes in one build:

* [Classical Persistence](OldStableMemory.md) (default): 
    This is the traditional Motoko compiler design based on 32-bit memory and Candid-based stabilization for upgrades.
    This mode is known to have severe scalability problems on upgrades, because the stabilization may exceed upgrade instruction limit for stable data amounts, besides other problems such as exponential duplication or stack overflows depending on the data structures.
* [Enhanced Orthogonal Persistence](OrthogonalPersistence.md) (new):
    This implements scalable persistence with 64-bit main memory that is retained across upgrades without stabilization to stable memory.
    The mode needs to be enabled by the compiler flag `--enhanced-orthogonal-persistence` and is intended to become the future default mode, deprecating classical persistence.

The reason for having one build instead of two separate branches and release artefact is for having a unified branch, and ensure that new features are implemented and tested for both persistence modes, passing the same CI.

## Compiler Flags

* (no flag): Use classical persistence
* `--enhanced-orthogonal-persistence`: Use enhanced orthogonal persistence.

Certain compiler flags are only applicable to a specific persistence mode:

Flag              | Applicable Mode
------------------|----------------
--rts-stack-pages | Classical persistence only
--stabilization-instruction-limit | Enhanced persistence only
--copying-gc      | Classical persistence only
--compacting-gc   | Classical persistence only
--generational-gc | Classical persistence only

(All other flags are applicable to both modes.)

Incremental graph copy stabilization with `__motoko_stabilize_before_upgrade` and `__motoko_destabilize_after_upgrade` are only available with enhanced orthogonal persistence and only needed in a seldom case of memory layout upgrade.

## Source Structure

## Runtime System
The Motoko runtime system (RTS) is a combined source base supporting 3 modes, each with a debug and release build:
* 32-bit classical persistence, with classical non-incremental GCs
* 32-bit classical persistence, with the incremental GC
* 64-bit enhanced orthogonal persistence

## Compiler
For pragmatic purposes, the compiler backend is split/duplicated in two parts
* `compile-enhanced.ml`: Enhanced orthogonal persistence, 64-bit, passive data segments, incremental graph copy.
* `compile-classical.ml`: Classical persistence, 32-bit, Candid stabilization.

The linker integrates both persistence modes and 32-bit and 64-bit in one package.

## Tests
Most tests run on both modes. Specific tests apply to selected modes, as defined by the `ENHANCED-ORTHOGONAL-PERSISTENCE` or `CLASSICAL-PERSISTENCE` tags.



================================================
FILE: design/scoped-await.md
================================================
# Structured awaits using indexed async types and parametric polymorphism

Inspired by Launchbury's RunST trick and Rust's lifetimes.

*Basic idea:*

Use type indexing and parametricity to ensure that a function can only
await async values it has created, hopefully ruling out:

* deadlock, and
* reply to wrong sender

while still allowing local uses of first-class async values.

Deadlock is prevented because an async can't await itself, since
it can only await asyncs it has created. Similarly, a sequence of
asyncs can only be awaited by the async that created them, not by each other.

The idea behind ruling out *reply-to-wrong-sender* is that an async
value cannot be stored in a non-local var or other mutable
datastructure, due to the fresh index, so it is only accessible from
the current message and thus can only receive continuations (via `await`) from the
current message.  It can't receive continuations from an inner
function by escaping into that function, since the inner function can at
most await asyncs with its inner index, not the outer one. Thus the only
continuations that are stored (including the ultimate reply
continuation), must be from the current function.

_Please break it_


# Abstract Syntax

```bnf
<typ> := ...
    | async<T>U            // T is an index, typically a scope parameter X
    | shared? <Xs> T -> U  // function types (with optional scope parameter X)


Xs := X,Ys
   | Ys

Ys := Y, Ys

(type parameters are an optional scope parameter X followed by ordinary type parameters Y(s))

<exp> :=
    | async<X> e                                         // async (scope X bound in e)
    | shared? f<Xs>(x:T) : U = e                         // functions
    | f <Ts> e                                           // application
    | ...

Ctxt := E; Cap        // Environment and capability C

// capabilites

Cap :=
    | NullCap            // no async capability (top-level, in constructors, some local functions)
    | AsyncCap<T>        // capability to async/send at T
    | AwaitCap<T>        // capability to async/send at T and await an async<T>

Env :=                // the usual suspects
    | E, x : T          // term va
    | E, X              // scope var
    | E, Y              // type var
    | <emp>

scope(AsyncCap<T>) = Some T
scope(AwaitCap<T>) = Some T
scope(NullCap) = None

cap(X,Ys) = AsyncCap<X>
cap(Ys) = NullCap
```

### Parameterized async expressions

```
E, X; AwaitCap<X> |- e : U  (X not in E,cap)
scope(cap) = Some T
----------------------------------------------------------
E; cap |- async<X> e: async<T> U[T/X]
```

An `async` expression at index `X` provides the scoped capability, `AwaitCap<X>`, to await asyncs with index `X`, provided
the current capability is `AwaitCap<T>` or `AsyncCap<T>`. That is, async expressions are only allowed in async or await contexts,
and the body of async expressions can await, spawn an async or send a message (at scope `X`).

The body `e` of an async must be parametric in the index but the index parameter is immediately eliminated at the current scope `T`.

Async expressions are illegal if the current capability is `NullCap` (e.g. at top-level, or in a constructor or vanilla function).

### (restricted) Await expressions

```
E; AwaitCap<T> |- e : async<T> U
------------------------------
E; AwaitCap<T> |- await e : U
```

We can only await things of the current index `T`, recorded in the context as `_ ; AwaitCap<T>`.

In particular, you cannot await anything unless you've entered an async expression.

(For *closure under type substitution* of contexts, note that we need the annotation in the context to be a type, not just a type parameter).

### Formation

Function types are only well-formed if async and oneway functions have an initial scope type parameter (our sugar will ensure this).

```
E,Xs; cap |- T   E,Xs; cap(Xs) |- U
shared? = shared implies Xs = X,Ys and (U = () or U = async<V>W) ...
Xs = X,Ys and U = async<V>W implies V = X and
----------------------------------------------------[func ok]
E; cap |- shared? <Xs> T -> U
```
The first side condition ensures that a shared function has a scope parameter `X` (invokation requires a capability and scope instantiation).
The second side condition ensures that an async return is parametric in `X` (local or shared).

Note that a local function may or may not take a scope parameter.


### Abstraction

The rules for async/oneway function abstraction are as follows:

```
E,Xs,x:T; cap(Xs) |- e : U
E, cap |- shared? <Xs> T -> U
shared? = shared implies U = () or e == async<Y>e' (some e')
-----------------------------------------------------------------------------------------[func]
E; cap |- shared? f<Xs> (x:T) : U = e : shared? <X::Xs>T -> U
```

The second premise ensure the initial parameter of a oneway or async function must be a scope parameter `X` (see formation [func ok]).
In this way, regardless, of the current capability, the body of an (shared/local) async function or shared oneway
is granted the capability to enter an async expression and send messages.

Without a scope parameter in `Xs` (`Xs` = `Ys`), the abstraction rule simple introduces the null capability, `NullCap`, to prevent sends and async expressions in the body.

Note that a local function may or may not introduce a scope parameter, affecting the capabilities of its body (and the ability to invoke that function).
This means that a local function *can* be used to abstract out async and sends, provided it has a scope parameter that is supplied when called.

### Application

Async and oneway functions:

Application of an async (or, in the full system, shared
oneway) uses the current scope `T` as the instantiation of the scope
parameter and is rejected when no such parameter exists (`scope(cap) = None`).



```
E; cap |- f : shared? <Xs> U -> V
Xs = X,Ys
scope(cap) = Some T
E; cap |- e': U[T/X,Ts/Ys]
-------------------------------------------------------
E; cap |-  f <Ts> e' : V[T/X,Ts/Ys]
```
One cannot specify the instantiation of an initial scope parameter, it
is determined by the context, if at all (as per async expressions).


(Local) Functions with no scope parameters are instantiated as usual and can be invoked with any capability.

```
E; cap |- f : <Ys> U -> V
E; cap |- e': U[Ts/Ys]
----------------------------------------------
E; cap |-  f <Ts> e' : V[Ts/Ys]
```

By construction, shared functions must have a scope parameter and can never be invoked in a `NullCap` context.

For local functions, it depends on the type of the function (i.e. whether it has a scope parameter).


### Abstraction (Derived Rule)

Derivation for (desugared) shared functions (ignoring recursion).


Consider the desugared async function:

```
shared? f<Ys>(X:T) : async U { e } :=
shared? f<X,Ys>(x:T) : async<X>U = async<X> e;
```

For reusability in different async contexts, every shared function
should introduce a new index parameter, implicitly supplied to the
inner async expression.  The result type needs to
be generic if we want to invoke and await it from other async contexts.

Using the above rules we get:

```
E, X, Ys, x : T, Y;  AwaitCap<X> |- e : U
-------------------------------------------------------------
E, X, Ys, x : T; AsyncCap<X> |- async <X> e
-------------------------------------------------------------
E; _ |- shared? f<X,Ys>(x:T) : async<X>U = async<Y> e :
          shared? <X,Ys>(x:T) : async<X>U
```
Notice that the context transitions from `AsyncCap<X>` to `AwaitCap<X>` to allow awaits from within `e`.

Applying the sugar above, which implicitly introduces scope parameters in types and terms we get the more manageable:

```
E; _ |- shared? f<Ys>(x:T) : async U { e } :
         shared? <Ys>(x:T) : async U
```

(in which the scope parameters `X` are completely elided).



### DON'T READ TOO CLOSELY BELOW HERE, needs revising

## Examples:

(These examples and more are all coded in

* [general_await.mo](../test/run-drun/general_await.mo) (annotated with desugaring)
* [general_await_implicit.mo](../test/run-drun/general_await_implicit.mo) (sugar only)
)

Assuming the following requests:

```
  public shared func Ack() : async(){
    Prim.debugPrint "Ack"
  };

  public shared func Request(i : Int) : async Int {
    Prim.debugPrintInt(i);
    return i
  };

```

### Static parallel waiting:

```
  public shared func PA() : async () {
    let a1 = Ack();
    let a2 = Ack();
    await a1;
    await a2;
  };

  public shared func PR() : async (Int,Int) {
    let a1 = Request(1);
    let a2 = Request(2);
    (await a1, await a2)
  };
```

### Dynamic parallel waiting for acknowledgements

```
  // Dynamic parallel waiting for acknowledgements

  public shared func DPA() : async() {
   let os = Prim.Array_init<?(async ())>(10, null);
   for (i in os.keys()) {
     os[i] := ? (Ack());
   };
   for (o in os.values()) {
     switch o {
      case (? a) await a;
      case null (assert false);
     };
   };
  };
```

### Dynamic parallel waiting (with results)

```
  public shared func DPR() : async [Int] {
    let os = Prim.Array_init<?(async Int)>(10, null);
    for (i in os.keys()) {
      os[i] := ? (Request(i));
    };
    let res = Prim.Array_init<Int>(os.len(),-1);
    for (i in os.keys()) {
      switch (os[i]) {
        case (? a) res[i] := await a;
        case null (assert false);
      };
    };
    Prim.Array_tabulate<Int>(res.len(),func i { res[i] })
  };
```

### Recursive parallel waiting

```
  public shared func RPA(n:Nat) : async () {
    if (n == 0) ()
    else {
      let a = Ack();
      await RPA(n-1); // recurse
      await a;
    };
  };

```

### Recursive parallel waiting (with results)

```
  public type List<Int> = ?(Int,List<Int>);

  public shared func RPR(n:Nat) : async List<Int> {
    if (n == 0) null
    else {
      let a = Request(n);
      let tl = await RPR(n-1); // recurse
      ?(await a,tl)
    }
  };
```

### Deadlock Prevention:

(These examples are all coded in [illegal-await.mo](../test/fail/illegal-await.mo)

#### Immediate deadlock

```
  let t : async () = async { await t};
```
is rejected because, once annotated:

```
  let t:async<$>U = async<$1>{ await t;}; // bad await since t : Async<$>U  </: Async<$1>U
```

Ruled out by index scoping (`$1 <> $ `)

#### Indirect deadlock

```
  async {
    let a1 : async () = async { await a2; };
    let a2 : async () = async { await a1; };
  };
```

is rejected because, once annotated:

```
  async<$> {
    let a1 : async<$> = async<$1> { await a2; }; // bad await since a2 : Async<$>() </: Async<$1>()
	let a2 : async<$> = async<$2> { await a1; }; // bad await since a1 : Async<$>() </: Async<$2>()
  }
```

since `$1 <> $` and `$2` \<\> `$`.

### Imperative deadlock

The informal example:

```
  async {
    var x = async { 0 };
    x := async {
      await x
    };
  }
```

that attempts to tie an imperative knot, is rejected by this system.

Explicitly, the outer and nested async would have distinct parameters `<$>` and `<$2>`, so the await at type `async<$2>Nat` on `x`
(of type `async<$>Nat` (with the outer parameter) would actually be illegal:

```
async<$> {
  var x : async<$> Nat = async<$1> 0;
  x := async<$2>{
    await x // illegal: this await requires async<$2>Nat (not async<$>Nat)
  };
}
```

## Sugar

Principle: Desugaring should be:

* simple and unambiguous
* expressible in the syntax (as explicit binders).
* avoidable (by supplying explicit binders).


### Basic idea:

(`$` is a new type identifier, reserved for scopes only, intially defined as 'Any')

Parsing:

* inserts `<$,...>` type binders for missing scope binders (in types and terms);
* adds missing `<$>` bindings to async returning functions with missing async indices.

Elaboration:

* Elaboration ensures `$` is bound to an appropriate constructor, shadowing any previous `$`-binding to ensure lexical scoping.

Syntactic sugar (during parse, applied bottom up as we construct types and terms)

```
(async T)^ := async<$> (T^)

(<...>T1 -> async T2)^ :=                           ($ not in ...)
  <$,...^>T1^ -> (async T2)^

(shared? f<...>(<pat>) : async T = e)^ :=           ($ not in ...)
  shared? f<$,...^>(<pat>^) : (async T)^ = e^

(shared? f<...>(<pat>) : async T { e })^ :=         ($ not in ...)
  shared? f<$,...^>(<pat>^) : (async T)^ = async<$> e^

(shared f<...>(<pat>) : () = e)^ :=           ($ not in ...)
  shared f<$,...^>(<pat>^) : () = e^

(shared f<...>(<pat>) { e })^ :=              ($ not in ...)
  shared f<$,...^>(<pat>^) : () =  e^


(async e)^ :=
  async<$> e^

```

### Elaboration

During elaboration, we rebind `$` to the current scope
identifier (aliasing `$` with some type parameter `X` if necessary) so
that:
 * references inserted during parsing elaborate to the nearest appropiate binding

Note that in a function type or definition with type parameters, `$`
either shadows one of those eponymous type parameters (if introduced by
de-sugaring) or it retains its outer meaning.

### Sugaring types (for pretty printing)

During pretty printing of types, we suppress a unary type binding in a
function type if it only occurs as an `async` type instantiation at
DeBruijn level 0, in which case we elide all those `async` type
instantiations too.

Binders with async instantiations at DeBruijn levels other than 0
cannot arise by construction (this is an invariant of desugaring and
the fact that we don't support explicit binding).


### Initial Context

For compiled programs we restrict the inital capability to `NullCap`,
so that sends and async can only occur in shared functions.

For interpreted programs we use the initial capability `Async $` so
that programs can `async` and `send` at top-level (but not `await`).

### Queries

In Motoko, expressions that `await` can also `throw/try-catch`, but
`query` functions are not allowed to spawn async expressions or send
message (but can return errors).

Query functions that may `throw/try/catch` but not send or `async` are
easily accomodated by:

* refining the notion of capabilities, addinq `QueryCap<c>` and
  `ErrorCap`, where `AwaitCap<C>` entails `ErrorCap`.
* making helper `cap` depend on the query modifer, returning
  `QueryCap<c>` for a query.
* conditionally transitioning the current capability accordingly when
  entering an `async` expression (from `QueryCap<T>` to `ErrorCap`
  rather than `AsyncCap<T>` to `AwaitCap<U>`)

See the code for details.


### Refinements

Since users may find it odd that we can instantiate the index at any
type, it might be better to define "type $ = Non" and always bound
index-parameters by `Non`. Then the top-level choice of index really
is unique since `Non`, and any `Non`-bounded type parameter, are the
only types bounded by `Non` and thus suitable for uses as index
instantiations.



================================================
FILE: design/Stable.md
================================================
# Stable Variables and Upgrade

To enable persistent state to survive upgrades, a special form of state is needed that we call _stable_.

The compiler needs to take special care to never change the representation of such state.
To make this requirement feasible, certain type restrictions apply to stable state: essentially it can only contain data.

Stable state is introduced in the form of _stable variable definitions_ that are only allowed (as well as required) in actors.


## Language Extension

### Syntax

We require all `let` and `var` declarations in an actor to be declared either stable or flexible.
This is to indicate explicitly that special type restrictions apply.

Concretely, the syntax of `<dec-field>` is extended as follows:
```
<dec-field> ::=
  (public|private)? (stable|flexible)? dec
```

Additional restrictions apply:
* A `stable` or `flexible` modifier _can_ appear on `let` and `var` declarations that are actor fields.
* A `stable` or `flexible` modifier _must not_ appear anywhere else.

Currently, `flexible` is assumed as implicit keyword on actor fields if no keyword is declared.
However, we should revise this design, as it may lead to accidental loss of data on upgrade if programmers accidentally forgot to specify `stable`.
In other languages of orthogonal persistence, pointers are by default persistent, analogous to `stable` in Motoko.

(Note: One possible future use case might be to mark private methods as stable, which would be a requisite that they can be handed out as capabilities, because such methods must also remain backwards compatible.)


### Typing

A stable declaration must have a _stable type_. Stable types are a superset of _shared_ types: specifically, they additionally allow objects or arrays with mutable components.

Concretely, the `stable` predicate has the same definition as the `shared` predicate (cf. `type.ml`), except that the case for `Mut t` is
```
  | Mut t -> go t
```

That is, shared entails stable.
Note that this implies that stable types may contain actors or shared functions, but mutability of course does not extend into those.

Note: This implies that stable state can only contain records, not objects (which contain non-shared functions).
This clearly is a severe restriction.
But we leave the possibility of "stable classes" for later, since it is not at all obvious how to design or implement them.


### Semantics

Installing a new actor runs the initialiser expressions of all flexible and stable variables in sequence, like for ordinary variable definitions in an object.
(In terms of the System API, this happens in the init hook.)

When upgrading an actor, all stable variables that existed in the previous version are pre-initialised with their old values.
Their initialiser expressions are ignored.
After that, the initialiser expressions of flexible and newly added stable variables are executed in sequence, like for ordinary variable definitions.
(In terms of the System API, this happens in the post_upgrade hook.)

This implies that any expression declaration (or any of the form `let _ = <exp>`, for which expressions are a short-hand) will always be run after an upgrade.
They can hence be (ab)used as post-upgrade hooks.

Open Question: What about let declarations with multiple variables, some of which existed before while others didn't? Or should we generally not persist `let`-bound values and always re-initialise them? Would that be a pitfall? Should we forbid it (how?)?

Note: With respect to variable initialisation, installing a new actor behaves like upgrading the actor from an empty actor with no pre-existing stable variables.


## Stable Signatures

The Candid IDL defines the public interface of an actor, listing the methods that an actor provides and their types.
When upgrading an actor, this interface may only be modified in backwards-compatible ways:
* new methods may be added,
* existing methods may be refined to a subtype.
This prevents breaking existing clients assuming the current or an earlier interface.

With stable state, a second dimension is added: the _stable signature_ of an actor lists its stable fields and their types.
When upgrading an actor, this interface may also only be modified in backwards-compatible ways:
* new variables may be added,
* existing variables may be refined to a _supertype_.
This ensures that existing persistent state is still readable with the new version of the program.

The stable signature is not public; its only relevance is to the owner of an actor, as an additional constraint imposed when upgrading the actor.

Stable signatures could also be used to auto-generate interfaces or UI for inspecting or even administering the state of an actor.


### Syntax

The stable signature can't be described in terms of IDL types, because it is specific to Motoko and stable types contain more than what the IDL can express.

The textual representation for stable signatures looks like a Motoko actor type:
```
actor {
  stable x : Nat;
  stable var y : Int;
  stable z : [var Nat];
};
```
Like in Candid, the actor specification may be preceded by a sequence of auxiliary (Motoko) type definitions.

Grammar:
```
<typ> ::= ...   (Motoko types)

<field> ::=
  stable <id> : <typ>
  stable var <id> : <typ>

<dec> ::=
  type <id> <typ-params>? = <typ>

<sig> ::= <dec>;* actor { <field>;* };

```

Note: We could also allow imports if useful.

Question: Should the stable signature become a superset of Candid signatures, i.e., also include methods, but expressed with (richer) Motoko types?


### Compiler and System Support

Like the Candid IDL, the Motoko compiler can produce stable signatures for the actors it compiles.

By using `moc --stable-compatible`, one can compare stable signature and verify that an extension is valid according to the Motoko subtyping rules.

To make that test reliable, the stable signature of an actor should be contained in the Wasm module of a deployed Motoko actor.
That way, it is ensured that accurate signature information is always available for each installed actor.
One way to store it would be in a Motoko-specific custom section;
another alternative is as a separate internal asset.
In either case, it is probably sufficient to use a textual representation.

Like for the IDL, the System would need to provide a way to extract this information from an onchain canister.

For even higher safety, [enhanced orthogonal persistence](OrthogonalPersistence.md) integrates the compatibility check in the runtime system,
such that it is atomically guarded and cannot be bypassed e.g. by skipping a `dfx` stable compatibility warning.

## Upgrade Hooks

The System API provides a number of hooks that a canister can implement.
In particular, this includes the pre & post upgrade hooks.
Motoko allows to define custom pre-/post upgrade hooks, see below.

### Syntax

To this end, we further extend the syntax of `<dec-field>` with _system methods_ of the following form:
```
<dec-field> ::= ...
  (public|private|system)? (flexible|stable)? dec
```
Again, additional restrictions apply:
* A `system` modifier _may only_ appear on `func` declarations that are actor fields.
* A `system` modifier _must not_ appear anywhere else.

Two system methods are recognised by their name:
* `preupgrade`
* `postupgrade`

The set of system functions may be extended in the future.


### Typing

The required type of system methods depends on their name:
* `preupgrade : () -> ()`
* `postupgrade : () -> ()`


### Semantics

Pre-upgrade and post-upgrade methods are executed before or after an upgrade, respectively. (In terms of the System API, they correspond to the respective hooks.)

Moreover, a post-upgrade method is executed after the actor body and its variable initialisers have run (see above).

Note: The post-upgrade method differs from expression declarations in the body of an actor in that they are _only_ run after an upgrade, not when first installing the actor.


## Implementation

Different [persistence modes](OrthogonalPersistence.md):
* [Enhanced orthogonal persistence](OrthogonalPersistence.md).
* [Classical orthogonal persistence](OldStableMemory.md).



================================================
FILE: design/StableMemory.md
================================================
# The IC's Stable Memory API

The IC provides a very small set of functions for operating on stable memory:

```
ic0.stable_size : () -> (page_count : i32);                                 // *
ic0.stable_grow : (new_pages : i32) -> (old_page_count : i32);              // *
ic0.stable_write : (offset : i32, src : i32, size : i32) -> ();             // *
ic0.stable_read : (dst : i32, offset : i32, size : i32) -> ();              // *
```

(see https://sdk.dfinity.org/docs/interface-spec/index.html#system-api-stable-memory)

These grow memory and do bulk transfers between Wasm and stable
memory.  The `// *` means that they can be called in all contexts
(e.g. init, update, query etc).  Direct reads and writes of word-sized
data to/from the stack are not supported but can be emulated at cost.
The initial size of the stable memory is zero. The contents of fresh pages (after grow) is initially zero.

Note that, in this API, the client is responsible for growing (both
stable and wasm) memory before access by read or write (out-of-bounds
access will trap).

# Stable Memory Accesses

Direct stable memory accesses (`ExperimentalStableMemory` in Motoko's base package) has been deprecated.
Instead, [stable regions](StableRegions.md) are available to explicitly access stable memory.

However, generally, programmers do not need to use stable memory due to the support of orthogonal persistence,
see [Enhanced Orthogonal Persistence](OrthogonalPersistence.md).



================================================
FILE: design/StableRegions.md
================================================
# Stable Region API

See StableMemory.md for context of the current experimental API.

This document aims to specify the API and memory representations for a generalization
of this API that permits multiple isolated _regions_ of stable memory, where each can be
grown independently.

The **region manager** is the state and logic to support this generalization.


## Role for "stable regions" in Motoko

The current stable memory module in `base` has been "experimental" for a long time, and requires a more composable API to graduate from this status.

Stable regions address the problem that the deprecated `ExperimentalStableMemory` module only provided a single, monolithic memory that makes it unsuitable for directly building composable software parts.

Stable regions permit a new API that supports composable use cases.

Stable regions also bring Motoko closer to parity with Rust canister development support today, by giving a run-time-system-based analog of a special Rust library for stable data structures that allocates “pages” for them from stable memory in separate, isolated, memory regions.


## Design space

The design space for the page allocator is defined by at least two
tensions:

 1. fully-stable representation of allocator meta data **versus** fast load/store operations.

 2. Total scaling capacity **versus** minimum footprint for meta data.


**Tension 1** is introduced because we want to avoid relying on the Motoko heap as the "ground truth" about the allocator's state.  If this heap is lost, as it is during an upgrade, then a developer may still want to recover all of the regions' data and meta data.

Tension 1 is resolved by storing the ground truth in stable memory, keeping it in sync with heap structures that permit faster access operations.

Compared with the Rust version, we store enough extra meta data to permit:

 - Regions whose page blocks are in arbitrary order, not
   necessarily in order of smallest to highest address.

 - 2^64-1 Regions max (instead of 255 Regions max).
   Due to the limit on blocks, only 2^16-1 can have non-zero page size.

We want to permit arbitrary page block orders to make a smooth
transition to region reclamation and re-allocation in the near
future, with potential integration into the Motoko GC.  The
extra complexity is modest, and seems "worth" the cost.

We change the maximum region limit because 255 may be too small in
some extreme cases and incompatible with GC.
Instead, we can freely allocate new regions, recycling blocks, but not
Region ids. The id of a Region is invariant and will not change, even with GC.

We address the question of whether the new limit of 32k regions is
"enough" in the Q&A section (it is, for all practical purposes)


**Tension 2** is introduced because we want a design that will continue
to work even when canisters can store more stable data than today (32GB).

Tension 2 is resolved by making prudent representation choices.

The representations we choose for regions and region identifiers
permit a scaling to 256GB of stable data while still permitting meta
data to be repeated in both stable and non-stable arenas.  These are
the same limits imposed by the Rust implementation, for the same
reasons.  See Q&A for more discussion.


## Definitions and constants

 - a **page** is 65536 bytes.
 - a **page block** is a contiguous sequence of 128 pages (~8MB).
 - a **page block index** is a 16 bit, index-based identifier for a page block.
 - a **region** is a sequence of (generally non-contiguous) **page blocks**.
 - the maximum number of page blocks is 32768.
 - the maximum amount of stable memory for all regions is 256GB.


## Questions and answers

### Q: What determines the 8MB non-empty region minimum?

Mostly, we want to reduce the amount of metadata we need to track, so instead of per-page metadata (lots) we only need per-block metadata (less).
This size means we grow a region by more than one physical page at
a time (in terms of the way that the canister interacts with the
system API, at least).  Rather than actually grow by a single page,
the implementation grows by a "page block" (8MB) at a time.

This choice means that there are 128 pages per page block, and that
the maximum number of regions and region blocks are each relatively
small (32k each).  Consequently, they can each be identified with a
2-byte identifier, and we can pre-allocate tables to store certain
relations about them, which is critical.

### Q: Are 32767 regions enough?

A: Permitting more than 32k regions may seem theoretically
interesting, but is not practical given other parameters today that
control the minimal footprint of a region (8MB) and dictate the
maximum size of stable memory for a canister today (32GB).  With 32k
regions at 8MB each, well over the maximum stable memory size is used
(256GB compared to 32GB, the limit today)

### Q: When is stable memory becoming less costly?

Spring 2023.

### Q: How does the cheaper stable memory access cost compare with ordinary heap memory access cost?

2-3x slower than ordinary heap memory.


## Design details

### API

Internal region allocator operations:

 - `initialize` -- called by the RTS, not by the Motoko developer.

User-facing region allocator operations:

 - `region_new` -- create a dynamic region.
 - `region_grow` -- grow region by a specified number of pages.
 - `region_load` -- read some data from the region.
 - `region_store` -- store some data into the region.

### FUTURE WORK

Add a special operation, for testing our design for future GC integration (bonus):

- `region_release` -- release region and reuse region's page blocks.

The `_release` operation is *not* part of the user-facing API nor part of the MVP,
but supporting it is important because it means we can transition quickly to an integration
with the ambient Motoko GC if we can support it.

Another special operation, for disaster recovery:

 - `rebuild` -- not needed unless we need to recreate all Region objects from their stable-memory counterparts.


## Internal footprint

The state of the allocator is stored in a combination of:

 - stable memory fields and tables and
 - stable heap memory, in the form of objects of opaque type `Region`.

The stable memory state is sufficient to reconstitute the stable heap objects
(`rebuild` operation, described in a subsection below).

That means that even if the stable parts of the heap are lost, the
stable memory state can fully describe the region objects that will be rebuilt when it succeeds.

### stable memory fields

 - total allocated blocks, `u16`, max value is `32768`.
 - total allocated regions, `u64`, max value is 2^64-1 (one region is reserved for "no region" in block-region table).
 - The `block` table (fixed size, about 6 pages).

### representation of values of type `Region`

 - A singleton, heap-allocated object with mutable fields.
 - While being heap-allocated, the object is also `stable` (can be stored in a `stable var`, etc).
 - `RegionObject { id_lower: u32, id_upper: u32; mut page_count: u32; mut vec_pages: Value }`
 - Fields id_lower (lower 32-bits)  and id_upper (upper 32-bits) gives the Region's numerical 64-bit (id = (id_upper \<\< 32 | id_lower)).
 - Field `page_count` gives the number of pages allocated to the Region.
 - Field `vec_pages` points at a heap-allocated `Blob` value, and it works with `page_count`
   to represent a growable vector that we call the region's **"access
   vector"** (because "blocks vector" sounds a bit strange, and its
   used to support O(1) access operations):
   - the access vector has `vec_capacity` slots.
   - each slot is a `u16`.
   - the first `page_count + 127 / 128` slots contain a valid page block ID for the region.
   - during an upgrade, the access vectors get serialized and deserialized as data `Blobs`.


### region-blocks relation

The `region-blocks` relation is not materialized into a table in stable memory (doing so with a pre-allocated table would be prohibitively large).

Instead, this relation is represented in two ways at the same time:
 1. by the set of heap-allocated region objects, and their access vectors.  The access vectors provide O(1) store and load support.
 2. by the `block-region` table, which together are sufficient to recreate all of the heap-allocated region objects.

In ordinary operation, the second feature is not required.  In the event of an upgrade failure, however, it could be vital (See `rebuild`).

### block-region table

 - purpose:
   - relate a block ID ("page block ID") to its region (if any), its position (or rank) in that region (see `rebuild`) and its current size in (used) pages (`<=128`).
     All but the last block owned by a region should have all pages 128 allocated.

   - NB: The organization of this table is not useful for efficient
     access calculations of load or store (they require a linear
     search that would be prohibitively slow).  OTOH, this
     table is suitable to do a "batch" rebuild of the dynamic heap-allocated vectors
     in that table, if need be (see `rebuild`).

 - 32768 entries (statically sized).
 - 8 (id) +2 (rank) + 1 (used) = 11 bytes per entry.
 - entry type = `BlockRegion { region : u64, position : u16, size: u8 }`
 - the location of each entry gives its corresponding block ID.


### Overview of `rebuild`

When upgrades work as expected, stable `Regions` are serialized and deserialized just like other stable data.

For disaster recovery, we can **also** rebuild all of the region objects from data in stable memory.

We use the `block-region` tables in stable memory to rebuild the regions' objects:

 - The `block-region` table gives a relative position and region ID for each block ID together with utilized page count.

Once each regions' vectors have been sized (by a linear scan of block-region, summing block sizes) and allocated, the block-region table says how to fill them, one entry at a time.
Unlike the Rust design, vector entries can be populated out-of-order.

Currently, we need only recover region 0 (when upgrading).


### Special (reserved) regions

  - Region 0 -- Anonymous region, for supporting the legacy API that we have today, which lacks `Region` values.
  - Region 1 -- "Reclaimed blocks" region that consists of blocks reclaimed from GC'd regions.
  - Regions 2-15 -- Future use by Motoko RTS (TBD).

### Overview of GC support (future work)

- Regions are represented (see special subsection) with heap objects that are `stable`, but mutable.
- They have special GC headers to recognize their special structure.
- The block-region table (or a more transient bitmap)  keeps track of which blocks are in use as Region heap values are GC'd.

Blocks can be marked during normal GC, with unmarked blocks returned to a transient free-list. In this design, blocks are recycled during
the lifetime of a single canister version.

Alternatively, Blocks can be marked only during deserialization after an upgrade, for bespoke, Region-only, GC during upgrades, with unmarked blocks
returned to a free list.
In this design, blocks are only recycled during upgrade from one version to the next, meaning long-lived canisters that create garbage regions will leak
space.

### Migration from earlier designs into region system

#### Version overview

Including this design, there are three possible verions (`0`, `1`, or `2`):

 0. Stable vars only.
 1. Stable vars *plus* direct access to IC0 API, including `grow`.
    This access is exposed via the Experimental Stable Memory API.
 2. This Region system, where direct access still works through region zero.


#### Key points

- Version 0:
  - will never be forced to "migrate" to other versions (assuming no stable memory API use).
  - will never incur the space overhead of the region system.

- Migration from 0 to version 1 occurs when:
  - Experimental Stable Memory function `grow` is invoked for the first time.
  This will not incur the space overhead of the region system.

- Migration from version 0 or version 1 to version 2 occurs when:
  - An initial region is allocated via `Region.new`.
  This will incur the space overhead of the region system.
  The space overhead is 16 pages (1MB) when migration from version 0, and 128 pages (8MiB) when migrating from version 1.

#### Compiler flag

Compiler flag

```
  --stable-regions
```

Affects upgrades only and forces migration directly into version 2 from version 0 or 1.
It is provided for testing purposes and *not* required for use of regions.

#### Format version details

The first 32 bits of stable memory record a "marker," which indicates how to determine the "version number"
for Motoko stable memory.  This version number is stored either:
  - *implicitly*, when the marker is non-zero, and version is `0`.
  - *explicitly*, when the marker is zero, and version is stored elsewhere (but currently always `1`).

Including this design, there are three possible verions (`0`, `1`, or `2`).  See preceeding section.

In the first cases (`0`) and (`1`), we wish to *selectively* migrate into the region system (`2`), with its own internal versioning.


#### Opt-in mechanism

The opt-in mechanism for using version 2 consists of using:

 - dynamically calling `Region.new()` form a canister currently in version 0 or 1;
 - staticly specifying compiler flag `--stable-regions`. This is mostly useful for testing.

Critically,

1. The use of physical stable memory is pay-as-you-go: canisters that do not use regions do not pay for that priviledge.
2. There is no provision for "downgrading" back to earlier, pre-region systems.

##### Version 0 migration.

To migrate from version 0 to version 2, there is nothing additional to do for existing data.

The region system detects this case by measuring the zero-sized stable memory during its initialization and
starts allocating blocks from address 16*2^16 (1MiB overhead), leaving 10 pages unused for future use.

##### Version 1 migration.

Migrating version 1 stable memory renames it as "region 0" in Version 2.

Critically, to migrate from version 1, we must perserve existing data, but reorganize it slightly.

In effect, all existing data will retain its logical order as (pre-allocated) region 0.

To accomodate the meta data of the region system, we move the first block of region 0, physically.

Then, we reformat the first block of stable memory as the region meta data block.

The rest of the blocks become part of region 0, with its first block stored at the end of physical memory.

The region system starts allocating blocks from address 128*2^16 (8MiB overhead), leaving 122 pages unused for future use.

Since we do not move the remaining blocks of region 0, the first block of memory (excluding meta-data) is unused space.

This design ensures that an existing canister using very large amounts of experimental stable memory can be migrated with only constant-cost movement
of the first block (128 pages) of memory.

## Orthogonal Persistence

Stable regions can be used together with orthogonal persistence, see [Classical Persistence](OldStableMemory.md) and [Enhanced Orthogonal Persistence](OrthogonalPersistence.md).


================================================
FILE: design/Syntax.md
================================================
# Motoko Syntax (Sketch)

Productions marked * probably deferred to later versions.


## Types
```
<typ> ::=                                     type expressions
  <id> <typ-args>?                              constructor
  (actor|module|object)? { <typ-field>;* }                      actor / module / object (default)
  { <typ-tag>;* }                               variant
  { # }                                         empty variant
  [ var? <typ> ]                                array
  ? <typ>                                       option
  shared? <typ-params>? <typ> -> <typ>          function
  async <typ>                                   future
  ( ((<id> :)? <typ>),* )                       tuple
  Any                                           top
  None                                          bottom
  Error                                         errors/exceptions

<typ-field> ::=                               object type fields
  <id> : <typ>                                  immutable
  var <id> : <typ>                              mutable
  <id> <typ-params>? <params> : <typ>           function (short-hand)

<typ-tag> ::=                                 variant type fields
  # <id> : <typ>                                tag
  # <id>                                        unit tag (short-hand)

<typ-args> ::=                                type arguments
  < <typ>,* >

<typ-params> ::=                              type parameters
  < (<id> <: <typ>),* >                         constrained
  < <id>,* >                                    unconstrained (short-hand)
```

## Literals
```
<lit> ::=                                     literals
  <nat>                                         natural
  <float>                                       float
  <char>                                        character
  <text>                                        unicode text
```

## Expressions
```
<exp> ::=
  <id>                                           variable
  <lit>                                          literal
  <unop> <exp>                                   unary numeric operator
  <exp> <binop> <exp>                            binary numeric operator
  ( <exp>,* )                                    tuple
  <exp> . <nat>                                  tuple projection
  ? <exp>                                        option injection
  new { <exp-field>;* }                          object
  <exp> . <id>                                   object projection
  # <id> <exp>?                                  variant injection
  <exp> := <exp>                                 assignment
  <unop>= <exp>                                  unary update
  <exp> <binop>= <exp>                           binary update
  [ var? <exp>,* ]                               array
  <exp> [ <exp> ]                                array indexing
  <exp> <typ-args>? <exp>                        function call
  { <dec>;* }                                    block
  not <exp>                                      negation
  <exp> and <exp>                                conjunction
  <exp> or <exp>                                 disjunction
  if <exp> <exp> (else <exp>)?                   conditional
  switch <exp> { (case <pat> <exp>;)+ }           switch
  while <exp> <exp>                              while loop
  loop <exp> (while <exp>)?                      loop
  for <id>? in <exp> <exp>                       iteration
  label <id> (: <typ>)? <exp>                    label
  break <id> <exp>?                              break
  continue <id>                                  continue
  return <exp>?                                  return
  async <exp>                                    async expression
  await <exp>                                    await future (only in async)
  assert <exp>                                   assertion
  <exp> : <typ>                                  type annotation
  <dec>                                          declaration (scopes to block)
  throw <exp>                                    raise error (only in async)
  try <exp> catch <pat> <exp>                    try (only in async)
* try <exp> catch { (case <pat> <exp>;) +} (<finally> <exp>)?  try-finally

<exp-field> ::=                                object expression fields
  var? <id> = <exp>                              field
```

## Patterns
```
<pat> ::=                                      patterns
  _                                              wildcard
  <id>                                           variable
  <unop>? <lit>                                  literal
  ( <pat>,* )                                    tuple or brackets
  { <pat-field>;* }                              object pattern
  # <id> <pat>?                                  variant pattern
  ? <pat>                                        option
  <pat> : <typ>                                  type annotation
  <pat> or <pat>                                 disjunctive pattern
* <pat> and <pat>                                conjunctive pattern
* async <pat>                                    asynchronous

<pat-field> ::=                                object pattern fields
  <id> = <pat>                                   field
```

## Declarations
```
<dec> ::=                                                 declaration
  <exp>                                                       expression
  let <pat> = <exp>                                           immutable
  var <id> (: <typ>)? = <exp>                                 mutable
  (actor|module|object) <id>? =? { <dec-field>;* }            object
  shared? func <id>? <typ-params>? <pat> (: <typ>)? =? <exp>  function
  actor? class <id> <typ-params>? <pat> (: <typ>)? =? <exp>   class
  type <id> <typ-params>? = <typ>                             type
  import <id>? =? <text>                                      import

<dec-field> ::=                                          object declaration fields
  (public|private|system)? (flexible|stable)? dec             field
```

## Programs
```
<prog> ::= <dec>;*

```



================================================
FILE: design/WhitePaper.md
================================================
# Motoko Evolution White Paper (Draft)

(Note: The status of this document still is very rough. It has more the character of a brain dump. Provided as is.)


## Background

### Introduction

*Motoko* is a general-purpose programming language designed to provide a seamless and modern programming experience on the Internet Computer (IC). To that end, it has built-in support for various features specific to the IC, such as:

* Representation of canisters as *actors* with asynchronous and atomic methods.
* Automatic integration with *Candid* for implicitly de/serialising message arguments and automatic derivation of Candid interfaces.
* *Async/await* support for straight-line coding of asynchronous messaging patterns.
* *Orthogonal persistence* keeping program state alive across messages automatically.
* *Stable variables* for persisting selected program state even across program version upgrades.
* Built-in support for other IC mechanisms, such as cycles, upgrades, heartbeat, etc (some of it still incomplete).

Motoko was initially designed and implemented as a relatively minimal language. This was both to keep it simple and to get off the ground more quickly. Consequently, there is a range of features it still lacks. Some are mere implementation gaps relative to the "complete" semantics provided by the interpreter, some are additional features that were anticipated from the beginning but consciously deferred, some have been discovered as new requirements over time.

The purpose of this document is to lay out the main directions of key features envisioned as future additions. None of these should be expected to materialise immediately. However, taken together, this document ought to provide a decent idea of the intended direction for the language, medium to longer-term.

This document focusses on the language itself. Implementation, tooling, and documentation improvements are a separate discussion altogether and not covered in this document. Likewise, it does not say much about libraries, except where they provide basic primitives of the language.


### Design Philosophy

Motoko tries to follow a set of design principles:

* *Safe.* The language should always default on the side of safety, encourage good code more than bad code, and avoid foot guns and unsafe or error-prone behaviours, unless explicitly requested by the programmer. The type system must be sound.

* *Simple.* The language should avoid complicated, hard-to-understand, or overly bleeding-edge features. It should minimise multiple redundant or overlapping ways to express the same thing (unless one can be expressed as syntactic sugar for another).

* *Understandable.* Where possible, the language should pick syntax and terminology that is intuitive and familiar from mainstream languages. It should avoid niche technical or theoretical jargon.

* *High-level.* The language should be productive and convenient to use, sufficiently expressive, and not bother the programmer with irrelevant details or error-prone routine.

* *Principled.* Both syntax and semantics should be based on well-behaved and well-understood, minimal and orthogonal, mechanisms and constructs and avoid ad-hoc behaviours, extensions, special cases, or leakage of implementation choices. Commonly expected meta-theoretical properties should hold for the language.

* *Definable.* It should be possible to specify the language in a declarative manner, using standard formal methods, without jumping through hoops. The language must never be "defined by implementation", meaning that there would be no way to specify it except by replicating implementation details of the compiler.

Oftentimes, these goals are difficult to achieve fully or can be in conflict with each other. Hence following them sometimes is a judgement call. However, none of these principles should be sacrificed completely.


### Main Concepts

* *Primitive types.* Motoko provides the usual set of built-in data types, such as various number types, Booleans, and text strings. Integral numbers have infinite precision by default, to prevent overflow bugs. Natural numbers are a restricted subtype of integers. Text strings are always assumed to be in Unicode, but without exposing a specific encoding. Motoko also provides (mutable or immutable) arrays and option types, the latter representing "nullable" types (of any form), but in a way that composes properly and enforces handling the null case where necessary.

* *Objects.* Motoko features a simple object and class system. It provides interface inheritance (via structural subtyping), but no implementation inheritance or downcasts. The semantic model for objects is essentially records of closures (closing over the private fields in particular). A class is simply a syntactic shorthands for a function returning an object, plus a type definition of the same name.

* *Actors.* The actor system is designed to be in 1-to-1 correspondence with the object system. Actors are essentially a restricted version of objects, with only asynchronous (and shared) methods. Actor classes look like classes, but producing an actor instead of an object. Typing is similarly symmetric.

* *Futures.* Expressions can be asynchronous, in which case their immediate result is just a future (a value of type `async T`), whose value is determined later. The value can only be accessed through the await operator, which in turn is only allowed inside another asynchronous expression. It suspends evaluation of that expression until the value is available, allowing interleaving of other computations in the same actor. It also commits all state changes performed thus far. Asynchronous functions are simply a shorthand for functions whose body is an asynchronous expression.

* *Functional constructs.* At its heart, Motoko has all features of a modern functional language, such as first-class functions (a.k.a. closures), tuples, algebraic data types (a.k.a. variants and records), polymorphism (a.k.a. generics), checked pattern matching (in the form of a generalised `switch`), and the fact that there are no statements but everything is an expression.

* *Modules.* Motoko also features a simple module system, where modules are essentially a restricted form of object that must be stateless. Modules can contain type definitions, but not (currently) abstract them, i.e., hide their implementation. A Motoko compilation unit is either a module, or a top-level actor or actor class definition that can be imported as if it was contained in a module.

* *Canonical type system.* Motoko's type system, at its core, is a fairly canonical typed lambda calculus with primitive types, labeled products and sums (i.e., objects and variants), first-class function types, polymorphism (i.e., generics), and structural recursive subtyping with top and bottom types. Type theory experts will recognise the close similarity to (Kernel) System F\<:. Type checking mostly follows a strict bidirectional discipline, with only a few exceptions regarding optional inference of polymorphic type instantiation, overloaded operators, and multiple passes to account for recursive declarations.

* *Shared types.* Motoko distinguishes a subset of types that are "sharable". These are those types whose values can be serialised, compared, or otherwise be inspected transparently. They include primitive types, immutable aggregates (arrays, objects, variants) whose components are shared, and references to actors or shared functions.


## Future Extensions

The following sections present various ideas of varying level of complexity, in no particular order and with no particular priorities. Some of them are fleshed out more concretely, while in some cases the details are not obvious. Where applicable, respective tracking issues in the Motoko repository are included, which sometimes contain further discussion.

In some cases, the description contains partial sketches of a formalisation. This can be skipped by readers not interested in the inner workings of a compiler.


### More Checking

Motoko should help detecting common sources of bugs, especially those of the subtle kind. To that end, the language ought to add more checking mechanisms.


#### Unused Identifiers ([#1489](https://github.com/dfinity/motoko/issues/1489))

It often is a symptom of a bug that an identifier is defined but never used. To diagnose these, the compiler should warn about unused identifiers (values, types, or otherwise).

On the other hand, it is occasionally useful to introduce unused identifiers for documentation purposes, e.g., unused function parameters, pattern components, etc.. To that end, an exception is made for identifiers starting with `_`, which are not warned if unused. This way, a programmer can still document the role of a binding, and simultaneously document that it is intentionally unused.

The `_` prefix convention is natural and common in languages that provide pattern matching and already use `_` for anonymous patterns, like Motoko.


#### Atomicity Violations ([#792](https://github.com/dfinity/motoko/issues/792))

Following the actor model, method execution is atomic in Motoko. However, this is only true up to uses of `await`. Semantically, every await splits execution of a method into separate actor-to-actor messages that can be interleaved by other calls. These calls may modify the state, opening up the possiblity of subtle reentrancy bugs if computations after an await depend on state read before the await. For example:
```
actor {
  var list : List<Nat> = null;
  public put(x : Nat) { list := List.push(x, list) };
  public average() : async Nat {
    let size = List.size(list);
    if (size == 0) return 0;
    let cap = await other.cap_value();
    var a = 0;
    List.iterate(list, func(n) {a := a + min(n, cap)});
    return a/size;
  }
}
```
Here, `size` is computed before calling out to `other.cap_value` and awaiting the result. Because of the await, another call to `put` may happen in the meantime, resulting in an incorrect average computation.

The async/await construct, and the ability to suspend a method with it, undermines one of the core properties of the actor model, namely the fact that methods are fully atomic. On the other hand, the practical convenience of async/await is so substantial that it still is a worthwhile trade-off.

To eliminate the disadvantage, the Motoko compiler could detect that there is a dependency on the current state of `list` across an await and warn.

However, sometimes such dependencies are necessary. So there needs to be a way for the programmer to declare intent and prevent the warning. Unfortunately, it is not obvious what a clean and general solution to this problem would be.

A related issue is that `await` also represents a commit point: if execution traps, the current method is aborted, but only up to the last await. Any state changes or messages sent before the last await will remain effective, potentially leaving the actor with inconsistent state. Consider:
```
actor {
  var list : List<Nat> = null;
  var len : Nat = 0;
  public putLogged(x : Nat) : async () {
    let := len + 1;
    let y = await other.process(x);
    list := List.push(y, list);
    log("old head: " # Nat.toText(List.head(List.head(list))));
  }
}
```
Here, if the logging attempt fails because the original list was empty, then the mutation of `list` will be abandoned, but not the mutation of `len`, because that happened before the `await`, and thus has already been committed to the actor's state.

There is no easy general solution to the problem – that would require the implementation of distributed transactions on the level of the IC, which are notoriously hard and expensive. But again it might be desirable to warn against accidental state mutations before an await, unless the programmer declares intent explicitly – and thereby, presumably, was aware of the implications.


### Primitive Types

Primitive types in Motoko still lack basic functionality.

#### Number Conversions

Currently, converting between different number types requires going through `Nat` or `Int` in most cases:
```
func nat8ToNat16(n : Nat8) : Nat16 { Nat18.fromNat(Nat8.toNat(n)) }
```
Obviously, that's both inconvenient and expensive. The base package should directly support the complete conversion matrix for all number types (nats, ints, and floats).


#### Blobs

Blobs are essentially arrays of bytes, but they currently lack basic array functionality, like random access. That ought to be made available analogously to regular arrays.


#### Text

All text strings are in Unicode in Motoko. But there is no proper support for Unicode-aware text processing. For example, there are no Unicode-enabled comparison operators, and no Unicode character classification or conversion functions.

Adding these requires including Unicode libraries and tables into the generated Wasm code, which can easily be several MB in size. Presumably, supporting Unicode would hence depend on some tree shaking ability of the compiler.

Another shortcoming in text processing is the inability to efficiently extract substrings. Motoko provides iterators over strings, but they cannot be used as arguments to other operations, because their type is structural. A solution to this is needed, e.g., by extending text iterator objects in some way. Details tbd.

Finally, it would sometimes be desirable to have extended syntax for multi-line text literals, ideally with interpolation, perhaps based on a generic `toText` function (see [shared generics](#shared-generics)).


### Type System

The Motoko type system has a number of known gaps that stand in the way of certain forms of abstraction and composition.


#### Type Fields ([#760](https://github.com/dfinity/motoko/issues/760))

Motoko allows type members in objects and modules:
```
object o {
  public type T = Nat;
  public let n : T = 0;
};
let n : o.T = o.n;
```
However, there is no way to actually express the type of `o` itself in Motoko's surface syntax, since type fields are not allowed in object _types_.

The following syntax should be available:
```
type O = {
  type T = Nat;
  n : Nat;
}
```
One delicate question here is whether it should be allowed to refer to a type field like `T` from within the record type itself – e.g., whether declaring `n : T`should be allowed to define the second field. The rules should be consistent with the scoping of value fields in plain record syntax, where
```
let x = 0;
let o = {x = 1; y = x};
```
has `x` referring to the outer binding. Consequently, the rules should be the same for types, and `n : T` not be allowed.

Note that all type definitions in an object are still transparent. Furthermore, in order to express the type of objects with recursive type fields, [anonymous recursive types](#anonymous-recursive-types) are also needed.

##### Formalisation

Syntax:
```
<typfld> ::= ... | type <id> < <typbind>,* >? = <typ>
```

Kinding:
```
(C,typbind* ⊢ typbind ok)*
C,typbind* ⊢ typ : Ω
-----------------------------------
C ⊢ type X<typbind*> = typ : X:Ω*→Ω
```


#### Anonymous Recursive Types

In Motoko, types can be recursive or mutually recursive. However, recursive types can only be written as named declarations. It is not possible to write an _anonymous_ recursive type inline, e.g., directly in a type annotation.

That is a problem when there is no place to put a type declaration, or when the compiler has to produce a type (e.g., as part of an error message) in a place where the respective type declarations are no longer in scope. For example:
```
let f = do {
  type A = {#aa; #ab : B};
  type B = {#bb; #ba : A};
  func(x : A) {...};
}
```
Here, the type of `f` can only be expressed in reference to types `A` and `B`, but those are not accessible outside the `do`.

The solution is to add recursive type expressions. In analogy to functions and other term-level recursive expressions, one way to do this would be by allowing type declarations as type expressions:
```
<typ> ::= ... | type <id>? =? <typ>
```
The optional identifier in this phrase is only available within the right-hand side type `<typ>`, and allows recursive references of that type to itself (if omitted, the syntax has the same meaning as plain `<typ>`).

With that, the type of `f` can be written as:
```
f : (x : type A {#aa; #ab : {#bb; #ba : A}}) -> ()
```

##### Formalisation

Syntax:
```
<typ> ::= ... | type <id>? < <typbind>,* >? =? <typ>
```

Kinding:
```
(C,typbind* ⊢ typbind ok)*
C,X:Ω*→Ω,typbind* ⊢ typ : Ω
typ productive
typ uniform wrt X<typbind*>
-------------------------------
C ⊢ type X<typbind*> T : Ω* → Ω
```

Equivalence:
```
C,X<typbind*>≡typ,typbind* ⊢ typ ≡ typ'
=======================================
C ⊢ type X<typbind*> typ ≡ typ'
```


#### Open Type Aliases

Type definitions are currently restricted in that they can only refer to their own type parameters, not to outer ones:
```
func f<A>(x : A) {
  type M<B> = HashMap<A, B>;  // error, can't refer to A
  ...
}
```
The reason for this restriction are mostly technicalities in the compiler and should be lifted.


#### Shared Generics ([#2096](https://github.com/dfinity/motoko/issues/2096))

Motoko defines the notion of _shared_ types. As mentioned above, these are the types whose values can be serialised, compared, or otherwise be inspected transparently.

Unfortunately, type _parameters_ are never deemed shared, because they can be instantiated arbitrarily. That prevents certain useful abstractions:
```
type Id<A> = shared (x : A) -> async A
```
Here, the use of `A` inside a shared function type will be rejected, because it cannot be guaranteed that all instantiations of `F` pick a shared type.

More interestingly, this prevents writing generic abstractions that require values of arbitrary shared type, e.g., to send a message:
```
func sendTwice<A>(x : A, f : shared A -> ()) {
  f(x);
  f(x);
}
```

Allowing this requires expressing a constraint on the type parameter:
```
type Id<shared A> = shared (x : A) -> async A

func sendTwice<shared A>(x : A, f : shared A -> ()) {
  f(x);
  f(x);
}
```

With that, any type parameter can be marked shared. If present, the bound of a shared parameter must itself be a shared type.

This extension is easy to implement for type definitions, but much more involved for generic functions or classes: to implement `sendTwice`, the value `x` must be serialised with type `A`, but that type is not known statically. Hence, every shared type parameter on a generic function or class will require a runtime type representation that the de/serialiser can interpret at runtime. This requires extensions to calling conventions, generic instantiation, as well as the implementation of de/serialisation itself.

On the plus side, the same mechanism can then be used to express any abstractions over shared types. For example, it would be possible to use equality over generic types:
```
func contained<shared A>(x : A, ys : [A]) : Bool {
  for (y in ys.values()) { if (x == y) return true };
  return false;
}
```

It would also allow getting rid of (and generalising) the hack that currently is the `debug_show` keyword, and instead surface it as a proper generic library function:
```
toText : <shared A>(A) -> Text;
```

A possible further extension is providing the programmer to write functions of this sort themselves. That would require adding a form of type-switch for intensional type analysis to the language.
```
func myToText<shared A>(x : A) : Text {
  switch type A {
    case Nat { Nat.toText(x) };
    case Bool { if x "true" else "false" }
    case _ { "?" }
  }
}
```
The challenge would be designing this construct such that it works for variadic types like tuples, objects, or functions, let alone generic types.


##### Formalisation

Syntax:
```
<typbind> ::= shared? <id> (<: <typ>)?
```

Kinding:
```
C,shared X<:typ ⊢ typ : Ω
C,shared X<:typ ⊢ typ shared
----------------------------
C ⊢ shared X <: typ ok
```


### Core Language

#### General `do`-Expressions

Motoko recently introduced `do?` expressions to make handling and threading of option types more convenient. A similar shorthand is desirable for other types, e.g., the type `Result<A, B>`.

However, such a generalisation requires specifying how values are composed for a given type. In semantic terms, the general abstraction is that of a so-called _monad_. A type `M<A*>` in question needs to define two operations:
```
make : <A*>(x : T) -> M<A*>
chain : <B*,A*>(x : M<B*>, f : T -> M<A*>) : M<A*>
```
You will note that the Motoko library already contains these operations for relevant types.

With that, the `do?` expression can be generalised to a form
```
do <id> { ... }
```
where the identifier refers to a module defining the above operations for the type in question.

Roughly, such a `do`-expression desugars into an expression whose last step is a call to `<id>.make`. Each use of `!` will be translated into a call to `<id>.chain`, after CPS-transforming the remainder of the body. For example, assume
```
g : Nat -> Result<Text, Error>
```
Then the expression
```
do Result { f(g(1)!, g(2)!) }
```
becomes
```
Result.chain(g(1),
  func(x) {
    Result.chain(g(2),
      func(y) {
        Result.make(f(x, y))
      }
    )
  }
)
```
Consequently, if `g(1)` produces an error result, that is the result of the whole expression. Otherwise, if `g(2)` produces an error result, that is the result of the whole expression. Otherwise, the result is `#ok(f(x, y))`.

With this generalisation, the expression `do?` effectively becomes a shorthand for `do Option`.

It would be ideal if `async/await` could be interpreted as an instance of this construct as well, though that may be difficult to achieve due to implementation constraints.

##### Formalisation

Syntax:
```
exp_nondec ::= ... | do <exp_nullary> <exp_block>
```

Typing:
```
C ⊢ exp1 :syn T1
C,do:T1 ⊢ exp2 :syn T2
T1 = { make : <A*>(T2') -> T; ... }
C ⊢ T2' <:infer T2[U*/A*]
-----------------------------------
C ⊢ do exp1 exp2 :syn T[U*/A*]

C ⊢ exp :syn T1
C(do) = { chain : <A*>(T1', T1'' -> T'') : T'; ... }
C,A* ⊢ T1' <: T1''
C,A* ⊢ T'' <: T'
C ⊢ T1 <:infer T1'[U*/A*]
-------------------------
C ⊢ exp! :syn T'[U*/A*]
```
The relation `<:infer` infers the rhs type substitution, as for implict type arguments in a generic call. The expression is ill-typed if it can't be inferred.

Challenge: One issue with the above is that `T1` does not generally determine all type parameters of `chain`, particularly the ones only occurring in the result type `T'`. It may be necessary to type-check `exp!` in analysis mode, though that could be inconvenient.


#### Bindings in `or`-Patterns ([#3807](https://github.com/dfinity/motoko/pull/3807))

When using `or`-patterns, it is possible to bind a variable in the alternatives. This is useful to avoid `case` repetitions:
```
func free(x : Text, e : exp) : Nat {
  switch e {
    case (#lit(_)) { 0 };
    case (#var(y)) { if (y == x) 1 else 0 };
    case (#add(e1, e2) or #sub(e1, e2)) { free(x, e1) + free(x, e2) };
  }
```
An or-pattern binding identifiers is well-formed only if both alternatives bind the same set of identifiers. The observed type of each identifier is the lub of the individual binding types.

##### Formalisation

Typing:
```
C ⊢ pat1 :syn T1 ⊣ C1
C ⊢ pat2 :syn T2 ⊣ C2
dom(C1) = dom(C2)
---------------------------------------
C ⊢ pat1 or pat2 :syn T1 ⊔ T2 ⊣ C1 ⊔ C2

C ⊢ pat1 :anal T ⊣ C1
C ⊢ pat2 :anal T ⊣ C2
dom(C1) = dom(C2)
----------------------------------
C ⊢ pat1 or pat2 :anal T ⊣ C1 ⊔ C2
```


#### `and`-Patterns

Analogous to disjunctive `or`-patterns, the language could also provide conjunctive `and`-patterns. they would be a generalisation of the notion of `as`-patterns present in other languages with pattern matching. Their main benefit is that they allow binding a name to a pattern while still matching it:
```
let (x, y) and p = f();
```
Here, `f` returns a pair that will be bound to `p`, while simultaneously, `x` and `y` will be bound to its components.

##### Formalisation

Syntax:
```
<pat_bin> ::= ... | <pat_bin> and <pat_bin>
```

Typing:
```
C ⊢ pat1 :syn T1 ⊣ C1
C ⊢ pat2 :syn T2 ⊣ C2
----------------------------------------
C ⊢ pat1 and pat2 :syn T1 ⊓ T2 ⊣ C1 ⊓ C2

C ⊢ pat1 :anal T ⊣ C1
C ⊢ pat2 :anal T ⊣ C2
-----------------------------------
C ⊢ pat1 and pat2 :anal T ⊣ C1 ⊓ C2
```


### Objects

#### Object Composition ([#3072](https://github.com/dfinity/motoko/issues/3072))

Currently, objects can only be constructed using object literals. It is not possible to construct an object in terms of another, preexisting object with some fields updated or added.

Some functional languages provide forms of _record update_, where a form of object literal is provided that replaces or adds individual fields of a pre-existing object. In Motoko, this could easily be generalised to object _merging_, akin to type intersection:
```
let o1 = {a = 1; b = 2};
let o2 = {a = 3; c = 4};
let o3 = o1 with o2;
```
Unlike type intersection, however, this operator cannot apply recursively. Instead, if the fields of both operands overlap, the right-hand side value takes precedence. Consequently, `o3` would result in the object `{a = 3; b = 2; c = 4}`.

If any of the fields are mutable, their state is duplicated in the new object – as an alternative design choice, they could become immutable; or it may be prohibited to merge stateful objects at all. Either way, the new object will only contain the public fields of the operands. It does _not_ duplicate private state. Likewise, functions/methods copied into the new object are not magically rewired to close over the new state, they'd still close over the original state unchanged.

One challenge is that for Motoko, such a mechanisms would be expected to symmetrically apply not just to regular objects, but also to actor or module objects. For example, this would allow to compose actors:
```
actor a {
  public func f() {}
}
let b = a with actor {
  public func g() {}
}
```
However, it is not clear how to implement this if an actor contains mutable state. Actor composition may only be possible via [mixin classes](#mixin-composition).


##### Formalisation

Syntax:
```
<exp_bin> ::= ... <exp_bin> with <exp_bin>
```

Typing:
```
C ⊢ exp1 :syn {(var? x1:T1)*; (var? x:T1')*}
C ⊢ exp2 :syn {(var? x2:T2)*; (var? x:T2')*}
x1* disjoint x2*
---------------------------------------------------------------------
C ⊢ exp1 with exp2 :syn {(var? x1:T1)*; (var? x2:T2)*; (var? x:T2')*}
```


#### Mixin Composition

Motoko does not provide implementation inheritance for classes. That is intentional: method overriding is a risky and error-prone mechanism, and even experienced programmers often use overridability carelessly, in ways that can easily allow subclasses break the assumed invariants of a class.

So far, there have been surprisingly few complaints about Motoko's lack of class inheritance.

However, should this become an issue, a more elegant and safer alternative is the introduction of a mechanism for _mixin-composition_, which is a form of generalisation of object merging.

Mixins are classes with _abstract_ fields. That is, some of their fields may not have a definition – they are "holes" in the object that are to be filled in later (similar to abstract methods in some OO languages, but not restricted to methods). The holes are filled by merging with another mixin or object that provides a definition for this hole. Only after all holes have been filled through composition, the result defines a proper class. For example:
```
abstract class A(x : Nat) {
  public abstract func f() : Nat;
  public func g() : Nat { f() + x }
}

class B(x : Nat) = A(x) with {
  public func f() : Nat { 7 }
}
```
Mixin composition thereby addresses similar use cases as implementation inheritance. But it only allows defining _abstract_ fields and methods, not overriding ones that were already defined. That way, it merely provides a way to express a form of (recursive) functional abstraction, not a stateful mechanism to "patch" an existing definition. That avoids most risks of general inheritance.

At the same time, mixin composition has the added advantage that it is symmetric, i.e., merging two mixins can define abstract fields in both directions simultaneously. For example:
```
abstract class A() {
  public abstract let x : Nat;
  public let y = 1;
  public func add() : Nat {x + y}
};
abstract class B() {
  public let x = 2;
  public abstract let y : Nat;
  public func mul() : Nat {x * y}
};
class C() = A() with B();
```
In this example, the `with` operator plugs together two abstract objects as if they are two jigsaw pieces. However, the composition may also leave some or all abstract fields alone, producing a new abstract class:
```
class Z() {
  public let zero = 0
};
abstract class D() = A() with Z();
```
Here, `D` still has an abstract field `x`.

Of course, a class can also compose more than 2 objects.

Mixin composition would also work fine for actor classes, and is more easily implementable than merging of actor objects:
```
abstract actor class Ping() {
  var x : Nat = 1;
  public func ping() : Nat { pong() + x };
  public abstract func pong() : Nat;
};
abstract actor class Pong() {
  var x : Nat = 2;
  public func pong() : Nat { ping() * x };
  public abstract func ping() : Nat;
};
actor class Tennis() = Ping() with Pong();
```

Obviously, however, mixins are a highly involved feature, and shouldn't be introduced light-heartedly. Many details are ignored above, and they induce significant complexity. For now the hope is that Motoko can get along without such a feature.


### Actors

Actors are Motoko's representation of IC canisters, but they were designed to allow more flexibility than just being static pieces of code.


#### Local Actors

As mentioned above, actors in Motoko are designed as a restricted form of object, where all public functions have to be defined as asynchronous and shared. Other than that, they ought to have mostly the same "rights" as regular objects. In particular, it is intended to be possible to define actors (or actor classes) in local scope, and to have them refer to definitions from outer scopes.

One crucial restriction, though, is that those outer definitions must be of shared types (and not `var` bindings), such that referencing them does not imply mutable state being shared across multiple actors, which would break the actor model.

One interesting special case of such an "outer" reference is a recursive reference to an actor or actor class itself, which technically lives in the scope surrounding it. For example:
```
actor class A(xx : Nat) {
  let x = xx;
  public func fork() : async A {
    await A(x + 1)
  }
}
```

Local actors and actor (class) closures are implemented in the Motoko interpreter, but they are not yet handled by the compiler. The main reason is that it is not obvious how to compile them to the IC in general. While it isn't too difficult to implement closures for plain actor expressions (e.g., by abusing the canister's init args to initialise the closure environment), it is more difficult to pull it off for actor _classes_, where the init args are visible and used by clients. It may require generating the Wasm binary for a canister representing an actor class closure at runtime, embedding the serialised closure environment in some form.

An additional complication arises from recursion and mutual recursion, such as two actors referring to each other. Interestingly, in the example above, the Wasm module representing actor class `A` would have to be able to reproduce instances of its own code, akin to a quine. Unless the IC enables a way for a canister to reference its own code, this would be difficult in general.


#### Local Shared Functions

The methods of an actor are _shared functions_, meaning that they (technically, references to them) can be passed to another actor. However, like with regular functions, it is occasionally convenient to be able to define shared functions locally, e.g., as shared "lambdas" passed as argument to another actor.

An obvious implementation of this is via hoisting the function to the enclosing actor. However, local functions are primarily useful if they can refer to definitions from their local scopes, as _closures_. The tricky part is to represent such closures on the IC. This would require the implementation to pair a function reference with an additional closure environment that is passed along with both the function and every call back to the function (as an additional parameter).

Such closures could be supported by an extension of Candid (via closure types, which would be a refinement of function types). But in addition, it is highly desirable that closure environments cannot be forged outside the originating actor, since that would easily allow breaking encapsulation properties. Ideally, they also should not be readable by others. Both could be achieved by signing and encrypting them in the originating actor in some fashion, or if the IC itself provided some respective functionality for passing "sealed" values. Details tbd.

Note: the obvious "solution", namely storing closure environments inside the originating actor and merely passing out handles to them, is not sufficient, since malicious actors might still incorrectly reuse handles they receive. Furthermore, storing the data locally induces a life time problem, since the actor cannot know if another actor still holds a reference to the closure, so it could never garbage-collect the data.


#### Upgrades and Memory

The most difficult problem to solve in the programming model of the IC by far is the question of safe and robust upgrades.
For this purpose, Motoko implements powerful and safe persistence, see [Enhanced Orthogonal Persistence](OrthogonalPersistence.md).

#### Upgrades and Methods

Another issue with upgrades on the IC is outstanding replies: if an actor is still waiting for a reply to some message it sent, upgrading might potentially lose the ability to handle the result.

To enable new versions of a canister to handle replies targetted at an earlier version, the IC and the language runtime need to know which code to reroute the reply to. Since the canister's code might have changed arbitrarily after the upgrade, this isn't generally possible without some indication from the programmer. At a minimum, they must somehow name the "entry points" for replies, such that they can be uniquely identified. Details tbd.


### Modules

#### Import Destructuring ([#2354](https://github.com/dfinity/motoko/issues/2354))

In current Motoko, an import declaration binds the imported module to a single identifier, and all accesses to the module have to be qualified with that module name.

An obvious extension is to allow pattern matching in import declarations to destructure the module and bring its components into scope unqualified:
```
import {freeze; size = asize} "mo:base/Array"
```

Mostly, this extension is syntactic sugar.

##### Formalisation

Syntax:
```
impdec ::= import <pat> =? <textlit>
```


#### Separate Compilation

The most serious restriction of the Motoko module system right now is that the compiler does not actually support compiling modules individually. Instead, it is a _whole-program_ compiler that always recompiles the full transitive set of all imports. Obviously, this will cause a bottleneck in turn-around times for large programs. Motoko should support separate compilation and separate linking of produced modules into a complete canister.


#### Foreign Function Interface

The ability to link compiled modules together would also be a first step towards supporting the import of modules written in other languages than Motoko, such as Rust.

Unfortunately, though, this is a more difficult problem than linking modules compiled in the same language, since the data types, memory management, and calling conventions used by different languages are rarely compatible. Supporting cross-language calls requires a suitable ABI agreed upon by different Wasm compilers, which in turn requires some kind of standard. There is work on a proposal ([interface types](https://github.com/WebAssembly/interface-types/blob/main/proposals/interface-types/Explainer.md)) for Wasm that could be the basis of such a mechanism, but it's not ready yet.

Wasm component model offers a solution for secure intra-canister language interop on the IC.


#### Onchain Linking

[Separate compilation](#separate-compilation) avoids the need to _compile_ applications in a monolitic manner, but it does not prevent the need to _deploy_ them in monolithic form. No matter how large an application and how small a change, upgrading always requires redeploying the entire code.

Also, it is not possible to share modules onchain between multiple applications. For features like [unicode support](#text), it would be desirable if respective modules of the language runtime would only have to be installed on the chain once and could be shared between applications.

Supporting this would require a new mechanism in the IC that allows canisters to consist of more than just a single Wasm module, and linking these modules _dynamically_, "onchain", reminiscent of dynamic linking in conventional operating systems. Unfortunately, there currently isn't any mechanism planned for the IC to support that.


### Platform Support

Besides the basic functionality of canisters and message sends between them, the IC has a number of ad-hoc mechanisms that only have basic support in Motoko so far.

#### Cycles ([#1981](https://github.com/dfinity/motoko/issues/1981))

The most important mechanism probably is the ability to send and receive cycles. The Motoko library currently provides an experimental low-level module to handle cycles, but obviously more high-level mechanisms would be desirable.

Ideally, Motoko should be able to represent cycles as a form of _linear resource_, like other smart contract languages do. Such a representation can provide significant aids to the programmer, i.e., the ability to check that funds aren't lost accidentally.

Unfortunately, the implementation and semantics of cycles on the IC is quite a bit more ad-hoc, and it is not obvious how to design a nice language-level abstraction around them that would have enforcable properties.

At a minimum, Motoko needs language extensions to send cycles along with messages, and likewise to receive them. This could either be through ad-hoc syntax, or preferably, through library primitives.

Even less clear is whether such a mechanism could be designed in a general enough fashion that could also model the transfer of ICPs or other custom tokens.

This also is an open question for Candid, which may want means to declare cycle or token transfer for functions.


#### IC library

There are other features of the IC that require support, e.g., access checks, heartbeat, etc. Some of these can hopefully be encapsulated in dedicated libraries, others might need minimal language support, such as new `system` methods an actor can define.

It would be desirable to sperate all IC-specific modules into a new `ic` library separate form `base`, in order to separate platform-neutral and platform-specific concerns.


#### Capabilities

The current authentication mechanisms of the IC, via access checks on caller etc, are very 1980. Access control is known to have fundamental flaws.

We would hope that the IC will eventually adopt a more modern and robust approach using [capabilities](https://en.wikipedia.org/wiki/Capability-based_security) for its programming model. Such a model also maps much more elegantly to a programming language like Motoko.


## Tooling Improvements

Tbd.

### Better Errors

### Logging

### Profiling

### Debugging

### Formalisation



================================================
FILE: doc/README.md
================================================
# Building the documentation locally

You can build the basic documentation locally as follows:

```
make
python3 -m http.server --directory html
# now open http://0.0.0.0:8000/motoko.html
```

CI pushes these docs for latest master to
[https://hydra.dfinity.systems/job/dfinity-ci-build/motoko/docs/latest/download/1/overview-slides.html](https://hydra.dfinity.systems/job/dfinity-ci-build/motoko/docs/latest/download/1/overview-slides.html).

The local documentation is suboptimal and compiled with pandoc, not
docusaurus so it doesn't understand or process remark-code-import file includes,
docusaurus admonitions (`:: Tip` etc) nor enable the motoko interpreter.

For a richer preview that supports these features,
and auto-updates as you edit doc source, try:

```
make preview
```

This uses a small ./docusaurus project to build a reduced web site locally, opening it your browser. It should be a subset of the full portal documentation,
complete with live code blocks.

In order to preview the real portal documentation, open a PR
https://github.com/dfinity/portal, edit the git "submodule"for
Motoko to point at the PR branch and wait for CI to produce a build or
follow the instructions to produce one locally.

# Support the moc interpreter in documentation

We wrap Docusaurus's module `CodeBlock/Content/String` to process Motoko code blocks with interpreter.
To enable this feature, add the following flags for code blocks:

* "```motoko" adds a Run button
* "```motoko run" adds a Run button and display the result
* "```motoko no-repl" syntax-highlighting only.
* "```motoko name=filename" saves the code as filename.mo so that it can be imported or referenced from another code block. An absent filename defaults to stdin.
* "```motoko include=f1,f2" run `f1.mo`, `f2.mo` before running the current code, equivalent to `moc -i f1.mo f2.mo current_code.mo`. It will fetch the updated code each time we click run. Note that if the code import "f1" but doesn't use include_f1, the code won't be updated until we click the run button for f1.mo.

The config flags can be used in any order with any combinations, e.g.
"```motoko run name=main include=f1,f2"



================================================
FILE: doc/chat.mo
================================================
type List<T> = ?{head : T; var tail : List<T>};

type Post = shared Text -> ();

actor Server = {
  private var clients : List<Client> = null;

  private shared func broadcast(message : Text) {
    var next = clients;
    loop {
      switch next {
        case null return;
        case (?l) {
          l.head.send(message);
          next := l.tail;
        };
      };
    };
  };

  public func subscribe(client : Client) : async Post {
    let cs = {head = client; var tail = clients};
    clients :=  ?cs;
    return broadcast;
  };
};

type Server = actor { subscribe : Client -> async Post; };

actor class Client() = this {
  private var name : Text = "";

  public func start(n : Text , s : Server) {
    name := n;
    let _ = async {
       let post = await s.subscribe(this);
       post("hello from " # name);
       post("goodbye from " # name);
    }
  };

  public func send(msg : Text) {
    debugPrint(name # " received " # msg # "\n");
  };
};


let bob = Client();
let alice = Client();
let charlie = Client();

bob.start("bob", Server);
alice.start("alice", Server);
charlie.start("charlie", Server);



================================================
FILE: doc/Makefile
================================================
all: overview-slides.html html

RELEASE=0.14.0
SHELL=bash
OUT=md

overview-slides.html : overview-slides.md
	pandoc \
	  -t revealjs -s -o overview-slides.html overview-slides.md \
	  -V theme=moon \
	  --strip-comments \
	  -V revealjs-url=https://cdn.jsdelivr.net/npm/reveal.js@4.1.0 \
	  #--standalone \
	  # -V width="\"100%\"" \
	  # -V height="\"100%\"" \
	  # -V margin=0 \
	  # # -V minScale=2 \
	  # # -V maxScale=2

base:
	mo-doc --source $(MOTOKO_CORE) --package core --output $(OUT)/core --format plain
	mo-doc --source $(MOTOKO_BASE) --package base --output $(OUT)/base --format plain

html:
        # TODO: perhaps use node and remark-cli to compile out remark plugins first or use docusaurus to build site properly
	rm -rf html
	mkdir -p html
	for f in md/*/*.md; do pandoc -f gfm --toc -t html -s --metadata title="$$f" -o html/$$(basename $$f .md).html $$f; done


# for building inside nix using a locally built interpreter
preview:
	make -C ../src moc_interpreter.js
	cp -f ../src/moc_interpreter.js docusaurus/static
	cd docusaurus; npm install; npm run clear; npm start

# for building outside nix using a downloaded interpreter
doc:

	rm -f docusaurus/static/moc_interpreter.js
	wget -O docusaurus/static/moc_interpreter.js https://github.com/dfinity/motoko/releases/download/$(RELEASE)/moc-interpreter-$(RELEASE).js
	cd docusaurus; npm install; npm run clear; npm start

.PHONY: base
.PHONY: md
.PHONY: html
.PHONY: preview
.PHONY: doc




================================================
FILE: doc/overview-slides.md
================================================
% Motoko
% A comprehensive overview

# Overview

### Motivation and Goals

A simple, useful language for the Internet Computer (IC)

* Familiar syntax
* Safe by default
* Incorporating ~~actor~~ *canister* model
* Seamless integration of IC features
* Making most of present and future WebAssembly

### Key Design Points

* Object-oriented, functional & imperative
* Objects as records of members
* `async`/`await` for sequential programming of asynchronous messaging
* Structural typing with simple generics and subtyping
* Safe arithmetic (unbounded and checked)
* Non-nullable types by default
* JavaScript-like syntax but statically typed & sane

Inspirations: Java(Script), C#, Swift, Pony, ML, Haskell

### Semantics

* call-by-value
  (like Java, C, JS, ML; unlike Haskell, Nix)
* declarations are locally mutually recursive
* parametric, bounded polymorphism
* subtyping as subsumption, not coercion.
* no dynamic casts
* no inheritance

### Implementation(s)

* implemented in OCaml (leverages `wasm` libary)
* simple reference interpreter
* less simple compiler to WebAssembly
  * multipass with typed IR in each pass.
  * uniform representation, unboxed arithmetic
  * two-space gc (for now), gc between messages
* polymorphism by erasure

# The language

## Expressions

* Identifiers:  
  `x`, `foo_bar`, `test'`, `List`, `Map`

* Parentheses for grouping

* Type annotations (to help type inference):  
  `(42 : Int)`

## Blocks and declarations

```
  type Delta = Nat;
  func print() {
    Debug.print(Int.toText(counter));
  };
  let d : Delta = 42;
  var counter = 1;
  counter := counter + tmp;
  print();
```

* Semicolon after each declaration!
* Mutually recursive
* Mutable variables marked explicitly

## Control flow

- `if (b) …`
- `if (b) … else …`
- `switch x { case (pat1) e1; …; case _ en }`
- `while (b) …`
- `loop …`
- `loop … while (b)`
- `for (pat in e) …`

<!--
### Labels, break and continue

  - `label l exp`
  - `break l` (more generally, `break l exp`)
  - `continue l`

labels ensure control flow is structured (no gotos)
-->


# Primitive types

## Unbounded integers

`Int`

Inferred by default for negative literals.

Literals: `13`, `0xf4`, `-20`, `+1`, `1_000_000`


## Unbounded naturals

`Nat`

Non-negative, trap upon underflow.

Inferred by default for non-negative literals

Literals: `13`, `0xf4`, `1_000_000`

## Bounded numbers (trapping)

`Nat8`, `Nat16`, `Nat32`, `Nat64`,
`Int8`, `Int16`, `Int32`, `Int64`

Trap on over- and underflow. Wrap-on-trap and bit-manipulating operations available.

Needs type annotations (somewhere)

Literals: `13`, `0xf4`, `-20`, `1_000_000`

## Floating point numbers

`Float`

IEEE 754 double precision (64 bit) semantics, normalized NaN

Inferred for fractional literals

Literals: 0, -10, `2.71`, `-0.3e+15`, `3.141_592_653_589_793_12`

## Numeric operations

No surprises here

`- x`  
`a + b`  
`a & b`  
…

## Characters and text

`Char`, `Text`

Unicode! No random access.

 * `'x'`, `'\u{6a}'`, `'☃'`,
 * `"boo"`, `"foo \u{62}ar ☃"`
 * `"Concat" # "enation"`

## Booleans

`Bool`

Literals: `true`, `false`

`a or b`  
`a and b`  
`not b`  
`if (b) e1 else e2`

# Functions

## Function types

* Simple functions:
  ```
  Int.toText : Int -> Text
  ```

* multiple arguments and return values  
  ```
  divRem : (Int, Int) -> (Int, Int)
  ```

* can be generic/polymorphic  
  ```
  Option.unwrapOr : <T>(?T, default : T) -> T
  ```

* first-class (can be passed around, stored)  
  ```
  map : <A, B>(f : A -> B, xs : [A]) -> [B]
  let funcs : [<T>(T) -> T] = …
  ```

## Function Declarations & Use

```
func add(x : Int, y : Int) : Int = x + y;

func applyNTimes<T>(n : Nat, x : T, f : T -> ()) {
  if (n == 0) return;
  f(x);
  applyNTimes(n-1, x, f);
}

applyNTimes<Text>(10, "Hello!", func(x) = { Debug.print(x) } );
```

* `func() { … }` short for `func() : () = { … }`
* Parametric functions
* Type instantiations may sometimes be omitted
* Anonymous functions (a.k.a. lambdas)


# Composite types

## Tuples

`(Bool, Float, Text)`

immutable, heterogeneous, fixed size

```
let tuple = (true, 1.2, "foo");
tuple.1 > 0.0;
let (_,_,t) = tuple;
```

## Options

`?Text`

is either a value of that type, or `null`

```
func foo(x : ?Text) : Text {
  switch x {
    case (null) { "No value" };
    case (?y) { "Value: " # y };
  };
};
foo(null);
foo(?"Test");
```

## Arrays (immutable)

`[Text]`

```
let days = ["Monday", "Tuesday", … ];
assert(days.len() == 7);
assert(days[1] == "Tuesday");
// days[7] will trap (fixed size)
for (d in days.values()) { Debug.print(d) };
```

## Arrays (mutable)

`[var Nat]`

```
let counters = [var 1, 2, 3];
assert(counters.len() == 3);
counters[1] := counters[1] + 1;
// counters[3] will trap (fixed size)
```

## Records

`{name : Text; points : var Int}`

```
let player = { name = "Joachim";  var points = 0 };
Debug.print(
  player.name # " has " #
  Int.toText(player.points) # " points."
);
player.points += 1;
```

## Objects

`{ get : () -> Int; add : Int -> () }`

```
object self {
  var points = 0; // private by default
  public func get() = points;
  public func add(p : Int) { points += p };
}
```

Different syntax, same type as records

## Variants

`{ #invincible; #alive : Int; #dead }`

```
type Health = { #invincible; #alive : Nat; #dead };
func takeDamage(h : Health, p : Nat) : Health {
  switch (h) {
    case (#invincible) #invincible;
    case (#alive hp) {
      if (hp > p) (#alive (hp-p)) else #dead
    };
    case (#dead) #dead;
  }
}
```

# Packages and modules

## Modules

```
// the type of base/Int.mo
module {
  toText : Int -> Text;
  abs : Int -> Nat;
  …
}
```

types and values like objects

but restricted to _static_ content (pure, no state, …)

## Module imports

```
import Debug "mo:base/Debug";
import Int "mo:base/Int";
```

`base` package provides basic features.

More libraries popping up!

# Platform features

## Actor types

Like object types, but marked as `actor`:

```
type Receiver = actor { recv : Text -> async Nat };
type Broadcast = actor {
  register : Receiver -> ();
  send : Text -> async Nat;
}
```

_sharable_ arguments and _no_ or _async_ result type.

“canister” ≈ “actor”

## sharable ≈ serializable

  - all primitive types
  - records, tuples, arrays, variants, options  
    with immutable sharable components
  - `actor` types
  - `shared` function type<br/><br/>**Not sharable:**
  - mutable things
  - local functions
  - objects (with methods)


## A complete actor

```
import Array "mo:base/Array";
actor {
  var r : [Receiver] = [];
  public func register(a : Receiver) {
    r := Array.append(r, [a]);
  };
  public func send(t : Text) : async Nat {
    var sum := 0;
    for (a in r.values()) {
      sum += await a.recv(t);
    };
    return sum;
  };
}
```

a typical canister main file

## Async/await

`async T`

asychronous future or promise

introduced by `async { … }`  
(implicit in async function declaration)

`await e`  
suspends computation pending `e`'s result

## Actor import

```
import Broadcast "ic:ABCDEF23";
actor Self {
  public func go() {
    Broadcast.register(Self);
  };
  public func recv(msg : Text) : async Nat {
    …
  }
}
```

## Principal and caller

```
actor Self {
  let myself : Principal = Principal.fromActor(Self);
  public shared(context) func hello() : async Text {
    if (context.caller == myself) {
      "Talking to yourself is the first sign of madness";
    } else {
      "Hello, nice to see you";
    };
  };
}
```

`Principal`: identity of a user or canister/actor

# Type system

## Structural

```
type Health1 = { #invincible; #alive : Nat; #dead };
type Health2 = { #invincible; #alive : Nat; #dead };

let takeDamage : (Health1, Nat) -> Health1 = …;
let h : Health2 = #invincible;
let h' = takeDamage(h, 100); // works
```

Type definitions  
do not create types,  
but name existing types

## Subtyping

`Mortal <: Health`

```
type Health = { #invincible; #alive : Nat; #dead };
type Mortal = { #alive : Nat; #dead };

let takeDamage : (Health, Nat) -> Health = …;
let h : Mortal = #alive 1000;
let h' = takeDamage(h, 100); // also works
```

`t1 <: t2`: `t1` can be used wherever `t2` is expected


## Generic types

```
type List<T> = ?{head : T; tail : List<T>};

…
let l : List<Nat> = ?{head = 0; tail = ?{head = 1 ; tail = null }};
```

# Fin

## Not covered

 * Polymorphic functions with type bounds
 * Classes
 * Error handling (`try … catch …` & `throw …`)

# Old slides

### Classes

Classes as functions returning objects:
```
 class Counter(init : Int) {
    private var state : Int = init;
    public func inc() { state += 1; };
    public func get() : Int { state; };
  }
```

Class instantiation as function call (no `new`):
```
let c = Counter(666);
c.inc();
let 667 = c.get();
```


### Generic Classes

```
class Dict< K, V > (cmp : (K,K)-> Int ) {
  add(k: K, v: V) { ... };
  find(k: K) : ? V { ... };
};
```

```
let d = Dict<Int,Text> (func (i:Int, j:Int) : Int = i - j);
d.add(1,"Alice");
let ? name = d.find(1);
```

### Language prelude

* connects internal primitives with surface syntax (types, operations)
* conversions like `intToNat32`
* side-effecting operations `debugPrintInt`
  (tie into execution environment)
* utilities like `hashInt`, `clzNat32`


# Sample App


### Implementing *Chat*

* type example
* one server actor
* multiple clients, each an instance of (actor) class Client.

### Chat Server

```
actor Server {
  private var clients : List<Client> = null;

  private shared broadcast(message : Text) {
    var next = clients;
    loop {
      switch next {
        case null { return; }
        case (?l) { l.head.send(message); next := l.tail; };
      };
    };
  };
```
```
  public func subscribe(client : Client) : async Post {
    let cs = {head = client; var tail = clients};
    clients := ?cs;
    return broadcast;
  };
};
```


### Example: The client class
<!--
 * should we remove the name and server fields? They aren't used, I believe, but somewhat illustrative.
* The fields would be  needed for unsubscribing etc, unless we return an unsubscribe capability...
 * Also, subscribe could just take send, not a whole client.

-->
```
type Server = actor { subscribe : Client -> async Post; };

actor class Client() = this {
  private var name : Text = "";
  public func start(n : Text , s : Server) {
    name := n;
    let _ = async {
       let post = await s.subscribe(this);
       post("hello from " # name);
       post("goodbye from " # name);
    }
  };
```
```
  public func send(msg : Text) {
    debugPrint(name # " received " # msg # "\n");
  };
};
```
### Example: test

test

```
let bob = Client();
let alice = Client();
let charlie = Client();

bob.start("Bob", Server);
alice.start("Alice", Server);
charlie.start("Charlie", Server);
```
output

```
[nix-shell:~/motoko/guide]$ ../src/moc -r chat.mo
charlie received hello from bob
alice received hello from bob
bob received hello from bob
charlie received goodbye from bob
alice received goodbye from bob
bob received goodbye from bob
charlie received hello from alice
alice received hello from alice
bob received hello from alice
charlie received goodbye from alice
alice received goodbye from alice
bob received goodbye from alice
charlie received hello from charlie
alice received hello from charlie
bob received hello from charlie
charlie received goodbye from charlie
alice received goodbye from charlie
bob received goodbye from charlie
```



================================================
FILE: doc/package.json
================================================
{
  "dependencies": {
    "dune": "^0.2.1"
  }
}



================================================
FILE: doc/pandoc.css
================================================

body {
    font-family: Verdana, sans-serif;
    font-size: 100%;
    line-height: 140%;

}
p {
    text-align: justify;
    hyphens: auto;
}
@media only screen {
    body{
        margin: auto;
        padding-right: 1em;
        padding-left: 1em;
        border-left: 1px solid black;
        border-right: 1px solid black;
    }
}
@media only print {
    body {
	font-size: 12pt;
    }
    #TOC {
        display: none
    }
}
@media only screen and not (min-width: 88em) {
    body {
        max-width: 44em;
    }
    #nav-toggle {
        position: fixed;
        right: 0.5em;
        top: 1em;
        width: 1em;
        height: 1em;
        background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" fill="rgb(0, 0, 0)"><rect y="0" width="100%" height="20%" rx="5%" ry="5%" /><rect y="40%" width="100%" height="20%" rx="5%" ry="5%" /><rect y="80%" width="100%" height="20%" rx="5%" ry="5%" /></svg>') center / 80% 80% no-repeat;
    }
    #TOC {
        display: none;
    }
    #TOC:target {
        display: block;
    }
}
@media only screen and (min-width: 88em) {
    body {
        max-width: 50%;

        background-image: url("dfinity.png");
        background-position: bottom 1em right 1em; /*Positioning*/
        background-repeat: no-repeat; /*Prevent showing multiple background images*/
        background-attachment: fixed;
        background-size: 20%;
    }

    #TOC {
        width: 20%;
        position: fixed;
        left: 0;
        top: 0;
        height: 100%;
        overflow: auto;
    }

}
#TOC ul {
    padding-left:1em;
}
#TOC ul {
    margin-left: 0em;
    padding-left: 1em;
}
#TOC a {
    text-decoration: none;
    color: blue;
}
#TOC a:visited {
    text-decoration: none;
    color: blue;
}
pre {
    border: 1px dotted gray;
    background-color: #ececec;
    color: #1111111;
    padding: 0.5em;
}
code {
    font-family: monospace;
}
h1 a, h2 a, h3 a, h4 a, h5 a { 
    text-decoration: none;
    color: #7a5ada; 
}
h1, h2, h3, h4, h5 { font-family: verdana;
                     font-weight: bold;
                     border-bottom: 1px dotted black;
                     color: #7a5ada; }
h1 {
        font-size: 130%;
}

h2 {
        font-size: 110%;
}

h3 {
        font-size: 95%;
}

h4 {
        font-size: 90%;
        font-style: italic;
}

h5 {
        font-size: 90%;
        font-style: italic;
}

h1.title {
        font-size: 200%;
        font-weight: bold;
        padding-top: 0.2em;
        padding-bottom: 0.2em;
        text-align: left;
        border: none;
}

dt code {
        font-weight: bold;
}
dd p {
        margin-top: 0;
}

#footer {
        padding-top: 1em;
        font-size: 70%;
        color: gray;
        text-align: center;
        }



================================================
FILE: doc/schat.mo
================================================
type List<T> = ?{head : T; var tail : List<T>};

type Post = shared Text -> ();

type Server =
  actor { subscribe : shared (actor { go : shared (Text, Server) -> ();
                                     send : shared (Text) -> ()
				   })
                      -> async Post; };

actor Server = {
  private var clients : List<Client> = null;

  private shared broadcast(message : Text) {
    var next = clients;
    loop {
      switch next {
        case null return;
        case (?l) {
          l.head.send(message);
          next := l.tail;
        };
      };
    };
  };

  subscribe(client : Client) : async Post {
    let cs = new {head = client; var tail = clients};
    clients := ?cs;
    return broadcast;
  };
};

actor class Client() = this {
  private var name : Text = "";
  go(n : Text , s : Server) {
    name := n;
    let _ = async {
       let post = await s.subscribe(this);
       post("hello from " # name);
       post("goodbye from " # name);
    }
  };
  send(msg : Text) {
    debugPrint(name # " received " # msg # "\n");
  };
};


let bob = Client();
let alice = Client();
let charlie = Client();

bob.go("bob", Server);
alice.go("alice", Server);
charlie.go("charlie", Server);



================================================
FILE: doc/attic/0.11.0-migration-guide.md
================================================
# Motoko v0.11.0: Safety feature migration guide

Motoko v0.11.0 and newer introduces a new safety feature that could cause breaking changes to existing code.

In previous Motoko versions, third-party library functions could make calls to sensitive functions such as `ExperimentalCycles.add(...)` and `Timer.setTimer(...)` without providing any indication to the caller that sensitive system functionality was being used.

In Motoko 0.11.0 and newer, the type system is used to detect and prevent this scenario while still allowing developers to grant access to sensitive functions.

## Motoko v0.11.0 changes

Motoko uses a simple capability-based type system which selectively enables language constructs depending on their context. One example is only `async` expressions can contain `await` expressions, or only some asynchronous contexts can call shared functions.

In Motoko v0.11.0 and newer, this capability system is expanded to restrict calls to functions including `Timer.setTimer` and `ExperimentalCycles.add`. To accomplish this, Motoko introduces and uses the pseudo-type parameter `system` and corresponding pseudo-type argument (also `system`) for both functions and classes.

Another change in v0.11.0 and newer is a revision of `ExperimentalCycles.add`, whose type has been changed from `Nat -> ()` to `<system>Nat -> ()`. This change reflects the additional  `system` capability requirement using the type parameter `<system>`.

:::info
The `system` type parameter must be the first parameter of any function, class constructor or function type, e.g. `<system, T, U>` is valid but `<T, system, U>` is not.
:::

## Migrations for existing workflows

User-defined functions must now declare an explicit system pseudo-type parameter if they require system capabilities. If a caller wants to grant system capabilities to a callee, the caller must already have system capabilities either (implicitly) by virtue of the callsite's program context or (explicitly) because the callsite resides within a function or class that itself declares the new `system`  type parameter.

For example, in previous Motoko versions the following could be used:

```motoko no-repl
  func splitCycles() {
    let amount = ExperimentalCycles.balance() / 2;
    ExperimentalCycles.add(amount); // new error
  };
```

This code will now throw a compiler error such as:

```
`system` capability required, but not available
(need an enclosing async expression or function body or explicit `system` type parameter)(M0197)
```

For Motoko v0.11.0 and newer, the previous code should be rewritten to include the system type parameter:

```motoko no-repl
 func splitCycles<system>() {
    let amount = ExperimentalCycles.balance() / 2;
    ExperimentalCycles.add(amount); // warning
  };
```

This code will include a warning to reflect that `ExperimentalCycles.add` is implicitly using system capability:

```
this function call implicitly requires `system` capability and may perform undesired actions (please review the call and provide a type instantiation `<system>` to suppress this warning)(M0195)
```

This warning can be silenced by adding the pseudo-type argument `system` at the call-site:

```motoko no-repl
  func splitCycles<system>() {
    let amount = ExperimentalCycles.balance() / 2;
    ExperimentalCycles.add<system>(amount); // no warning or error
  }
```

Developers whose code has proper capability related errors that prevent compilation will need to refactor their code to explicitly pass down the system capabilities using additional type parameters and arguments.

## System capability syntax limitations

System capability is available within the following contexts:

- Within the body of an `actor` expression or `actor` class.
- Within the body of a (non- `query`) `shared` function, asynchronous function, `async` expression or `async*` expression.
- Within the body of a local (i.e. not `shared`) function or class that is declared with `system` pseudo-type parameter.
- Within the system functions `preupgrade` and `postupgrade`.

No other context provides system capabilities, including the bodies of query and composite query methods.





================================================
FILE: doc/attic/about-this-guide.md
================================================
# Motoko Programming Language Guide

## About this guide

The *Motoko Programming Language Guide* introduces key features of the general-purpose Motoko programming language and provides examples and reference information to help you learn the nuances of the language and the practical implications of how to apply it.

The Motoko programming language is optimized for developing programs that run on the Internet Computer blockchain network and to work with the [IC SDK](https://internetcomputer.org/docs/current/developer-docs/setup/install). You could, in principle, also write programs using Motoko for more traditional platforms and to run in other contexts, though support for this is currently best-effort and incomplete. This guide attempts to strike a balance between highlighting features that are uniquely suited to running on the Internet Computer and features that are generally-applicable or well-suited for programs running on all targets.

## Intended audience

This guide provides reference information and examples for programmers who want to explore or plan to use the Motoko programming language. Most of the information in this guide is applicable independent of whether you are developing programs to run on the Internet Computer or working with the [IC SDK](https://internetcomputer.org/docs/current/developer-docs/setup/install).

The guide assumes you are familiar with basic programming principles and terminology and have at least some experience writing programs in a high-level programming language such as C++ or Rust, or have practical experience working with a scripting language such as JavaScript or TypeScript. In addition, Motoko incorporates some aspects of functional programming, so you might find some knowledge of functional programming design principles helpful in learning to use Motoko.

Although this guide is intended to help readers from different backgrounds understand the basic design principles and semantics of the Motoko, you should keep in mind that the language implementation and the documentation are also continuing to evolve.

## Using this guide

To provide a framework for learning Motoko, you might want to start by reviewing [Engineering values and goals](#engineering-values-and-goals). The [Engineering values and goals](#engineering-values-and-goals) describe the core design considerations for the development and evolution of the Motoko programming language.

With those considerations in mind, you can start to explore fundamental concepts, including the role of types and type annotations, in simple code examples and small programs.

Once you are familiar with the basic concepts and terminology, later sections introduce programs that compute in more interesting ways, including function abstractions, user-defined type definitions, user-defined actors, and asynchronous communication.

As you begin using Motoko to write your own programs, you can return to this guide for reference information and examples.

Most of the code examples in this guide are interactive: you can live edit the example, interpret the code in the browser and see the result. The interpreter is provided for education purposes. While most of the language features are supported in the interpreter, they are not exactly the same as the real compiler. For example, you may get a stack overflow for a medium-size input, while the real compiler handles the input just fine. Some of the system features are not fully supported, such as cycles, canister imports and state-mutating query calls.

## Documentation conventions

The following conventions are used in this guide:

-   `Fixed-width` font is used for sample code, program names, program output, file names, and commands that you type at the command line.

-   **Bold** text is used to emphasize commands, buttons, or user interface text, and to introduce new terms.

-   *Italics* are used for book titles and to emphasize specific words or terms.

-   The CAUTION style is used to indicate content that is missing or incomplete.

-   The WARNING style is used to indicate where content is outdated or potentially inaccurate.

-   The NOTE style is used to indicate content that describes a feature that is not yet supported but is planned for a future release.

## Engineering values and goals

The engineering effort behind the design and implementation of Motoko is driven by a core set of values and goals. The DFINITY engineering organization uses these values and goals to define and prioritize the language features and enhancements to add and improve as part of *ongoing* language development.

For transparency into the principles that guide the engineering effort, the engineering organization has identified the following sets of core values and secondary values for driving the direction of the Motoko programming language.

### Core values

The following guiding principles represent the core values of the engineering organization in prioritized order:

1.  Seamless integration with the Internet Computer blockchain network to ensure that Motoko provides full language support for the actor-based model, asynchronous messaging, data persistence, interface description language interoperability, and other features.

2.  Ergonomics to ensure that Motoko embraces familiarity, simplicity, clarity, explicitness, and other human factors.

3.  Formal correctness to ensure that Motoko maintains state isolation, a sound type system and type safety, precision, pattern matching, appropriate defaults, and coding best-practices.

### Secondary values

The following principles represent the secondary values of the engineering organization that are deemed important but not primary driving factors:

1.  Expressiveness, so that Motoko provides first-class functions, polymorphism, pattern matching, and more as the language evolves.

2.  Performance, so that Motoko provides reasonably fast operation initially and continues to improves as the language evolves.

3.  Readiness, so the Motoko comes with "batteries included" in the form of libraries and examples and out-of-the-box integration with the [IC SDK](https://internetcomputer.org/docs/current/developer-docs/setup/install).

### Non-goals

As a counterpoint to the core values and goals, the engineering organization also identified the following as "non-goals" that are outside of the scope of the engineering effort:

1.  Having a more advanced type system, with cutting-edge features.

2.  Simplicity over functionality in design or implementation (the "Worse is Better" approach).

3.  Interoperability or support for running Motoko programs on blockchains other than the Internet Computer.

## Finding more information

For information about using Motoko with the IC SDK for creating and managing canisters, see the [Developer Resources](https://internetcomputer.org/developers).

For background information on various topics relevant to the design, use, or deployment of Motoko services, or the language’s design itself, consider the following resources as a starting point:

### WebAssembly

-   [WebAssembly home page](https://webassembly.org/).

-   [WebAssembly overview video (youtube)](https://www.youtube.com/watch?v=fvkIQfRZ-Y0).

### Modern type systems

-   [Practical Foundations for Programming Languages](http://www.cs.cmu.edu/~rwh/pfpl/) by Robert Harper. Cambridge University Press, 2016.

-   [Types and Programming Languages](https://www.cis.upenn.edu/~bcpierce/tapl/) by Benjamin C. Pierce. The MIT Press.

## Getting additional support

If you are looking for more information or technical support, the DFINITY website provides quick access to frequently-asked questions, technical articles, developer updates, and other resources. From the website, you can search knowledge base articles, open and view support cases, sign up for the newsletter, read the latest blog posts, view how-to videos, download software updates, or exchange ideas with members of the community.

In addition to the resources available on the website, you can connect with DFINITY or other developers using social media or by visiting the DFINITY Community Forum on Discourse and joining the conversation.



================================================
FILE: doc/attic/advanced-discussion.md
================================================
# Advanced discussion topics

<!--
To do:

-[ ] discuss: no race conditions

-[ ] discuss: no null-pointer exceptions

-[ ] discuss: Subtypes and the `Null` type

-[ ] discuss: Types are structural
-->



================================================
FILE: doc/attic/extrastuff.md
================================================
# Why develop applications to run on the internet computer?

Motoko provides:

-   A high-level language for programming applications to run on the Internet Computer blockchain network.

-   A simple design that uses familiar syntax that is easy for programmers to learn.

-   An **actor-based** programming model optimized for efficient message handling.

-   An interpreter and compiler that you can use to test and compile the WebAssembly code for autonomous applications.

-   Support for features not-yet implemented that anticipate future extensions and improvement to WebAssembly.

# Why a new language?

The Internet Computer provides a blockchain network that can support programs written in different languages. The only requirement is that the program must support compilation to WebAssembly code. WebAssembly (commonly-abbreviated as Wasm) is a low-level computer instruction format for virtual machines. Because WebAssembly code is designed to provide portable low-level instructions that enable applications to be deployed on many platforms such as the web, it is a natural fit for deploying applications that are intended to run on the Internet Computer. However, most of the higher-level languages - like C, C, and Rust - that support compiling to WebAssembly are either too unsafe (for example, C or C) or too complex (for example, Rust) for developers who want to deliver secure applications without a long learning curve.

To address the need for correctness without complexity, DFINITY has designed its own **Motoko** programming language. **Motoko** provides a simple and expressive alternative to other programming languages that is easy to learn whether you are a new or experienced programmer.

# Support for other languages

WebAssembly is language-agnostic. It does not require a high-level type system for language inter-operation. Although Motoko is specifically designed to compile to WebAssembly and make it easy to write programs to run on the internet computer, it is just one of many languages you can eventually use to develop applications for the Internet Computer blockchain network.

To support multiple languages and typed, cross-language communication, DFINITY also provides an **Interface Definition Language** (IDL). The Motoko compiler automates the production and consumption of IDL files using the type signatures in Motoko programs and the structure of imported IDL interfaces.

For information about the **Interface Definition Language** interfaces, see XXX.



================================================
FILE: doc/attic/overview.md
================================================
# Concise overview of Motoko

This is terse, slide-like introduction to Motoko and its features.

(For a gentler introduction, visit the other sections on this site.)

## Motivation and Goals

A simple, useful language for the Internet Computer (IC)

-   Familiar syntax

-   Safe by default

-   Incorporating **actor** model for canister smart contracts

-   Seamless integration of Internet Computer features

-   Making most of present and future WebAssembly

## Key Design Points

-   Object-oriented, functional & imperative

-   Objects as records of functions

-   `async`/`await` for sequential programming of asynchronous messaging

-   Structural typing with simple generics and subtyping

-   Safe arithmetic (both unbounded and checked)

-   Non-nullable types by default

-   Garbage collected (no manual memory management)

-   JavaScript-like syntax but statically typed & sane

Inspirations: Java, JavaScript, C#, Swift, Pony, ML, Haskell

## Semantics

-   call-by-value (like Java, C, JS, ML; unlike Haskell)

-   declarations are locally mutually recursive

-   parametric, bounded polymorphism

-   subtyping as zero-cost subsumption, not coercion

-   no dynamic casts

-   no inheritance

## Implementation(s)

-   implemented in OCaml (leverages `wasm` libary)

-   simple reference interpreter

-   less simple compiler to WebAssembly

    -   multipass with typed IR in each pass.

    -   uniform representation, unboxed arithmetic

    -   copying GC, compacting GC, or generational GC
        (select which with compiler flag)

    -   GC invoked after messages (for now)

-   polymorphism by erasure

# The language

## Expressions

-   Identifiers:
    `x`, `foo_bar`, `test123`, `List`, `Map`

-   Parentheses `( … )` for grouping

-   Braces `{ … }` for scoping (and records)

-   `;` for sequencing

-   Type annotations (to help type inference):
    `(42 : Int)`
    (zero cost)

## Libraries

``` motoko name=impDebugInt
import Debug "mo:base/Debug";
import Int "mo:base/Int";
```

(`import MyLib "src/MyLib"` imports a library from the local file system.)

Specific bindings can be imported from the module using object patterns

``` motoko
import { push; nil } = "mo:base/List";
```

## Libraries continued

``` motoko
import Debug "mo:base/Debug";
import Int "mo:base/Int";
import Trie "mo:base/Trie";

type Users = Trie.Trie<Text, Nat>; // reference types

Debug.print(Int.toText(7)); // reference functions/values
```

## Blocks and declarations

``` motoko include=impDebugInt
type Delta = Nat;
func print() {
  Debug.print(Int.toText(counter));
};
let d : Delta = 42;
var counter = 1;
counter := counter + d;
print();
```

-   Semicolon after each declaration!

-   Mutually recursive

-   Mutable variables marked explicitly

## Control flow

The usual suspects…

-   `do { … }`

-   `if b …`

-   `if b … else …`

-   `switch e { case pat1 e1; …; case _ en }`

-   `while b …`

-   `loop …`

-   `loop …  while b`

-   `for (pat in e) …`

-   `return`, `return e`

-   `label l e`, `break l e`

-   `do ? { … e! … }`

-   `async e`, `await e` *(restricted)*

-   `throw`, `try … catch x { … }` *(restricted)*

# Primitive types

## Unbounded integers

`Int`

`{ …​, -2, 1, 0, 1, 2, …​ }`

Inferred by default for negative literals.

Literals: `13`, `0xf4`, `-20`, `+1`, `1_000_000`

## Unbounded naturals

[`Nat`](https://internetcomputer.org/docs/motoko/base/Nat.md)

`{ 0, 1, 2, …​ }`

Non-negative, trap on underflow.

Inferred by default for non-negative literals

Literals: `13`, `0xf4`, `1_000_000`

`Nat <: Int`

[`Nat`](https://internetcomputer.org/docs/motoko/base/Nat.md) is a *subtype* of `Int`

(you can supply a [`Nat`](https://internetcomputer.org/docs/motoko/base/Nat.md) wherever an `Int` is expected)

## Bounded numbers (trapping)

`Nat8`, `Nat16`, `Nat32`, `Nat64`, `Int8`, `Int16`, `Int32`, `Int64`

Trap on over- and underflow; wrap-around and bit-manipulating operations available separately

Needs type annotations (somewhere)

Literals: `13`, `0xf4`, `-20`, `1_000_000`

## Floating point numbers

`Float`

IEEE 754 double precision (64 bit) semantics, normalized NaN

Inferred for fractional literals

Literals: 0, -10, `2.71`, `-0.3e+15`, `3.141_592_653_589_793_12`

## Numeric operations

No surprises here

`- x`
`a + b`
`a % b`
`a & b`
`a << b`
…

`a +% b, a -% b, …` for wrapping, modular arithmetic (where appropriate)

## Characters and Text

`Char`, `Text`

Unicode! Character = Unicode scalar value; no random access on text

-   `'x'`, `'\u{6a}'`, `'☃'`,

-   `"boo"`, `"foo \u{62}ar ☃"`

-   `"Concat" # "enation"`

## Booleans

`Bool`

Literals: `true`, `false`

`a or b`
`a and b`
`not b`
`if (b) e1 else e2`

# Functions

## Function types

-   Simple functions:

    ``` motoko no-repl
    Int.toText : Int -> Text
    ```

-   multiple arguments and return values

    ``` motoko no-repl
    divRem : (Int, Int) -> (Int, Int)
    ```

-   can be generic/polymorphic

    ``` motoko no-repl
    Option.unwrapOr : <T>(?T, default : T) -> T
    ```

-   first-class (can be passed around, stored)

    ``` motoko no-repl
    map : <A, B>(f : A -> B, xs : [A]) -> [B]
    let funcs : [<T>(T) -> T] = …
    ```

## Function Declarations & Use

``` motoko include=impDebugInt
func add(x : Int, y : Int) : Int = x + y;

func applyNTimes<T>(n : Int, x : T, f : T -> ()) {
  if (n <= 0) return;
  f(x);
  applyNTimes(n-1, x, f);
};

applyNTimes<Text>(3, "Hello!", func(x) { Debug.print(x) } );
```

-   `func() { … }` short for `func() : () = { … }`

-   Parametric functions

-   Type instantiations may sometimes be omitted

-   Anonymous functions (a.k.a. lambdas)

# Composite types

## Tuples

`(Bool, Float, Text)`

immutable, heterogeneous, fixed size

``` motoko name=tuple
let tuple = (true or false, 0.6 * 2.0, "foo" # "bar");
```

``` motoko include=tuple
tuple.1;
```

``` motoko include=tuple
let (_,_,t) = tuple;
t
```

## Options

`?Text`

is either a value of that type, e.g. `?"hello"`, or `null`.

``` motoko name=display
func display(x : ?Text) : Text {
  switch x {
    case (null) { "No value" };
    case (?y) { "Value: " # y };
  };
};
```

``` motoko include=display
(display(null), display(?"Test"))
```

## Option blocks

Switching on every option value can be inconvenient …

The *option block*, `do ? { … }`, allow you to safely access option values with a postfix *null break* `!` expression.

Within `do ? { … }`, which returns an option, the expression `e!` immediately exits the block with `null` when the value of option `e` is `null` or continues with the option’s contents.

``` motoko
func add(x : ?Nat, y: ?Nat) : ?Nat {
  do ? { x! + y! };
};

(add(null, null), add (?1,null), add (?1,?2), add (null,?2));
```

## Arrays (immutable)

`[Text]`

``` motoko include=impDebugInt
let days = [ "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun" ];

assert(days.size() == 7);

assert(days[1] == "Tue");

// days[7] will trap (fixed size)

for (d in days.values()) { Debug.print(d) };
```

## Arrays (mutable)

`[var Nat]`

``` motoko
let counters = [var 1, 2, 3];

assert(counters.size() == 3);

counters[1] := counters[1] + 1;

// counters[3] will trap (fixed size)

counters;
```

## Records

`{first : Text; last : Text; salary : var Nat}`

``` motoko include=impDebugInt
let employee = {first = "John"; last = "Doe"; var salary = 81_932};

Debug.print(
  employee.first # " " # employee.last # " earns " #
    Int.toText(employee.salary) # " pounds."
);

employee.salary += 79_496;

employee;
```

## Objects

`{first : Text; last : Text; get : () → Nat; add : Nat → ()}`

``` motoko
object self {
  public let first = "John";
  public let last = "Doe";
  var salary : Nat = 81_932; // private by default
  public func get() : Nat = salary;
  public func add(bump : Nat) { salary += bump };
}
```

## Classes

``` motoko
class Employee(fst : Text, lst : Text) {
  public let first = fst;
  public let last = lst;
  var salary : Nat = 0;
  public func get() : Nat = salary;
  public func add(bump : Nat) { salary += bump };
}
```

Classes are factories for constructing objects.
A class introduces a type and a function (for constructing instances).

Just sugar for:

``` motoko no-repl
type Employee = {first : Text; last : Text; get : () -> Nat; add : Nat -> ()};

func Employee(fst : Text, lst : Text) : Employee = object { … }
```

## Variants

`{#sun; #mon; #tue; #wed; #thu; #fri; #sat}`

``` motoko
type Day = {#sun; #mon; #tue; #wed; #thu; #fri; #sat};

func toText(d : Day) : Text {
  switch d {
     case (#sun) "Sunday";
     case (#mon) "Monday";
     case (#tue) "Tuesday";
     case (#wed) "Wednesday";
     case (#thu) "Thursday";
     case (#fri) "Friday";
     case (#sat) "Saturday";
   };
};

func sort(d : Day) : { #weekDay; #weekEnd } {
  switch d {
    case (#sun or #sat) #weekEnd;  // or pattern
    case _ #weekDay;  // wildcard pattern
  };
};
```

## Recursive Types

``` motoko name=Lists
type List = {
  #item : {head : Text; tail : List}; // variant with payload!
  #empty                     // ^^^^ recursion!
};

func reverse(l : List) : List {
  func rev(l : List, r : List) : List {
    switch l {
      case (#empty) { r };
      case (#item { head; tail }) { // nested patterns
        rev(tail, #item {head; tail = r})
      }
    }
  };
  rev(l, #empty);
};

let l = reverse(#item {head = "A"; tail = #item {head = "B"; tail = #empty}});
```

## Generic types

``` motoko
type List<T> = {
  #item : {head : T; tail : List<T>};
  #empty
};

func reverse<T>(l : List<T>) : List<T> {
  func rev(l : List<T>, r : List<T>) : List<T> {
    switch l {
      case (#empty) { r };
      case (#item { head; tail }) { // a nested pattern
        rev(tail, #item {head; tail = r})
      }
    }
  };
  rev(l, #empty);
};

let s : List<Text> =
  reverse(#item {head = "A"; tail = #item {head = "B"; tail = #empty}});

let ns : List<Nat> =
  reverse(#item {head = 0; tail = #item {head = 1; tail = #empty}})
```

# Packages and modules

## Modules

``` motoko no-repl
// the type of base/Int.mo
module {
  type Int = Prim.Types.Int;
  toText : Int -> Text;
  abs : Int -> Nat;
  // ...
}
```

modules contain named types and values (like objects),
but are restricted to *static* content (pure, no state, …)

## Module imports

``` motoko no-repl
import Debug "mo:base/Debug";  // import from package
import Int "mo:base/Int";
import MyLib "lib/MyLib";  // import from local file MyLib.mo
```

`base` package provides basic features as separate modules.

More libraries popping up!

`MyLib.mo` *must* contain a module or actor class, eg:

``` motoko no-repl
module {
  public type List<T> = …;

  public func reverse<T>(l : List<T>) : List<T> { … };
}
```

# Platform features

## Actor types

Like object types, but marked as `actor`:

``` motoko name=actorTypes
type Broadcast = actor {
  register : Receiver -> ();
  send : Text -> async Nat;
};

type Receiver = actor {
  recv : query Text -> async Nat
};
```

*sharable* arguments and *no* or *async* result type.

-   `register` is a *oneway* IC method (unawaitable).

-   `send` is an IC *update* method

-   `recv` is IC *query* method

IC canister with Candid interface ≈ Motoko actor

## sharable ≈ serializable

**Sharable:**

-   all primitive types

-   records, tuples, arrays, variants, options
    with immutable sharable components

-   `actor` types

-   `shared` function type

**Not sharable:**

-   mutable things

-   local functions

-   objects (with methods)

## A complete actor

``` motoko
import Array "mo:base/Array";

actor Broadcast {
  type Receiver = actor {recv : query Text -> async Nat};

  var r : [Receiver] = [];

  public func register(a : Receiver) {
    r := Array.append(r, [a]);
  };

  public func send(t : Text) : async Nat {
    var sum = 0;
    for (a in r.values()) {
      sum += await a.recv(t);
    };
    return sum;
  };
}
```

a typical actor/canister main file

## Async/await

`async T`

asychronous future or promise

introduced by `async { … }`
(implicit in async function declaration)

`await e`
suspends computation pending `e`’s result:
if the result is a value, continues with that value,
if the result is an `Error`, `throw`s the error.

``` motoko no-repl
  public func send(t : Text) : async Nat {
    var sum = 0;
    for (a in r.values()) {
      sum += await a.recv(t); // may return Nat or `throw` error
    };
    return sum;
  };
```

(Errors can be handled using `try … catch …`)

## Concurrency Hazards

Functions that `await` are *not* atomic.
Suspension introduces *concurrency hazards*.

A bad implementation of `send`:

``` motoko no-repl
  var sum = 0; // shared state!
  public func send(t : Text) : async Nat {
    sum := 0;
    for (a in r.values()) {
      sum += await a.recv(t);
    };
    return sum;
  };
```

(Concurrent `send`s will share and clobber `sum`.)

Beware of race conditions!

## Actor import

``` motoko
import Broadcast "canister:Broadcast";
/* or
import Broadcast "ic:r7inp-6aaaa-aaaaa-aaabq-cai";
*/
actor Self {

  var count = 0;

  public func go() {
    Broadcast.register(Self);
  };

  public query func recv(msg : Text) : async Nat {
    return count;
  }
}
```

(assumes there is a Candid file describing the interface of the import)

## A Candid interface file

`Broadcast`'s Candid file (produced by `moc --idl Broadcast.mo` compiler).

Broadcast.did:

``` candid
type Receiver =
 service {
   recv: (text) -> (nat) query;
 };
service : {
  register: (Receiver) -> () oneway;
  send: (text) -> (nat);
}
```

A language independent interface definition.

Could just as easily describe a Rust implementation of `Broadcast`.

## Principal and caller

``` motoko
import Principal "mo:base/Principal";

actor Self {

  public shared(context) func hello() : async Text {
    let myself : Principal = Principal.fromActor(Self);
    if (context.caller == myself) {
      "Talking to yourself is the first sign of madness";
    } else {
      "Hello, nice to see you";
    };
  };

}
```

## Errors

``` motoko no-repl
import Principal "mo:base/Principal";
import Error "mo:base/Error";

actor Self {

  public shared(context) func hello() : async Text {
    let myself : Principal = Principal.fromActor(Self);
    if (context.caller == myself) {
      throw Error.reject("Talking to yourself is the first sign of madness");
    } else {
      "Hello, nice to see you";
    };
  };

};

async {
  let t = try Self.hello() catch (e) { Error.message(e); }
};
```

Similar to exceptions in other languages,
but *only* available in async contexts, e.g. shared functions; async blocks

## Stable variables

If we upgrade the `Broadcast` actor, all current registrations are lost.
To preserve them, declare the state variable `r` as `stable`.

``` motoko no-repl
import Array "mo:base/Array";

actor Broadcast {

  type Receiver = actor {recv : query Text -> async Nat};

  stable var r : [Receiver] = []; // declare r `stable`

  public func register(a : Receiver) { … }
  public func send(t : Text) : async Nat { … }

  // optional pre-upgrade action
  system func preupgrade() { Debug.print("saving receivers"); }

  // optional post-upgrade action
  system func postupgrade() {  Debug.print("restoring receivers"); }
}
```

stable variables must have *stable* types (see manual)
`system` hooks can’t send messages

# Type system

## Structural

``` motoko include=Lists
/*
type List = {
  #item : {head : Text; tail : List};
  #empty
};

func reverse(l : List) : List { //... };
*/
type Stack = {
   #empty;
   #item : {tail : Stack; head : Text};
};

let stack : Stack = #empty;

let revStack = reverse(stack); // works though reverse defined on List (not Stack)
```

Type definitions
do not create types,
but name existing types

Despite their different names, `Stack` and `List` are equivalent types.

## Subtyping (Variants)

`WeekDay <: Day`

``` motoko
type WeekDay = {#mon; #tue; #wed; #thu; #fri};

type Day = {#sun; #mon; #tue; #wed; #thu; #fri; #sat};

func toText(d : Day) : Text {
  switch d
   { case (#sun) "Sunday";
     case (#mon) "Monday";
     //...
   };
};

let mon : WeekDay = #mon;
let t = toText(mon); // also works, since WeekDay <: Day
```

`t1 <: t2`: `t1` can be used wherever `t2` is expected

`Employee <: Person`

``` motoko
type Employee = {first : Text; last : Text; var salary : Nat};
type Person = {first : Text; last : Text};

func toText(p : Person) : Text {
  p.last # "," # p.first;
};

let employee : Employee =
  { first = "John"; last = "Doe"; var salary = 161_401};

let t = toText(employee); // also works, since Employee <: Person
```

# Fin

## Not covered

-   Polymorphic functions with type bounds

-   User defined iterator objects, supporting `for` loops.

-   Actor classes

-   `debug_show` for conversion of almost any value to text.

-   `debug e` expressions for debug-only compilation

-   `do ? { … e! …  }` blocks for handling/propagating option values.

-   `assert e` expressions for conditional traps

-   tools:

    -   `mo_doc` (generates doc from doc comments),

    -   `vessel` (package manager)

<!--
== Old slides

=== Classes

Classes as functions returning objects:

....
 class Counter(init : Int) {
    private var state : Int = init;
    public func inc() { state += 1; };
    public func get() : Int { state; };
  }
....

Class instantiation as function call (no `new`):

....
let c = Counter(666);
c.inc();
let 667 = c.get();
....

=== Generic Classes

....
class Dict< K, V > (cmp : (K,K)-> Int ) {
  add(k: K, v: V) { ... };
  find(k: K) : ? V { ... };
};
....

....
let d = Dict<Int,Text> (func (i:Int, j:Int) : Int = i - j);
d.add(1,"Alice");
let ? name = d.find(1);
....

=== Language prelude

* connects internal primitives with surface syntax (types, operations)
* conversions like `intToNat32`
* side-effecting operations `debugPrintInt` (tie into execution
environment)
* utilities like `hashInt`, `clzNat32`

== Sample App

=== Implementing _Chat_

* type example
* one server actor
* multiple clients, each an instance of (actor) class Client.

=== Chat Server

....
actor Server {
  private var clients : List<Client> = null;

  private shared broadcast(message : Text) {
    var next = clients;
    loop {
      switch next {
        case null { return; }
        case (?l) { l.head.send(message); next := l.tail; };
      };
    };
  };
....

....
  public func subscribe(client : Client) : async Post {
    let cs = {head = client; var tail = clients};
    clients := ?cs;
    return broadcast;
  };
};
....

=== Example: The client class

....
type Server = actor {subscribe : Client -> async Post};

actor class Client() = this {
  private var name : Text = "";
  public func start(n : Text , s : Server) {
    name := n;
    let _ = async {
       let post = await s.subscribe(this);
       post("hello from " # name);
       post("goodbye from " # name);
    }
  };
....

....
  public func send(msg : Text) {
    debugPrint(name # " received " # msg # "\n");
  };
};
....

=== Example: test

test

....
let bob = Client();
let alice = Client();
let charlie = Client();

bob.start("Bob", Server);
alice.start("Alice", Server);
charlie.start("Charlie", Server);
....

output

....
[nix-shell:~/motoko/guide]$ ../src/moc -r chat.mo
charlie received hello from bob
alice received hello from bob
bob received hello from bob
charlie received goodbye from bob
alice received goodbye from bob
bob received goodbye from bob
charlie received hello from alice
alice received hello from alice
bob received hello from alice
charlie received goodbye from alice
alice received goodbye from alice
bob received goodbye from alice
charlie received hello from charlie
alice received hello from charlie
bob received hello from charlie
charlie received goodbye from charlie
alice received goodbye from charlie
bob received goodbye from charlie
....
-->



================================================
FILE: doc/docusaurus/README.md
================================================
# Website

This website is built using [Docusaurus 2](https://docusaurus.io/), a modern static website generator.

### Installation

```
$ yarn
```

### Local Development

```
$ yarn start
```

This command starts a local development server and opens up a browser window. Most changes are reflected live without having to restart the server.

### Build

```
$ yarn build
```

This command generates static content into the `build` directory and can be served using any static contents hosting service.

### Deployment

Using SSH:

```
$ USE_SSH=true yarn deploy
```

Not using SSH:

```
$ GIT_USER=<Your GitHub username> yarn deploy
```

If you are using GitHub pages for hosting, this command is a convenient way to build the website and push to the `gh-pages` branch.



================================================
FILE: doc/docusaurus/babel.config.js
================================================
module.exports = {
  presets: [require.resolve('@docusaurus/core/lib/babel/preset')],
};



================================================
FILE: doc/docusaurus/docusaurus.config.js
================================================
// @ts-check
// Note: type annotations allow type checking and IDEs autocompletion

const lightCodeTheme = require('prism-react-renderer/themes/github');
const darkCodeTheme = require('prism-react-renderer/themes/dracula');

/** @type {import('@docusaurus/types').Config} */
const config = {
  title: 'Motoko Doc Preview',
  tagline: '(a work in progress)',
  url: 'https://your-docusaurus-test-site.com',
  baseUrl: '/',
  onBrokenLinks: 'throw',
  onBrokenMarkdownLinks: 'warn',
  favicon: 'img/motoko.png',

  // GitHub pages deployment config.
  // If you aren't using GitHub pages, you don't need these.
  organizationName: 'dfinity', // Usually your GitHub org/user name.
  projectName: 'motoko', // Usually your repo name.

  plugins: [
    'docusaurus-plugin-sass'
  ],

  // Even if you don't use internalization, you can use this field to set useful
  // metadata like html lang. For example, if your site is Chinese, you may want
  // to replace "en" with "zh-Hans".
  i18n: {
    defaultLocale: 'en',
    locales: ['en'],
  },

  presets: [
    [
      'classic',
      /** @type {import('@docusaurus/preset-classic').Options} */
      ({
          docs: {
          path: "../md",
          sidebarPath: require.resolve('./sidebars.js'),
          remarkPlugins: [require("remark-code-import")],
          // Please change this to your repo.
          // Remove this to remove the "edit this page" links.
          editUrl:
            'https://github.com/dfinity/motoko/tree/master/doc/md/',
        },
        blog: false,
        theme: {
          customCss: require.resolve('./src/css/custom.scss'),
        },
      }),
    ],
  ],

  themeConfig:
    /** @type {import('@docusaurus/preset-classic').ThemeConfig} */
    ({
      navbar: {
        title: 'Motoko',
        logo: {
          alt: 'My Site Logo',
          src: 'img/motoko.png',
        },
        items: [
          {
            type: 'doc',
            docId: 'base/index',
            position: 'left',
            label: 'Base',
          },
          {
            type: 'doc',
            docId: 'core/index',
            position: 'left',
            label: 'Core',
          },
          {
            href: 'https://github.com/dfinity/motoko',
            label: 'GitHub',
            position: 'right',
          },
        ],
      },
      footer: {
        style: 'dark',
        links: [
          {
            title: 'Docs',
            items: [
              {
                label: 'Motoko',
                to: '/docs/attic/motoko',
              },
              {
                label: 'Base',
                to: '/docs/base/index',
              },
            ],
          }
        ],
        copyright: `Copyright © ${new Date().getFullYear()} My Project, Inc. Built with Docusaurus.`,
      },
      prism: {
        theme: lightCodeTheme,
        darkTheme: darkCodeTheme,
      },
    }),
  clientModules: [require.resolve("./static/load_moc.ts")],
};

module.exports = config;



================================================
FILE: doc/docusaurus/package.json
================================================
{
  "name": "docusaurus",
  "version": "0.0.0",
  "private": true,
  "scripts": {
    "docusaurus": "docusaurus",
    "start": "docusaurus start",
    "build": "docusaurus build",
    "swizzle": "docusaurus swizzle",
    "deploy": "docusaurus deploy",
    "clear": "docusaurus clear",
    "serve": "docusaurus serve",
    "write-translations": "docusaurus write-translations",
    "write-heading-ids": "docusaurus write-heading-ids"
  },
  "dependencies": {
    "@docusaurus/core": "3.8.1",
    "@docusaurus/preset-classic": "3.8.1",
    "@docusaurus/theme-live-codeblock": "^3.8.1",
    "@mdx-js/react": "^1.6.22",
    "clsx": "^1.2.0",
    "docusaurus-plugin-sass": "^0.2.2",
    "highlight.js": "^11.5.1",
    "prism-react-renderer": "^1.3.5",
    "react": "^16.14.0",
    "react-chartjs-2": "^4.1.0",
    "react-codejar": "^1.1.2",
    "react-dom": "^16.14.0",
    "remark-code-import": "^0.4.0"
  },
  "devDependencies": {
    "@docusaurus/module-type-aliases": "2.0.0-beta.22"
  },
  "browserslist": {
    "production": [
      ">0.5%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "engines": {
    "node": ">=16.14"
  },
  "description": "This website is built using [Docusaurus 2](https://docusaurus.io/), a modern static website generator.",
  "main": "babel.config.js",
  "directories": {
    "doc": "docs"
  },
  "author": "",
  "license": "ISC"
}



================================================
FILE: doc/docusaurus/sidebars.js
================================================
/**
 * Creating a sidebar enables you to:
 - create an ordered group of docs
 - render a sidebar for each doc of that group
 - provide next/previous navigation

 The sidebars can be generated from the filesystem, or explicitly defined here.

 Create as many sidebars as you want.
 */

// @ts-check

/** @type {import('@docusaurus/plugin-content-docs').SidebarsConfig} */
const sidebars = {
  // By default, Docusaurus generates a sidebar from the docs folder structure
  tutorialSidebar: [{type: 'autogenerated', dirName: '.'}],

  // But you can create a sidebar manually
  /*
  tutorialSidebar: [
    {
      type: 'category',
      label: 'Tutorial',
      items: ['hello'],
    },
  ],
   */
};

module.exports = sidebars;



================================================
FILE: doc/docusaurus/src/components/Card/index.tsx
================================================
// Placeholder
export default function () {
  return null;
}



================================================
FILE: doc/docusaurus/src/components/HomepageFeatures/index.js
================================================
import React from 'react';
import clsx from 'clsx';
import styles from './styles.module.css';

const FeatureList = [
  // {
  //   title: 'Easy to Use',
  //   Svg: require('@site/static/img/undraw_docusaurus_mountain.svg').default,
  //   description: (
  //     <>
  //       Docusaurus was designed from the ground up to be easily installed and
  //       used to get your website up and running quickly.
  //     </>
  //   ),
  // },
  // {
  //   title: 'Focus on What Matters',
  //   Svg: require('@site/static/img/undraw_docusaurus_tree.svg').default,
  //   description: (
  //     <>
  //       Docusaurus lets you focus on your docs, and we&apos;ll do the chores. Go
  //       ahead and move your docs into the <code>docs</code> directory.
  //     </>
  //   ),
  // },
  // {
  //   title: 'Powered by React',
  //   Svg: require('@site/static/img/undraw_docusaurus_react.svg').default,
  //   description: (
  //     <>
  //       Extend or customize your website layout by reusing React. Docusaurus can
  //       be extended while reusing the same header and footer.
  //     </>
  //   ),
  // },
];

function Feature({Svg, title, description}) {
  return (
    <div className={clsx('col col--4')}>
      <div className="text--center">
        <Svg className={styles.featureSvg} role="img" />
      </div>
      <div classN
