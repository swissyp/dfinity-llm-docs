(Files content cropped to 300k characters)

================================================
FILE: README.md
================================================
# Rust Canister Development Kit

[![Documentation](https://docs.rs/ic-cdk/badge.svg)](https://docs.rs/ic-cdk/)
[![Crates.io](https://img.shields.io/crates/v/ic-cdk.svg)](https://crates.io/crates/ic-cdk)
[![License](https://img.shields.io/crates/l/ic-cdk.svg)](https://github.com/dfinity/cdk-rs/blob/main/LICENSE)
[![Downloads](https://img.shields.io/crates/d/ic-cdk.svg)](https://crates.io/crates/ic-cdk)
[![CI](https://github.com/dfinity/cdk-rs/actions/workflows/ci.yml/badge.svg)](https://github.com/dfinity/cdk-rs/actions/workflows/ci.yml)

**Rust CDK provides tools for building Canisters on Internet Computer (IC).**

You may be looking for:

- [Documentation Site of the Internet Computer](https://internetcomputer.org/docs)
- [Tutorials of Rust CDK](https://internetcomputer.org/docs/current/developer-docs/backend/rust/)
- [`dfx` for managing IC projects](https://github.com/dfinity/sdk)

If you are looking for a crate to communicate with existing canisters on IC,
you may want to check [agent-rs](https://github.com/dfinity/agent-rs).

# Introduction

A `canister` is a WebAssembly (wasm) module that can run on the Internet Computer.

To be a `canister`, a wasm module should communicate with the execution environment using [Canister interfaces (System API)](https://internetcomputer.org/docs/current/references/ic-interface-spec/#system-api).

This repo provides libraries and tools to facilitate developing canisters in Rust.

- [`ic0`](ic0):
Internet Computer System API binding.
- [`ic-cdk`](ic-cdk):
Internet Computer Canister Development Kit.
- [`ic-cdk-bindgen`](ic-cdk-bindgen):
Generate Rust bindings from Candid to make inter-canister calls.
- [`ic-cdk-macros`](ic-cdk-macros):
Annotate functions with attribute macros to make them exposed public interfaces.
- [`ic-cdk-timers`](ic-cdk-timers):
The library implements multiple and periodic timers.
- [`ic-management-canister-types`](ic-management-canister-types): Types for calling the IC management canister.
- [`ic-certified-map`](library/ic-certified-map):
An implementation of map which support *certified queries*.
- [`ic-ledger-types`](library/ic-ledger-types):
Type definitions to communicate with the ICP ledger canister.

## Rust CDK in Action

In Cargo.toml:

```toml
[lib]
crate-type = ["cdylib"]

[dependencies]
ic-cdk = "0.18"
candid = "0.10" # required if you want to define Candid data types
```

Then in Rust source code:

```rust
#[ic_cdk::query]
fn hello() -> String{
    "world".to_string()
}
```

Check [Rust quickstart](https://internetcomputer.org/docs/current/developer-docs/backend/rust/quickstart) for a detailed guidance.



================================================
FILE: Cargo.toml
================================================
[workspace]
members = [
    "ic-cdk",
    "ic-cdk-bindgen",
    "ic-cdk-executor",
    "ic-cdk-macros",
    "ic-cdk-timers",
    "ic-management-canister-types",
    "ic0",
    "library/*",
    "e2e-tests",
]
resolver = "3"
exclude = ["candid-extractor"]

[workspace.package]
authors = ["DFINITY Stiftung <sdk@dfinity.org>"]
edition = "2024"
repository = "https://github.com/dfinity/cdk-rs"
# MSRV
# Avoid updating this field unless we use new Rust features.
# Sync with the `toolchain` field when setting up Rust toolchain in ci.yml msrv job.
rust-version = "1.85.0"
license = "Apache-2.0"

[profile.canister-release]
inherits = "release"
debug = false
panic = "abort"
lto = true
opt-level = 'z'

[workspace.dependencies]
ic0 = { path = "ic0", version = "1.0.1" }
ic-cdk = { path = "ic-cdk", version = "0.19.0-beta.3" }
ic-cdk-bindgen = { path = "ic-cdk-bindgen", version = "0.2.0-alpha.2" }
ic-cdk-timers = { path = "ic-cdk-timers", version = "1.0.0-beta.1" }
ic-cdk-executor = { path = "ic-cdk-executor", version = "2.0.0-beta.1" }
ic-management-canister-types = { path = "ic-management-canister-types", version = "0.4.1" }

candid = "0.10.18"      # sync with the doc comment in ic-cdk/README.md
candid_parser = "0.2.1"
futures = "0.3"
hex = "0.4"
ic_principal = "0.1"
quote = "1"
serde = "1"
serde_bytes = "0.11"
sha2 = "0.10"
slotmap = "1"
syn = "2"
thiserror = "2.0"



================================================
FILE: clippy.toml
================================================
doc-valid-idents = ["VetKD", "PocketIC", "TxID", "UTXO", "McJones", ".."]



================================================
FILE: LICENSE
================================================
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS



================================================
FILE: rust-toolchain.toml
================================================
[toolchain]
# This is not the MSRV, we just want to use the latest stable Rust for development
# MSRV is defined in the `Cargo.toml` file
channel = "stable"
targets = ["wasm32-unknown-unknown"]
components = ["rustfmt", "clippy"]



================================================
FILE: TROUBLESHOOTING.md
================================================
# Troubleshooting

## I was linked here by a Cargo error!

If your Cargo command produces the following error:

```
error: failed to select a version for `ic-cdk-executor`.
    ... required by package `yourcrate v0.1.0 (/Users/you/yourcrate)`
versions that meet the requirements `0.1.0` are: 0.1.0

the package `ic-cdk-executor` links to the native library `ic-cdk async executor`, but it conflicts with a previous package which links to `ic-cdk async executor` as well:
package `ic-cdk-executor v1.0.0`
    ... which satisfies dependency `ic-cdk-executor = "^1.0.0` of package `someothercrate v0.1.0`
Only one package in the dependency graph may specify the same links value. This helps ensure that only one copy of a native library is linked in the final binary. Try to adjust your dependencies so that only one package uses the `links = "ic-cdk async executor"` value. For more information, see https://doc.rust-lang.org/cargo/reference/resolver.html#links.

failed to select a version for `ic-cdk-executor` which could resolve this conflict
```

You have two incompatible versions of `ic-cdk` in your dependency tree. There are two common reasons for this.

First, a dependency may be using an older (or newer) version of the CDK. Many versions are compatible with each other, but versions 0.17 and earlier are incompatible with version 0.18, and 0.18 is incompatible with 0.19 or later. You will have to wait for those dependencies to update, or patch them yourself.

Second, a dependency may be using a nominally compatible version of the CDK, but you are using a GitHub prerelease of the CDK with `ic-cdk = { git =`. Git dependencies are automatically incompatible with everything, even if nothing changed. You will need to create a [patch table](https://doc.rust-lang.org/cargo/reference/overriding-dependencies.html) that replaces `ic-cdk` with a Git dependency at the same commit (you may also need to replace `ic-cdk-executor`).

You can find the dependencies responsible with the command `cargo tree -i ic-cdk`.



================================================
FILE: .mergify.yml
================================================
pull_request_rules:
  - name: Automatic merge
    conditions:
      - "#approved-reviews-by>=1"
      - "#changes-requested-reviews-by=0"
      - status-success=conventional-pr-title
      - label=automerge-squash
    actions:
      merge:
        method: squash
        strict: smart
        commit_message: title+body
      delete_head_branch: {}

  - name: Clean up automerge tags
    conditions:
      - closed
    actions:
      label:
        remove:
          - automerge-squash

  - name: Auto-approve auto-PRs
    conditions:
      - author=dfinity-bot
    actions:
      review:
        type: APPROVE
        message: This bot trusts that bot



================================================
FILE: e2e-tests/build.rs
================================================
fn main() {
    // For the `macros` test
    prost_build::compile_protos(&["src/bin/macros/canister.proto"], &["src/"])
        .expect("Failed to compile protos");

    // For the `bindgen` test
    // Static Callee mode bindgen for the management_canister
    ic_cdk_bindgen::Config::new(
        "management_canister",
        "../ic-management-canister-types/tests/ic.did",
    )
    .set_type_selector_config("src/bin/bindgen_callee/management.toml")
    .static_callee(candid::Principal::management_canister())
    .generate();
    // Dynamic Callee mode bindgen for the bindgen_callee
    ic_cdk_bindgen::Config::new("bindgen_callee", "src/bin/bindgen_callee/callee.did")
        .dynamic_callee("ICP_CANISTER_ID:bindgen_callee")
        .generate();
}



================================================
FILE: e2e-tests/Cargo.toml
================================================
[package]
name = "ic-cdk-e2e-tests"
version = "0.1.0"
authors = ["DFINITY Stiftung <sdk@dfinity.org>"]
edition = "2021"
description = "End-to-end tests for the Rust Canister Development Kit"
license = "Apache-2.0"
repository = "https://github.com/dfinity/cdk-rs"
publish = false

[dependencies]
async-channel = "2.3.1"
candid.workspace = true
env_logger = "0.11.5"
escargot = { version = "0.5.7" }
futures.workspace = true
ic-cdk = { workspace = true, features = ["transform-closure"] }
ic-cdk-timers.workspace = true
lazy_static = "1.4.0"
serde.workspace = true
serde_bytes.workspace = true
sha2.workspace = true
prost = "0.14"

[dev-dependencies]
candid_parser.workspace = true
cargo_metadata = "0.21"
futures = "0.3"
hex.workspace = true
ic-vetkd-utils = { git = "https://github.com/dfinity/ic", rev = "95231520" }
pocket-ic = { git = "https://github.com/dfinity/ic", tag = "release-2025-08-21_03-19-base" }
reqwest = "0.12"

[build-dependencies]
prost-build = "0.14"
ic-cdk-bindgen.workspace = true
candid.workspace = true



================================================
FILE: e2e-tests/tests/api.rs
================================================
use candid::Principal;
use ic_cdk::management_canister::{CanisterSettings, EnvironmentVariable, UpdateSettingsArgs};
use pocket_ic::ErrorCode;

mod test_utilities;
use test_utilities::{cargo_build_canister, pic_base, update};

#[test]
fn call_api() {
    let wasm = cargo_build_canister("api");
    // with_ii_subnet is required for testing the ic0.cost_sign_with_* API with pre-defined key name.
    let pic = pic_base().with_ii_subnet().build();
    let canister_id = pic.create_canister();
    pic.add_cycles(canister_id, 100_000_000_000_000);
    pic.install_canister(canister_id, wasm, vec![], None);
    let sender = Principal::anonymous();
    let res = pic
        .update_call(canister_id, sender, "call_msg_arg_data", vec![42])
        .unwrap();
    assert!(res.is_empty());
    let res = pic
        .update_call(canister_id, sender, "call_msg_caller", vec![])
        .unwrap();
    assert!(res.is_empty());
    // Unlike the other entry points, `call_msg_dealine_caller` was implemented with the `#[update]` macro.
    // So we use the update method which assumes candid
    let _: () = update(&pic, canister_id, "call_msg_deadline_caller", ()).unwrap();
    // `msg_reject_code` and `msg_reject_msg` can't be tested here.
    // They are invoked in the reply/reject callback of inter-canister calls.
    // So the `call.rs` test covers them.
    let res = pic
        .update_call(canister_id, sender, "call_msg_reply", vec![])
        .unwrap();
    assert_eq!(res, vec![42]);
    let res = pic
        .update_call(canister_id, sender, "call_msg_reject", vec![])
        .unwrap_err();
    assert_eq!(res.reject_message, "e2e test reject");
    let res = pic
        .update_call(canister_id, sender, "call_msg_cycles_available", vec![])
        .unwrap();
    assert!(res.is_empty());
    // `msg_cycles_refunded` can't be tested here.
    // It can only be called in the reply/reject callback of inter-canister calls.
    // TODO: Find a way to test it.
    let res = pic
        .update_call(canister_id, sender, "call_msg_cycles_accept", vec![])
        .unwrap();
    assert!(res.is_empty());
    let res = pic
        .update_call(canister_id, sender, "call_cycles_burn", vec![])
        .unwrap();
    assert!(res.is_empty());
    let res = pic
        .update_call(
            canister_id,
            sender,
            "call_canister_self",
            canister_id.as_slice().to_vec(),
        )
        .unwrap();
    assert!(res.is_empty());
    let res = pic
        .update_call(canister_id, sender, "call_canister_cycle_balance", vec![])
        .unwrap();
    assert!(res.is_empty());
    let res = pic
        .update_call(
            canister_id,
            sender,
            "call_canister_liquid_cycle_balance",
            vec![],
        )
        .unwrap();
    assert!(res.is_empty());
    let res = pic
        .update_call(canister_id, sender, "call_canister_status", vec![])
        .unwrap();
    assert!(res.is_empty());
    let res = pic
        .update_call(canister_id, sender, "call_canister_version", vec![])
        .unwrap();
    assert!(res.is_empty());
    let res = pic
        .update_call(canister_id, sender, "call_subnet_self", vec![])
        .unwrap();
    assert!(res.is_empty());
    // `msg_method_name` and `accept_message` are invoked in the inspect_message entry point.
    // Every calls above/below execute the inspect_message entry point.
    // So these two API bindings are tested implicitly.
    let res = pic
        .update_call(canister_id, sender, "call_stable", vec![])
        .unwrap();
    assert!(res.is_empty());
    let res = pic
        .update_call(canister_id, sender, "call_root_key", vec![])
        .unwrap();
    assert!(res.is_empty());
    let res = pic
        .update_call(canister_id, sender, "call_certified_data_set", vec![])
        .unwrap();
    assert!(res.is_empty());
    let res = pic
        .query_call(canister_id, sender, "call_data_certificate", vec![])
        .unwrap();
    assert!(res.is_empty());
    let res = pic
        .update_call(canister_id, sender, "call_time", vec![])
        .unwrap();
    assert!(res.is_empty());
    // `global_timer_set` is tested in `timers.rs`.
    let res = pic
        .update_call(canister_id, sender, "call_performance_counter", vec![])
        .unwrap();
    assert!(res.is_empty());
    let res = pic
        .update_call(canister_id, sender, "call_is_controller", vec![])
        .unwrap();
    assert!(res.is_empty());
    let res = pic
        .update_call(canister_id, sender, "call_in_replicated_execution", vec![])
        .unwrap();
    assert_eq!(res, vec![1]);
    let res = pic
        .query_call(canister_id, sender, "call_in_replicated_execution", vec![])
        .unwrap();
    assert_eq!(res, vec![0]);
    let res = pic
        .update_call(canister_id, sender, "call_cost_call", vec![])
        .unwrap();
    assert!(res.is_empty());
    let res = pic
        .update_call(canister_id, sender, "call_cost_create_canister", vec![])
        .unwrap();
    assert!(res.is_empty());
    let res = pic
        .update_call(canister_id, sender, "call_cost_http_request", vec![])
        .unwrap();
    assert!(res.is_empty());
    let res = pic
        .update_call(canister_id, sender, "call_cost_sign_with_ecdsa", vec![])
        .unwrap();
    assert!(res.is_empty());
    let res = pic
        .update_call(canister_id, sender, "call_cost_sign_with_schnorr", vec![])
        .unwrap();
    assert!(res.is_empty());

    let res = pic
        .update_call(canister_id, sender, "call_debug_print", vec![])
        .unwrap();
    assert!(res.is_empty());
    let rej = pic
        .update_call(canister_id, sender, "call_trap", vec![])
        .unwrap_err();
    assert_eq!(rej.error_code, ErrorCode::CanisterCalledTrap);
    assert!(rej.reject_message.contains("It's a trap!"));
}

// Test for the system API that are not enabled on the mainnet yet.
// A canister Wasm module that imports the non-mainnet APIs would result in canister installation failure.
#[test]
fn call_api_nonmainnet() {
    let wasm = cargo_build_canister("api_nonmainnet");
    let pic = pic_base().with_nonmainnet_features(true).build();
    let canister_id = pic.create_canister();
    pic.add_cycles(canister_id, 100_000_000_000_000);
    pic.install_canister(canister_id, wasm, vec![], None);
    let sender = Principal::anonymous();
    let update_settings_arg = UpdateSettingsArgs {
        canister_id,
        settings: CanisterSettings {
            environment_variables: Some(vec![
                EnvironmentVariable {
                    name: "key1".to_string(),
                    value: "value1".to_string(),
                },
                EnvironmentVariable {
                    name: "key2".to_string(),
                    value: "value2".to_string(),
                },
            ]),
            ..Default::default()
        },
    };
    let _: () = update(
        &pic,
        Principal::management_canister(),
        "update_settings",
        (update_settings_arg,),
    )
    .unwrap();

    // As of 2025-08, the env_var APIs are not available on mainnet yet.
    let res = pic
        .update_call(canister_id, sender, "call_env_var_count", vec![])
        .unwrap();
    assert!(res.is_empty());
    let res = pic
        .update_call(canister_id, sender, "call_env_var_name", vec![])
        .unwrap();
    assert!(res.is_empty());
    let res = pic
        .update_call(canister_id, sender, "call_env_var_name_exists", vec![])
        .unwrap();
    assert!(res.is_empty());
    let res = pic
        .update_call(canister_id, sender, "call_env_var_value", vec![])
        .unwrap();
    assert!(res.is_empty());
}



================================================
FILE: e2e-tests/tests/async.rs
================================================
use candid::Principal;
use pocket_ic::{query_candid, ErrorCode};

mod test_utilities;
use test_utilities::{cargo_build_canister, pic_base, update};

#[test]
fn panic_after_await_frees_resources() {
    let wasm = cargo_build_canister("async");
    let pic = pic_base().build();
    let canister_id = pic.create_canister();
    pic.add_cycles(canister_id, 2_000_000_000_000);
    pic.install_canister(canister_id, wasm, vec![], None);

    for i in 1..3 {
        match update(&pic, canister_id, "panic_after_await", ()) {
            Ok(()) => panic!("expected a panic, but got success"),
            Err(rej) => {
                println!("Got a user error as expected: {rej}");

                assert_eq!(rej.error_code, ErrorCode::CanisterCalledTrap);
                let expected_message = "Goodbye, cruel world.";
                assert!(
                    rej.reject_message.contains(expected_message),
                    "Expected the user error to contain '{}', got: {}",
                    expected_message,
                    rej.reject_message
                );
            }
        }

        let (n,): (u64,) = update(&pic, canister_id, "get_locked_resource", ()).unwrap();

        assert_eq!(i, n, "expected the invocation count to be {i}, got {n}");
    }

    let (message,): (String,) =
        update(&pic, canister_id, "invalid_reply_payload_does_not_trap", ()).unwrap();
    assert!(message.contains("handled decoding error gracefully"));

    let rej = update::<_, ()>(&pic, canister_id, "panic_twice", ()).expect_err("failed to panic");
    assert!(rej.reject_message.contains("Call already trapped"));
    let _: (u64,) = update(&pic, canister_id, "notifications_received", ()).unwrap();
    let _: (u64,) = update(&pic, canister_id, "get_locked_resource", ()).unwrap();
}

#[test]
fn panic_after_await_frees_resources_in_spawn_migratory() {
    let wasm = cargo_build_canister("async");
    let pic = pic_base().build();
    let canister_id = pic.create_canister();
    pic.add_cycles(canister_id, 2_000_000_000_000);
    pic.install_canister(canister_id, wasm, vec![], None);

    update::<_, ()>(
        &pic,
        canister_id,
        "panic_after_await_in_spawn_migratory",
        (),
    )
    .unwrap();

    let res = update::<_, ()>(&pic, canister_id, "migratory_resume", ());
    let logs = pic
        .fetch_canister_logs(canister_id, Principal::anonymous())
        .unwrap();
    match res {
        Err(r) => assert!(r.reject_message.contains("Goodbye, cruel world.")),
        Ok(()) => assert!(logs.last().is_some_and(|log| str::from_utf8(&log.content)
            .unwrap()
            .contains("Goodbye, cruel world.",))),
    }

    update::<_, ()>(&pic, canister_id, "migratory_resume", ()).unwrap();
    assert!(
        pic.fetch_canister_logs(canister_id, Principal::anonymous())
            .unwrap()
            .len()
            == logs.len()
    );
    let _: (u64,) = update(&pic, canister_id, "notifications_received", ()).unwrap();
    let _: (u64,) = update(&pic, canister_id, "get_locked_resource", ()).unwrap();
}

#[test]
fn panic_after_await_destructors_cannot_schedule_tasks() {
    let wasm = cargo_build_canister("async");
    let pic = pic_base().build();
    let canister_id = pic.create_canister();
    pic.add_cycles(canister_id, 2_000_000_000_000);
    pic.install_canister(canister_id, wasm, vec![], None);
    let err = update::<_, ()>(&pic, canister_id, "schedule_on_panic", ()).unwrap_err();
    assert!(err
        .reject_message
        .contains("tasks cannot be spawned while recovering from a trap"));
    let (pre_bg_notifs,): (u64,) =
        query_candid(&pic, canister_id, "notifications_received", ()).unwrap();
    assert_eq!(pre_bg_notifs, 1);
    update::<_, ()>(&pic, canister_id, "on_notify", ()).unwrap();
    let (post_bg_notifs,): (u64,) =
        query_candid(&pic, canister_id, "notifications_received", ()).unwrap();
    assert_eq!(post_bg_notifs, 2);
}

#[test]
fn panic_after_await_destructors_can_schedule_timers() {
    let wasm = cargo_build_canister("async");
    let pic = pic_base().build();
    let canister_id = pic.create_canister();
    pic.add_cycles(canister_id, 2_000_000_000_000);
    pic.install_canister(canister_id, wasm, vec![], None);
    let err = update::<_, ()>(&pic, canister_id, "timer_on_panic", ()).unwrap_err();
    assert!(err.reject_message.contains("testing"));
    assert!(!err.reject_message.contains("recovery"));
    let (pre_bg_notifs,): (u64,) =
        query_candid(&pic, canister_id, "notifications_received", ()).unwrap();
    assert_eq!(pre_bg_notifs, 1);
    update::<_, ()>(&pic, canister_id, "on_notify", ()).unwrap();
    let (post_bg_notifs,): (u64,) =
        query_candid(&pic, canister_id, "notifications_received", ()).unwrap();
    assert_eq!(post_bg_notifs, 5);
}

#[test]
fn notify_calls() {
    let wasm = cargo_build_canister("async");
    let pic = pic_base().build();
    let sender_id = pic.create_canister();
    pic.add_cycles(sender_id, 2_000_000_000_000);
    pic.install_canister(sender_id, wasm.clone(), vec![], None);
    let receiver_id = pic.create_canister();
    pic.add_cycles(receiver_id, 2_000_000_000_000);
    pic.install_canister(receiver_id, wasm, vec![], None);

    let (n,): (u64,) = query_candid(&pic, receiver_id, "notifications_received", ()).unwrap();
    assert_eq!(n, 0);

    let () = update(&pic, sender_id, "notify", (receiver_id, "on_notify")).unwrap();

    let (n,): (u64,) = query_candid(&pic, receiver_id, "notifications_received", ()).unwrap();
    assert_eq!(n, 1);
}

#[test]
fn test_composite_query() {
    let wasm = cargo_build_canister("async");
    let pic = pic_base().build();
    let sender_id = pic.create_canister();
    pic.add_cycles(sender_id, 2_000_000_000_000);
    pic.install_canister(sender_id, wasm.clone(), vec![], None);
    let receiver_id = pic.create_canister();
    pic.add_cycles(receiver_id, 2_000_000_000_000);
    pic.install_canister(receiver_id, wasm, vec![], None);

    let (greeting,): (String,) =
        query_candid(&pic, sender_id, "greet_self", (receiver_id,)).unwrap();
    assert_eq!(greeting, "Hello, myself");
}

#[test]
fn channels() {
    let wasm = cargo_build_canister("async");
    let pic = pic_base().build();
    let canister_id = pic.create_canister();
    pic.add_cycles(canister_id, 2_000_000_000_000);
    pic.install_canister(canister_id, wasm, vec![], None);

    let (greeting,): (String,) = update(&pic, canister_id, "await_channel_completion", ()).unwrap();
    assert_eq!(greeting, "Hello, myself");
}

#[test]
fn spawn_ordering() {
    let wasm = cargo_build_canister("async");
    let pic = pic_base().build();
    let canister_id = pic.create_canister();
    pic.add_cycles(canister_id, 2_000_000_000_000);
    pic.install_canister(canister_id, wasm, vec![], None);

    let () = update(&pic, canister_id, "spawn_ordering", ()).unwrap();
    let (n,): (u64,) = query_candid(&pic, canister_id, "notifications_received", ()).unwrap();
    assert_eq!(n, 2);
}

#[test]
fn early_panic_not_erased() {
    let wasm = cargo_build_canister("async");
    let pic = pic_base().build();
    let canister_id = pic.create_canister();
    pic.add_cycles(canister_id, 2_000_000_000_000);
    pic.install_canister(canister_id, wasm, vec![], None);

    let err = update::<_, ()>(&pic, canister_id, "panic_then_continue", ()).unwrap_err();
    assert!(err.reject_message.contains("already trapped"));

    let (n,): (u64,) = query_candid(&pic, canister_id, "notifications_received", ()).unwrap();
    assert_eq!(n, 2);
    let _: (u64,) = query_candid(&pic, canister_id, "get_locked_resource", ()).unwrap();
}

#[test]
fn protected_spawn_magnetism() {
    let wasm = cargo_build_canister("async");
    let pic = pic_base().build();
    let canister_id = pic.create_canister();
    pic.add_cycles(canister_id, 2_000_000_000_000);
    pic.install_canister(canister_id, wasm, vec![], None);

    update::<_, ()>(&pic, canister_id, "spawn_protected_with_distant_waker", ()).unwrap();
}

#[test]
fn protected_spawn_cannot_outlive() {
    let wasm = cargo_build_canister("async");
    let pic = pic_base().build();
    let canister_id = pic.create_canister();
    pic.add_cycles(canister_id, 2_000_000_000_000);
    pic.install_canister(canister_id, wasm, vec![], None);

    let err = update::<_, ()>(&pic, canister_id, "stalled_protected_task", ()).unwrap_err();
    assert!(err
        .reject_message
        .contains("protected task outlived its canister method"));
}

#[test]
fn protected_spawn_unavailable_in_migratory() {
    let wasm = cargo_build_canister("async");
    let pic = pic_base().build();
    let canister_id = pic.create_canister();
    pic.add_cycles(canister_id, 2_000_000_000_000);
    pic.install_canister(canister_id, wasm, vec![], None);

    let err = update::<_, ()>(&pic, canister_id, "protected_from_migratory", ()).unwrap_err();
    assert!(err
        .reject_message
        .contains("cannot be called outside of a tracked method context"));
}



================================================
FILE: e2e-tests/tests/bindgen.rs
================================================
mod test_utilities;
use candid::Principal;
use ic_cdk::management_canister::{CanisterSettings, EnvironmentVariable, UpdateSettingsArgs};
use test_utilities::{cargo_build_canister, pic_base, update};

#[test]
fn bindgen() {
    let wasm = cargo_build_canister("bindgen");
    let callee_wasm = cargo_build_canister("bindgen_callee");

    let pic = pic_base().with_nonmainnet_features(true).build();

    let callee_canister_id = pic.create_canister();
    pic.add_cycles(callee_canister_id, 100_000_000_000_000);
    pic.install_canister(callee_canister_id, callee_wasm, vec![], None);

    let canister_id = pic.create_canister();
    pic.add_cycles(canister_id, 100_000_000_000_000);
    pic.install_canister(canister_id, wasm, vec![], None);
    // Make the callee canister a controller of the main canister.
    // We will impersonate a management canister call to set the env var later.
    pic.set_controllers(canister_id, None, vec![callee_canister_id])
        .expect("failed to set controllers");

    let _: () = update(&pic, canister_id, "call_management_canister", ()).unwrap();

    // The required env var is not set, so the call will fail.
    let required_env_var = "ICP_CANISTER_ID:bindgen_callee";
    let res: Result<(), _> = update(&pic, canister_id, "call_bindgen_callee", ());
    assert!(res.unwrap_err().reject_message.contains(&format!(
        "env var `{}` is not set. Canister controller can set it using tools like icp-cli.",
        required_env_var
    )));

    // Set a invalid value for the required env var.
    // Then the call will fail for a different reason.
    let effective_principal =
        pocket_ic::common::rest::RawEffectivePrincipal::CanisterId(canister_id.as_slice().to_vec());
    let invalid_value = "Not a Principal";
    let settings = CanisterSettings {
        environment_variables: Some(vec![EnvironmentVariable {
            name: required_env_var.into(),
            value: invalid_value.to_string(),
        }]),
        ..Default::default()
    };
    let args = UpdateSettingsArgs {
        canister_id,
        settings,
    };
    let _: () = pocket_ic::call_candid_as(
        &pic,
        Principal::management_canister(),
        effective_principal.clone(),
        callee_canister_id,
        "update_settings",
        (args,),
    )
    .expect("failed to call update_settings for setting env var");
    let res: Result<(), _> = update(&pic, canister_id, "call_bindgen_callee", ());
    assert!(res.unwrap_err().reject_message.contains(&format!(
        "failed to parse Principal from env var `{}`, value `{}`",
        required_env_var, invalid_value
    )));

    // Set the required env var.
    // This is expected to be set automatically by `icp-cli`.
    let settings = CanisterSettings {
        environment_variables: Some(vec![EnvironmentVariable {
            name: required_env_var.into(),
            value: callee_canister_id.to_string(),
        }]),
        ..Default::default()
    };
    let args = UpdateSettingsArgs {
        canister_id,
        settings,
    };

    let _: () = pocket_ic::call_candid_as(
        &pic,
        Principal::management_canister(),
        effective_principal,
        callee_canister_id,
        "update_settings",
        (args,),
    )
    .expect("failed to call update_settings for setting env var");
    let _: () = update(&pic, canister_id, "call_bindgen_callee", ()).unwrap();
}



================================================
FILE: e2e-tests/tests/bitcoin_canister.rs
================================================
use candid::{IDLArgs, Principal};
use candid_parser::parse_idl_args;
use cargo_metadata::MetadataCommand;
use ic_cdk::bitcoin_canister::Network;
use std::path::PathBuf;

mod test_utilities;
use test_utilities::{cargo_build_canister, pic_base, update};

#[test]
fn test_bitcoin_canister() {
    // Mainnet
    let mainnet_id = Principal::from_slice(&[0, 0, 0, 0, 1, 160, 0, 4, 1, 1]);
    let mainnet_init_args = r#"(
  record {
    api_access = variant { enabled };
    lazily_evaluate_fee_percentiles = variant { enabled };
    blocks_source = principal "aaaaa-aa";
    fees = record {
      get_current_fee_percentiles = 10_000_000 : nat;
      get_utxos_maximum = 10_000_000_000 : nat;
      get_block_headers_cycles_per_ten_instructions = 10 : nat;
      get_current_fee_percentiles_maximum = 100_000_000 : nat;
      send_transaction_per_byte = 20_000_000 : nat;
      get_balance = 10_000_000 : nat;
      get_utxos_cycles_per_ten_instructions = 10 : nat;
      get_block_headers_base = 50_000_000 : nat;
      get_utxos_base = 50_000_000 : nat;
      get_balance_maximum = 100_000_000 : nat;
      send_transaction_base = 5_000_000_000 : nat;
      get_block_headers_maximum = 10_000_000_000 : nat;
    };
    network = variant { mainnet };
    stability_threshold = 100 : nat;
    syncing = variant { enabled };
    burn_cycles = variant { enabled };
    disable_api_if_not_fully_synced = variant { enabled };
  },
)"#;
    test_network(Network::Mainnet, mainnet_id, mainnet_init_args);
    // Testnet
    let testnet_id = Principal::from_slice(&[0, 0, 0, 0, 1, 160, 0, 1, 1, 1]);
    let testnet_init_args = r#"(
  record {
    api_access = variant { enabled };
    lazily_evaluate_fee_percentiles = variant { enabled };
    blocks_source = principal "aaaaa-aa";
    fees = record {
      get_current_fee_percentiles = 4_000_000 : nat;
      get_utxos_maximum = 4_000_000_000 : nat;
      get_block_headers_cycles_per_ten_instructions = 10 : nat;
      get_current_fee_percentiles_maximum = 40_000_000 : nat;
      send_transaction_per_byte = 8_000_000 : nat;
      get_balance = 4_000_000 : nat;
      get_utxos_cycles_per_ten_instructions = 10 : nat;
      get_block_headers_base = 20_000_000 : nat;
      get_utxos_base = 20_000_000 : nat;
      get_balance_maximum = 40_000_000 : nat;
      send_transaction_base = 2_000_000_000 : nat;
      get_block_headers_maximum = 4_000_000_000 : nat;
    };
    network = variant { testnet };
    stability_threshold = 144 : nat;
    syncing = variant { enabled };
    burn_cycles = variant { enabled };
    disable_api_if_not_fully_synced = variant { enabled };
  },
)"#;
    test_network(Network::Testnet, testnet_id, testnet_init_args);
    // Regtest
    let regtest_id = testnet_id;
    let regtest_init_args = r#"(
  record {
    api_access = variant { enabled };
    lazily_evaluate_fee_percentiles = variant { enabled };
    blocks_source = principal "aaaaa-aa";
    fees = record {
      get_current_fee_percentiles = 0 : nat;
      get_utxos_maximum = 0 : nat;
      get_block_headers_cycles_per_ten_instructions = 0 : nat;
      get_current_fee_percentiles_maximum = 0 : nat;
      send_transaction_per_byte = 0 : nat;
      get_balance = 0 : nat;
      get_utxos_cycles_per_ten_instructions = 0 : nat;
      get_block_headers_base = 0 : nat;
      get_utxos_base = 0 : nat;
      get_balance_maximum = 0 : nat;
      send_transaction_base = 0 : nat;
      get_block_headers_maximum = 0 : nat;
    };
    network = variant { regtest };
    stability_threshold = 144 : nat;
    syncing = variant { enabled };
    burn_cycles = variant { enabled };
    disable_api_if_not_fully_synced = variant { enabled };
  },
)"#;
    test_network(Network::Regtest, regtest_id, regtest_init_args);
}

fn test_network(network: Network, btc_id: Principal, init_args: &str) {
    let wasm = cargo_build_canister("bitcoin_canister");
    // The Bitcoin canisters can still function without connecting to a `bitcoind` node.
    // The interface check and the cycles cost logic are still valid.
    let pic = pic_base().with_bitcoin_subnet().build();
    let canister_id = pic.create_canister();
    pic.add_cycles(canister_id, 10_000_000_000_000u128); // 10 T
    pic.install_canister(canister_id, wasm, vec![], None);

    let btc_canister_wasm = std::fs::read(cache_btc_canister_wasm()).unwrap();
    let _ = pic.create_canister_with_id(None, None, btc_id).unwrap();
    pic.add_cycles(btc_id, 10_000_000_000_000u128);
    let args: IDLArgs = parse_idl_args(init_args).expect("failed to parse IDL args");
    let encoded_args = args.to_bytes().expect("failed to encode IDL args");
    pic.install_canister(btc_id, btc_canister_wasm.clone(), encoded_args, None);
    let () = update(&pic, canister_id, "execute_non_query_methods", (network,)).unwrap();
}

fn cache_btc_canister_wasm() -> PathBuf {
    const EXPECTED_TAG: &str = "release%2F2024-08-30"; // The slash is encoded as %2F in the URL
    let dir = PathBuf::from(std::env::var("CARGO_MANIFEST_DIR").unwrap());
    let cargo_toml_path = dir.join("Cargo.toml");
    let target_dir = MetadataCommand::new()
        .manifest_path(&cargo_toml_path)
        .exec()
        .expect("failed to run cargo metadata")
        .target_directory;
    let artifact_dir = target_dir.join("e2e-tests-artifacts");
    std::fs::create_dir_all(&artifact_dir).expect("failed to create artifact directory");
    let tag_file = artifact_dir.join("ic-btc-canister-tag");
    let binary_file = artifact_dir.join("ic-btc-canister.wasm.gz");
    if let Ok(tag) = std::fs::read_to_string(&tag_file) {
        if tag == EXPECTED_TAG && binary_file.exists() {
            return binary_file.into();
        }
    }
    let url = format!(
        " https://github.com/dfinity/bitcoin-canister/releases/download/{EXPECTED_TAG}/ic-btc-canister.wasm.gz");
    let gz_bytes = reqwest::blocking::get(url)
        .expect("failed to download ic-btc-canister.wasm.gz")
        .bytes()
        .expect("failed to get bytes of ic-btc-canister.wasm.gz")
        .to_vec();
    std::fs::write(&binary_file, gz_bytes).expect("failed to write binary file");
    std::fs::write(tag_file, EXPECTED_TAG).expect("failed to write tag file");
    binary_file.into()
}



================================================
FILE: e2e-tests/tests/call.rs
================================================
mod test_utilities;
use test_utilities::{cargo_build_canister, pic_base, update};

#[test]
fn call() {
    let wasm = cargo_build_canister("call");
    let pic = pic_base().build();
    let canister_id = pic.create_canister();
    pic.add_cycles(canister_id, 100_000_000_000_000);
    pic.install_canister(canister_id, wasm, vec![], None);
    let _: () = update(&pic, canister_id, "call_foo", ()).unwrap();
    let _: () = update(&pic, canister_id, "call_echo", ()).unwrap();
    let _: () = update(&pic, canister_id, "retry_calls", ()).unwrap();
    let _: () = update(&pic, canister_id, "join_calls", ()).unwrap();
    let _: () = update(
        &pic,
        canister_id,
        "insufficient_liquid_cycle_balance_error",
        (),
    )
    .unwrap();

    let _: () = update(&pic, canister_id, "call_error_ext", ()).unwrap();
}



================================================
FILE: e2e-tests/tests/canister_info.rs
================================================
use candid::Principal;
use ic_cdk::management_canister::{
    CanisterInfoResult, CanisterInstallMode, Change, ChangeDetails, ChangeOrigin,
    CodeDeploymentMode::{Install, Reinstall, Upgrade},
    CodeDeploymentRecord, ControllersChangeRecord, CreationRecord, FromCanisterRecord,
    FromUserRecord, InstallCodeArgs, UninstallCodeArgs,
};
use pocket_ic::{call_candid_as, common::rest::RawEffectivePrincipal};

mod test_utilities;
use test_utilities::{cargo_build_canister, pic_base, update};

#[test]
fn test_canister_info() {
    let wasm = cargo_build_canister("canister_info");
    let pic = pic_base().build();
    // As of PocketIC server v5.0.0 and client v4.0.0, the first canister creation happens at (time0+4).
    // Each operation advances the Pic by 2 nanos, except for the last operation which advances only by 1 nano.
    let time0: u64 = pic.get_time().as_nanos_since_unix_epoch();
    let canister_id = pic.create_canister();
    pic.add_cycles(canister_id, 2_000_000_000_000);
    pic.install_canister(canister_id, wasm, vec![], None);

    let new_canister: (Principal,) = update(&pic, canister_id, "canister_lifecycle", ())
        .expect("Error calling canister_lifecycle");

    let () = call_candid_as(
        &pic,
        Principal::management_canister(),
        RawEffectivePrincipal::None,
        Principal::anonymous(),
        "uninstall_code",
        (UninstallCodeArgs {
            canister_id: new_canister.0,
        },),
    )
    .expect("Error calling uninstall_code");
    let () = call_candid_as(
        &pic,
        Principal::management_canister(),
        RawEffectivePrincipal::None,
        Principal::anonymous(),
        "install_code",
        (InstallCodeArgs {
            mode: CanisterInstallMode::Install,
            arg: vec![],
            wasm_module: vec![0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00],
            canister_id: new_canister.0,
        },),
    )
    .expect("Error calling install_code");

    let info: (CanisterInfoResult,) =
        update(&pic, canister_id, "info", (new_canister.0,)).expect("Error calling canister_info");

    assert_eq!(
        info.0,
        CanisterInfoResult {
            total_num_changes: 9,
            recent_changes: vec![
                Change {
                    timestamp_nanos: time0 + 4,
                    canister_version: 0,
                    origin: ChangeOrigin::FromCanister(FromCanisterRecord {
                        canister_id,
                        canister_version: Some(1)
                    }),
                    details: ChangeDetails::Creation(CreationRecord {
                        controllers: vec![canister_id],
                        environment_variables_hash: None
                    }),
                },
                Change {
                    timestamp_nanos: time0 + 6,
                    canister_version: 1,
                    origin: ChangeOrigin::FromCanister(FromCanisterRecord {
                        canister_id,
                        canister_version: Some(2)
                    }),
                    details: ChangeDetails::CodeDeployment(CodeDeploymentRecord {
                        mode: Install,
                        module_hash: hex::decode(
                            "93a44bbb96c751218e4c00d479e4c14358122a389acca16205b1e4d0dc5f9476"
                        )
                        .unwrap(),
                    }),
                },
                Change {
                    timestamp_nanos: time0 + 8,
                    canister_version: 2,
                    origin: ChangeOrigin::FromCanister(FromCanisterRecord {
                        canister_id,
                        canister_version: Some(3)
                    }),
                    details: ChangeDetails::CodeUninstall,
                },
                Change {
                    timestamp_nanos: time0 + 10,
                    canister_version: 3,
                    origin: ChangeOrigin::FromCanister(FromCanisterRecord {
                        canister_id,
                        canister_version: Some(4)
                    }),
                    details: ChangeDetails::CodeDeployment(CodeDeploymentRecord {
                        mode: Install,
                        module_hash: hex::decode(
                            "93a44bbb96c751218e4c00d479e4c14358122a389acca16205b1e4d0dc5f9476"
                        )
                        .unwrap(),
                    }),
                },
                Change {
                    timestamp_nanos: time0 + 12,
                    canister_version: 4,
                    origin: ChangeOrigin::FromCanister(FromCanisterRecord {
                        canister_id,
                        canister_version: Some(5)
                    }),
                    details: ChangeDetails::CodeDeployment(CodeDeploymentRecord {
                        mode: Reinstall,
                        module_hash: hex::decode(
                            "93a44bbb96c751218e4c00d479e4c14358122a389acca16205b1e4d0dc5f9476"
                        )
                        .unwrap(),
                    }),
                },
                Change {
                    timestamp_nanos: time0 + 14,
                    canister_version: 5,
                    origin: ChangeOrigin::FromCanister(FromCanisterRecord {
                        canister_id,
                        canister_version: Some(6)
                    }),
                    details: ChangeDetails::CodeDeployment(CodeDeploymentRecord {
                        mode: Upgrade,
                        module_hash: hex::decode(
                            "93a44bbb96c751218e4c00d479e4c14358122a389acca16205b1e4d0dc5f9476"
                        )
                        .unwrap(),
                    }),
                },
                Change {
                    timestamp_nanos: time0 + 16,
                    canister_version: 6,
                    origin: ChangeOrigin::FromCanister(FromCanisterRecord {
                        canister_id,
                        canister_version: Some(7)
                    }),
                    details: ChangeDetails::ControllersChange(ControllersChangeRecord {
                        controllers: vec![Principal::anonymous(), canister_id, new_canister.0]
                    }),
                },
                Change {
                    timestamp_nanos: time0 + 18,
                    canister_version: 7,
                    origin: ChangeOrigin::FromUser(FromUserRecord {
                        user_id: Principal::anonymous(),
                    }),
                    details: ChangeDetails::CodeUninstall,
                },
                Change {
                    timestamp_nanos: time0 + 19,
                    canister_version: 8,
                    origin: ChangeOrigin::FromUser(FromUserRecord {
                        user_id: Principal::anonymous(),
                    }),
                    details: ChangeDetails::CodeDeployment(CodeDeploymentRecord {
                        mode: Install,
                        module_hash: hex::decode(
                            "93a44bbb96c751218e4c00d479e4c14358122a389acca16205b1e4d0dc5f9476"
                        )
                        .unwrap(),
                    }),
                },
            ],
            module_hash: Some(
                hex::decode("93a44bbb96c751218e4c00d479e4c14358122a389acca16205b1e4d0dc5f9476")
                    .unwrap()
            ),
            controllers: vec![Principal::anonymous(), canister_id, new_canister.0],
        }
    );
}



================================================
FILE: e2e-tests/tests/chunk.rs
================================================
use candid::Principal;
use sha2::Digest;

mod test_utilities;
use test_utilities::{cargo_build_canister, pic_base, update};

#[test]
fn test_chunk() {
    let wasm = cargo_build_canister("chunk");
    let pic = pic_base().build();
    let canister_id = pic.create_canister();
    pic.add_cycles(canister_id, 100_000_000_000_000);
    pic.install_canister(canister_id, wasm, vec![], None);
    let (target_canister_id,): (Principal,) =
        update(&pic, canister_id, "call_create_canister", ()).unwrap();

    let wasm_module = b"\x00asm\x01\x00\x00\x00".to_vec();
    let wasm_module_hash = sha2::Sha256::digest(&wasm_module).to_vec();
    let chunk1 = wasm_module[..4].to_vec();
    let chunk2 = wasm_module[4..].to_vec();
    let hash1_expected = sha2::Sha256::digest(&chunk1).to_vec();
    let hash2_expected = sha2::Sha256::digest(&chunk2).to_vec();

    let (hash1_return,): (Vec<u8>,) = update(
        &pic,
        canister_id,
        "call_upload_chunk",
        (target_canister_id, chunk1.clone()),
    )
    .unwrap();
    assert_eq!(&hash1_return, &hash1_expected);

    let () = update(
        &pic,
        canister_id,
        "call_clear_chunk_store",
        (target_canister_id,),
    )
    .unwrap();

    let (_hash1_return,): (Vec<u8>,) = update(
        &pic,
        canister_id,
        "call_upload_chunk",
        (target_canister_id, chunk1),
    )
    .unwrap();
    let (_hash2_return,): (Vec<u8>,) = update(
        &pic,
        canister_id,
        "call_upload_chunk",
        (target_canister_id, chunk2),
    )
    .unwrap();

    let (hashes,): (Vec<Vec<u8>>,) = update(
        &pic,
        canister_id,
        "call_stored_chunks",
        (target_canister_id,),
    )
    .unwrap();
    // the hashes returned are not guaranteed to be in order
    assert_eq!(hashes.len(), 2);
    assert!(hashes.contains(&hash1_expected));
    assert!(hashes.contains(&hash2_expected));

    let () = update(
        &pic,
        canister_id,
        "call_install_chunked_code",
        (
            target_canister_id,
            // the order of the hashes matters
            vec![hash1_expected, hash2_expected],
            wasm_module_hash,
        ),
    )
    .unwrap();
}



================================================
FILE: e2e-tests/tests/http_request.rs
================================================
use candid::{Encode, Principal};
use pocket_ic::common::rest::{
    CanisterHttpHeader, CanisterHttpReply, CanisterHttpRequest, CanisterHttpResponse,
    MockCanisterHttpResponse,
};
use pocket_ic::PocketIc;

mod test_utilities;
use test_utilities::{cargo_build_canister, pic_base};

#[test]
fn test_http_request() {
    let wasm = cargo_build_canister("http_request");
    let pic = pic_base().build();

    let canister_id = pic.create_canister();
    pic.add_cycles(canister_id, 3_000_000_000_000u128);
    pic.install_canister(canister_id, wasm, vec![], None);

    test_one_http_request(&pic, canister_id, "get_without_transform");
    test_one_http_request(&pic, canister_id, "post");
    test_one_http_request(&pic, canister_id, "head");
    test_one_http_request(&pic, canister_id, "get_with_transform");
    test_one_http_request(&pic, canister_id, "get_with_transform_closure");
    test_one_http_request(&pic, canister_id, "non_replicated");
}

fn test_one_http_request(pic: &PocketIc, canister_id: Principal, method: &str) {
    let call_id = pic
        .submit_call(
            canister_id,
            Principal::anonymous(),
            method,
            Encode!(&()).unwrap(),
        )
        .unwrap();
    let canister_http_requests = tick_until_next_request(pic);
    assert_eq!(canister_http_requests.len(), 1);
    let request = &canister_http_requests[0];
    pic.mock_canister_http_response(MockCanisterHttpResponse {
        subnet_id: request.subnet_id,
        request_id: request.request_id,
        response: CanisterHttpResponse::CanisterHttpReply(CanisterHttpReply {
            status: 200,
            headers: vec![CanisterHttpHeader {
                name: "response_header_name".to_string(),
                value: "response_header_value".to_string(),
            }],
            body: vec![42],
        }),
        additional_responses: vec![],
    });
    pic.await_call(call_id).unwrap();
}

fn tick_until_next_request(pic: &PocketIc) -> Vec<CanisterHttpRequest> {
    for _ in 0..10 {
        let requests = pic.get_canister_http();
        if !requests.is_empty() {
            return requests;
        }
        pic.tick();
    }
    vec![]
}



================================================
FILE: e2e-tests/tests/macros.rs
================================================
use candid::Principal;
use prost::Message;

mod canister {
    include!(concat!(env!("OUT_DIR"), "/canister.rs"));
}
use canister::*;

mod test_utilities;
use test_utilities::{cargo_build_canister, pic_base, update};

#[test]
fn call_macros() {
    let wasm = cargo_build_canister("macros");
    let pic = pic_base().build();
    let canister_id = pic.create_canister();
    pic.add_cycles(canister_id, 100_000_000_000_000);
    pic.install_canister(canister_id, wasm, vec![], None);
    let _: () = update(&pic, canister_id, "arg0", ()).unwrap();
    let _: () = update(&pic, canister_id, "arg1", (1u32,)).unwrap();
    let _: () = update(&pic, canister_id, "arg2", (1u32, 2u32)).unwrap();
    let sender = Principal::anonymous();
    let res = pic
        .update_call(canister_id, sender, "ret0", vec![])
        .unwrap();
    assert_eq!(res, vec![0]);
    let res = pic
        .update_call(canister_id, sender, "ret1", vec![])
        .unwrap();
    assert_eq!(res, vec![42]);
    let res = pic
        .update_call(canister_id, sender, "ret2", vec![])
        .unwrap();
    assert_eq!(res, vec![1, 2]);
    let res = pic
        .update_call(
            canister_id,
            sender,
            "method_one",
            MethodOneRequest {
                input: "Hello".to_string(),
            }
            .encode_to_vec(),
        )
        .unwrap();
    assert_eq!(res, MethodOneResponse { result: 5i32 }.encode_to_vec());
    let res = pic
        .update_call(
            canister_id,
            sender,
            "method_two",
            MethodTwoRequest { values: vec![1.0] }.encode_to_vec(),
        )
        .unwrap();
    assert_eq!(
        res,
        MethodTwoResponse {
            success: true,
            message: "Hello world!".to_string()
        }
        .encode_to_vec()
    );
    let _: (u32,) = update(&pic, canister_id, "manual_reply", ()).unwrap();
    let (res,): (u32,) = update(&pic, canister_id, "generic", (1u32,)).unwrap();
    assert_eq!(res, 2);

    let rej = pic
        .update_call(canister_id, sender, "with_guards", vec![1])
        .unwrap_err();
    assert_eq!(rej.reject_message, "guard1 failed");
    let rej = pic
        .update_call(canister_id, sender, "with_guards", vec![3])
        .unwrap_err();
    assert_eq!(rej.reject_message, "guard2 failed");
    let _res = pic
        .update_call(canister_id, sender, "with_guards", vec![15])
        .unwrap();

    // The entry-point expects an `opt nat32` value.
    // Here we send some blob that decoder need to skip.
    // The call is expected to:
    // * succeed: when the blob is relatively small
    // * fail: when the blob is too large
    let _: () = update(
        &pic,
        canister_id,
        "default_skipping_quota",
        (vec![42; 1400],),
    )
    .unwrap();
    let res: Result<(), _> = update(
        &pic,
        canister_id,
        "default_skipping_quota",
        (vec![42; 1500],),
    );
    assert!(res
        .unwrap_err()
        .reject_message
        .contains("Skipping cost exceeds the limit"));
}



================================================
FILE: e2e-tests/tests/management_canister.rs
================================================
mod test_utilities;
use test_utilities::{cargo_build_canister, pic_base, update};

#[test]
fn test_management_canister() {
    let wasm = cargo_build_canister("management_canister");
    let pic = pic_base().with_ii_subnet().build();

    let canister_id = pic.create_canister();
    let subnet_id = pic.get_subnet(canister_id).unwrap();
    pic.add_cycles(canister_id, 10_000_000_000_000u128); // 10 T
    pic.install_canister(canister_id, wasm.clone(), vec![], None);
    let () = update(&pic, canister_id, "basic", ()).unwrap();
    let () = update(&pic, canister_id, "ecdsa", ()).unwrap();
    let () = update(&pic, canister_id, "schnorr", ()).unwrap();
    let () = update(&pic, canister_id, "metrics", (subnet_id,)).unwrap();
    let () = update(&pic, canister_id, "subnet", (subnet_id,)).unwrap();
    let () = update(&pic, canister_id, "snapshots", ()).unwrap();

    // Install the test canister on the II subnet, so that it can provisional create canisters on the same subnet.
    let ii_subnet_id = pic.topology().get_ii().unwrap();
    let canister_id_on_ii = pic.create_canister_on_subnet(None, None, ii_subnet_id);
    pic.add_cycles(canister_id_on_ii, 10_000_000_000_000u128); // 10 T
    pic.install_canister(canister_id_on_ii, wasm, vec![], None);
    let () = update(&pic, canister_id_on_ii, "provisional", ()).unwrap();
}

#[test]
fn test_env_var() {
    let wasm = cargo_build_canister("management_canister");
    let pic = pic_base()
        // env_var is not available on mainnet yet
        .with_nonmainnet_features(true)
        .build();

    let canister_id = pic.create_canister();
    pic.add_cycles(canister_id, 10_000_000_000_000u128); // 10 T
    pic.install_canister(canister_id, wasm, vec![], None);
    let () = update(&pic, canister_id, "env_var", ()).unwrap();
}

#[test]
fn test_vetkd() {
    let wasm = cargo_build_canister("management_canister");
    let pic = pic_base()
        .with_ii_subnet()
        // vetKD is not available on mainnet yet
        .with_nonmainnet_features(true)
        .build();

    let canister_id = pic.create_canister();
    pic.add_cycles(canister_id, 10_000_000_000_000u128); // 10 T
    pic.install_canister(canister_id, wasm, vec![], None);

    const VETKD_TRANSPORT_SECRET_KEY_SEED: [u8; 32] = [13; 32];
    let transport_key =
        ic_vetkd_utils::TransportSecretKey::from_seed(VETKD_TRANSPORT_SECRET_KEY_SEED.to_vec())
            .expect("Failed to generate transport secret key");
    let transport_public_key = transport_key.public_key();

    let () = update(&pic, canister_id, "vetkd", (transport_public_key,)).unwrap();
}



================================================
FILE: e2e-tests/tests/simple_kv_store.rs
================================================
use pocket_ic::query_candid;
use serde_bytes::ByteBuf;

mod test_utilities;
use test_utilities::{cargo_build_canister, pic_base, update};

/// Checks that a canister that uses [`ic_cdk::storage::stable_save`]
/// and [`ic_cdk::storage::stable_restore`] functions can keep its data
/// across upgrades.
#[test]
fn test_storage_roundtrip() {
    let wasm = cargo_build_canister("simple_kv_store");
    let pic = pic_base().build();
    let canister_id = pic.create_canister();
    pic.add_cycles(canister_id, 2_000_000_000_000);
    pic.install_canister(canister_id, wasm.clone(), vec![], None);

    let () = update(&pic, canister_id, "insert", (&"candid", &b"did"))
        .expect("failed to insert 'candid'");

    pic.upgrade_canister(canister_id, wasm, vec![], None)
        .expect("failed to upgrade the simple_kv_store canister");

    let (result,): (Option<ByteBuf>,) =
        query_candid(&pic, canister_id, "lookup", (&"candid",)).expect("failed to lookup 'candid'");
    assert_eq!(result, Some(ByteBuf::from(b"did".to_vec())));
}



================================================
FILE: e2e-tests/tests/test_utilities.rs
================================================
use candid::utils::{ArgumentDecoder, ArgumentEncoder};
use candid::Principal;
use cargo_metadata::MetadataCommand;
use pocket_ic::common::rest::RawEffectivePrincipal;
use pocket_ic::{call_candid, PocketIc, PocketIcBuilder, RejectResponse};
use std::path::PathBuf;
use std::process::{Command, Stdio};
use std::sync::Once;

/// Builds a canister with the specified name from the current
/// package and returns the WebAssembly module.
pub fn cargo_build_canister(bin_name: &str) -> Vec<u8> {
    static LOG_INIT: Once = Once::new();
    LOG_INIT.call_once(env_logger::init);
    let dir = PathBuf::from(std::env::var("CARGO_MANIFEST_DIR").unwrap());

    let cargo_toml_path = dir.join("Cargo.toml");

    let target_dir = MetadataCommand::new()
        .manifest_path(&cargo_toml_path)
        .no_deps()
        .exec()
        .expect("failed to run cargo metadata")
        .target_directory;

    // We use a different target path to stop the native cargo build
    // cache being invalidated every time we run this function
    let wasm_target_dir = target_dir.join("canister-build");

    let mut cmd = Command::new("cargo");
    let target = match std::env::var("WASM64") {
        Ok(_) => {
            cmd.args([
                "+nightly-2025-05-09", // 1.88.0
                "build",
                "-Z",
                "build-std=std,panic_abort",
                "--target",
                "wasm64-unknown-unknown",
            ]);
            "wasm64-unknown-unknown"
        }
        Err(_) => {
            cmd.args(["build", "--target", "wasm32-unknown-unknown"]);
            "wasm32-unknown-unknown"
        }
    };

    let cmd = cmd
        .args([
            "--bin",
            bin_name,
            "--profile",
            "canister-release",
            "--manifest-path",
            &cargo_toml_path.to_string_lossy(),
            "--target-dir",
            wasm_target_dir.as_ref(),
        ])
        .stdout(Stdio::inherit())
        .stderr(Stdio::inherit());

    let output = cmd.output().expect("failed to locate cargo");
    assert!(output.status.success(), "failed to compile the wasm binary");

    let wasm_path = wasm_target_dir
        .join(target)
        .join("canister-release")
        .join(bin_name)
        .with_extension("wasm");

    std::fs::read(&wasm_path).unwrap_or_else(|e| {
        panic!(
            "failed to read compiled Wasm file from {:?}: {}",
            &wasm_path, e
        )
    })
}

// The linter complains "function `update` is never used"
// because not EVERY test uses this function.
pub fn update<Input, Output>(
    env: &PocketIc,
    canister_id: Principal,
    method: &str,
    input: Input,
) -> Result<Output, RejectResponse>
where
    Input: ArgumentEncoder,
    Output: for<'a> ArgumentDecoder<'a>,
{
    call_candid(env, canister_id, RawEffectivePrincipal::None, method, input)
}

/// Creates a PocketIcBuilder with the base configuration for e2e tests.
///
/// The PocketIc server binary is cached for reuse.
pub fn pic_base() -> PocketIcBuilder {
    let pocket_ic_server = check_pocket_ic_server();
    PocketIcBuilder::new()
        .with_server_binary(pocket_ic_server)
        .with_application_subnet()
}

fn check_pocket_ic_server() -> PathBuf {
    let dir = PathBuf::from(std::env::var("CARGO_MANIFEST_DIR").unwrap());
    let cargo_toml_path = dir.join("Cargo.toml");
    let metadata = MetadataCommand::new()
        .manifest_path(&cargo_toml_path)
        .exec()
        .expect("failed to run cargo metadata");
    let e2e_tests_package = metadata
        .packages
        .iter()
        .find(|m| m.name.as_ref() == "ic-cdk-e2e-tests")
        .expect("ic-cdk-e2e-tests not found in Cargo.toml");
    let pocket_ic_tag = e2e_tests_package
        .dependencies
        .iter()
        .find(|d| d.name == "pocket-ic")
        .expect("pocket-ic not found in Cargo.toml")
        .source
        .as_ref()
        .expect("pocket-ic source not found in Cargo.toml")
        .repr
        .split_once("tag=")
        .expect("`tag=` not found in pocket-ic source")
        .1;
    let target_dir = metadata.target_directory;
    let artifact_dir = target_dir.join("e2e-tests-artifacts");
    let tag_path = artifact_dir.join("pocket-ic-tag");
    let server_binary_path = artifact_dir.join("pocket-ic");
    if let Ok(tag) = std::fs::read_to_string(&tag_path) {
        if tag == pocket_ic_tag && server_binary_path.exists() {
            return server_binary_path.into();
        }
    }
    panic!("pocket-ic server not found or tag mismatch, please run `scripts/download_pocket_ic_server.sh` in the project root");
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_pocket_ic() {
        let _pic = pic_base();
    }

    #[test]
    fn test_update() {
        let pic = pic_base().build();
        let canister_id = pic.create_canister();
        pic.add_cycles(canister_id, 2_000_000_000_000);
        pic.install_canister(
            canister_id,
            b"\x00asm\x01\x00\x00\x00".to_vec(),
            vec![],
            None,
        );
        assert!(update::<(), ()>(&pic, canister_id, "insert", ()).is_err());
    }
}



================================================
FILE: e2e-tests/tests/timers.rs
================================================
use pocket_ic::{query_candid, PocketIc};
use std::time::Duration;

mod test_utilities;
use test_utilities::{cargo_build_canister, pic_base, update};

#[test]
fn test_timers() {
    let wasm = cargo_build_canister("timers");
    let pic = pic_base().build();
    let canister_id = pic.create_canister();
    pic.add_cycles(canister_id, 2_000_000_000_000);
    pic.install_canister(canister_id, wasm, vec![], None);

    update::<(), ()>(&pic, canister_id, "schedule", ()).expect("Failed to call schedule");
    advance_seconds(&pic, 5);

    update::<_, ()>(&pic, canister_id, "schedule_long", ()).expect("Failed to call schedule_long");
    advance_seconds(&pic, 5);
    update::<_, ()>(&pic, canister_id, "cancel_long", ()).expect("Failed to call cancel_long");
    advance_seconds(&pic, 5);
    update::<_, ()>(&pic, canister_id, "start_repeating", ())
        .expect("Failed to call start_repeating");
    advance_seconds(&pic, 3);
    update::<_, ()>(&pic, canister_id, "stop_repeating", ())
        .expect("Failed to call stop_repeating");
    advance_seconds(&pic, 2);

    let (events,): (Vec<String>,) =
        query_candid(&pic, canister_id, "get_events", ()).expect("Failed to call get_events");
    assert_eq!(
        events[..],
        ["1", "2", "3", "4", "repeat", "repeat", "repeat"]
    );
}

#[test]
fn test_timers_can_cancel_themselves() {
    let pic = pic_base().build();
    let wasm = cargo_build_canister("timers");
    let canister_id = pic.create_canister();
    pic.add_cycles(canister_id, 2_000_000_000_000);
    pic.install_canister(canister_id, wasm, vec![], None);

    update::<_, ()>(&pic, canister_id, "set_self_cancelling_timer", ())
        .expect("Failed to call set_self_cancelling_timer");
    update::<_, ()>(&pic, canister_id, "set_self_cancelling_periodic_timer", ())
        .expect("Failed to call set_self_cancelling_periodic_timer");

    advance_seconds(&pic, 1);

    let (events,): (Vec<String>,) =
        query_candid(&pic, canister_id, "get_events", ()).expect("Failed to call get_events");
    assert_eq!(
        events,
        ["timer cancelled self", "periodic timer cancelled self"]
    );
}

#[test]
fn test_scheduling_many_timers() {
    let wasm = cargo_build_canister("timers");
    // Must be more than the queue limit (500)
    let timers_to_schedule = 1_000;
    let pic = pic_base().build();
    let canister_id = pic.create_canister();
    pic.add_cycles(canister_id, 100_000_000_000_000u128);
    pic.install_canister(canister_id, wasm, vec![], None);

    let () = update(
        &pic,
        canister_id,
        "schedule_n_timers",
        (timers_to_schedule,),
    )
    .expect("Error calling schedule_n_timers");

    // Up to 20 timers will be executed per round
    // Be conservative that advance 2 times the minimum number of rounds
    const TIMERS_PER_ROUND: u32 = 20;
    advance_seconds(&pic, 2 * timers_to_schedule / TIMERS_PER_ROUND);

    let (executed_timers,): (u32,) = query_candid(&pic, canister_id, "executed_timers", ())
        .expect("Error querying executed_timers");

    assert_eq!(timers_to_schedule, executed_timers);
}

fn advance_seconds(pic: &PocketIc, seconds: u32) {
    for _ in 0..seconds {
        pic.advance_time(Duration::from_secs(1));
        pic.tick();
    }
}

#[test]
fn test_set_global_timers() {
    let wasm = cargo_build_canister("timers");
    let pic = pic_base().build();

    let canister_id = pic.create_canister();
    pic.add_cycles(canister_id, 2_000_000_000_000);
    pic.install_canister(canister_id, wasm, vec![], None);

    // Set a 9s timer at t0, it expires at t1 = t0 + 9s
    let t0 = pic.get_time().as_nanos_since_unix_epoch();
    let t1 = t0 + 9_000_000_000;
    update::<_, ()>(&pic, canister_id, "schedule_long", ()).expect("Failed to call schedule_long");

    // 5 seconds later, the 9s timer is still active
    advance_seconds(&pic, 5);

    // Set the expiration time of the timer to t2 = t1 + 5s
    let t2 = t1 + 5_000_000_000;
    let (previous,) =
        update::<(u64,), (u64,)>(&pic, canister_id, "global_timer_set", (t2,)).unwrap();
    assert!(previous.abs_diff(t1) < 2); // time error no more than 1 nanosecond

    // Deactivate the timer
    let (previous,) =
        update::<(u64,), (u64,)>(&pic, canister_id, "global_timer_set", (0,)).unwrap();
    assert!(previous.abs_diff(t2) < 2); // time error no more than 1 nanosecond
}

#[test]
fn test_async_timers() {
    let wasm = cargo_build_canister("timers");
    let pic = pic_base().build();

    let canister_id = pic.create_canister();
    pic.add_cycles(canister_id, 2_000_000_000_000);
    pic.install_canister(canister_id, wasm, vec![], None);

    update::<(), ()>(&pic, canister_id, "async_await", ()).unwrap();
    advance_seconds(&pic, 5);

    let (events,): (Vec<String>,) =
        query_candid(&pic, canister_id, "get_events", ()).expect("Failed to call get_events");
    assert_eq!(events.len(), 8);
    assert_eq!(events[..4], ["0", "1", "method outer", "2",]);
    assert_eq!(
        events[4..]
            .iter()
            .filter(|e| *e == "method spawned")
            .count(),
        1
    );
    assert_eq!(
        events[4..]
            .iter()
            .filter(|e| *e == "method concurrent")
            .count(),
        3
    );
}



================================================
FILE: ic-cdk/README.md
================================================
[![Documentation](https://docs.rs/ic-cdk/badge.svg)](https://docs.rs/ic-cdk/)
[![Crates.io](https://img.shields.io/crates/v/ic-cdk.svg)](https://crates.io/crates/ic-cdk)
[![License](https://img.shields.io/crates/l/ic-cdk.svg)](https://github.com/dfinity/cdk-rs/blob/main/LICENSE)
[![Downloads](https://img.shields.io/crates/d/ic-cdk.svg)](https://crates.io/crates/ic-cdk)
[![CI](https://github.com/dfinity/cdk-rs/actions/workflows/ci.yml/badge.svg)](https://github.com/dfinity/cdk-rs/actions/workflows/ci.yml)

# ic-cdk

Canister Developer Kit for the Internet Computer.

## Background

On the Internet Computer, smart contracts come in the form of canisters which are WebAssembly modules.

Canisters expose entry points which can be called both by other canisters and by parties external to the IC.

This library aims to provide a Rust-ergonomic abstraction to implement Canister entry points.

## Getting Started

In Cargo.toml:

```toml
[lib]
crate-type = ["cdylib"]

[dependencies]
ic-cdk = "0.18"
candid = "0.10" # required if you want to define Candid data types
```

Then in Rust source code:

```rust
#[ic_cdk::query]
fn hello() -> String {
    "world".to_string()
}
```

This will register a **query** entry point named `hello`.

## Compilation

### Stable Target: `wasm32-unknown-unknown`

```sh
cargo build --target wasm32-unknown-unknown
```

### Experimental Target: `wasm64-unknown-unknown`

No changes to the source code are required. However, setting up the Rust toolchain for Wasm64 support requires some additional steps.

1. Install nightly toolchain: 
```bash
rustup toolchain install nightly
```
2. Add rust-src component:
```bash
rustup component add rust-src --toolchain nightly
```
3. Build with necessary flags:
```bash
cargo +nightly build -Z build-std=std,panic_abort --target wasm64-unknown-unknown
```

## Macros

This library re-exports macros defined in `ic-cdk-macros` crate.

The macros fall into two categories:

* To register functions as canister entry points
* To export Candid definitions

### Register functions as canister entry points

These macros are directly related to the [Internet Computer Specification](https://internetcomputer.org/docs/current/references/ic-interface-spec#entry-points).

* [`init`](https://docs.rs/ic-cdk/latest/ic_cdk/attr.init.html)
* [`pre_upgrade`](https://docs.rs/ic-cdk/latest/ic_cdk/attr.pre_upgrade.html)
* [`post_upgrade`](https://docs.rs/ic-cdk/latest/ic_cdk/attr.post_upgrade.html)
* [`inspect_message`](https://docs.rs/ic-cdk/latest/ic_cdk/attr.inspect_message.html)
* [`heartbeat`](https://docs.rs/ic-cdk/latest/ic_cdk/attr.heartbeat.html)
* [`on_low_wasm_memory`](https://docs.rs/ic-cdk/latest/ic_cdk/attr.on_low_wasm_memory.html)
* [`update`](https://docs.rs/ic-cdk/latest/ic_cdk/attr.update.html)
* [`query`](https://docs.rs/ic-cdk/latest/ic_cdk/attr.query.html)

Canister entry points can be `async`. The CDK embeds an asynchronous executor. Unfortunately anything `tokio`-specific cannot be used.
Use the [`spawn`](https://docs.rs/ic-cdk/latest/ic_cdk/futures/fn.spawn.html) function to run more asynchronous functions in
the background. Panics can cause async tasks to cancel partway through; read the documentation for the 
[`futures`](https://docs.rs/ic-cdk/latest/ic_cdk/futures/index.html) module for more information.

### Export Candid definitions

* [`export_candid`](https://docs.rs/ic-cdk/latest/ic_cdk/macro.export_candid.html)

Check [Generating Candid files for Rust canisters](https://internetcomputer.org/docs/current/developer-docs/backend/candid/generating-candid/) for more details.

## More examples

The [examples repository](https://github.com/dfinity/examples/tree/master/rust) offers numerous Rust examples demonstrating how to build functional Rust canisters.

## Manage Data Structures in Stable Memory

For managing larger datasets and multiple data structures in stable memory, consider using the [`ic-stable-structures`](https://crates.io/crates/ic-stable-structures) crate. While the `ic_cdk::storage::{stable_save, stable_restore}` API is straightforward, it may not be efficient for larger datasets. The `ic-stable-structures` crate provides more scalable solutions for such scenarios.



================================================
FILE: ic-cdk/Cargo.toml
================================================
[package]
name = "ic-cdk"
version = "0.19.0-beta.3"                                                            # sync with ic-cdk-macros and the doc comment in README.md
authors.workspace = true
edition.workspace = true
license.workspace = true
rust-version.workspace = true
repository.workspace = true
description = "Canister Developer Kit for the Internet Computer."
homepage = "https://docs.rs/ic-cdk"
documentation = "https://docs.rs/ic-cdk"
readme = "README.md"
categories = ["api-bindings", "data-structures", "no-std", "development-tools::ffi"]
keywords = ["internet-computer", "types", "dfinity", "canister", "cdk"]
include = ["src", "Cargo.toml", "LICENSE", "README.md"]

[dependencies]
candid.workspace = true
ic0.workspace = true
ic-cdk-executor.workspace = true
# Pin ic-cdk-macros to a specific version.
# This actually create a 1-to-1 mapping between ic-cdk and ic-cdk-macros.
# Dependents won't accidentaly upgrading ic-cdk-macros only but not ic-cdk.
# ic-cdk-macros is a hidden dependency, re-exported by ic-cdk.
# It should not be included by users direcly.
ic-cdk-macros = { path = "../ic-cdk-macros", version = "=0.19.0-beta.3" }
ic-error-types = "0.2.0"
ic-management-canister-types.workspace = true
pin-project-lite = "0.2.16"
serde.workspace = true
serde_bytes.workspace = true
slotmap.workspace = true
thiserror.workspace = true

[dev-dependencies]
anyhow = "1"
candid_parser.workspace = true
futures = "0.3"
rstest = "0.12.0"
trybuild = "1.0"

[features]
transform-closure = []

[package.metadata.docs.rs]
features = ["transform-closure"]
default-target = "wasm32-unknown-unknown"
rustdoc-args = ["--cfg=docsrs"]



================================================
FILE: ic-cdk/CHANGELOG.md
================================================
# Changelog
All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [unreleased]

## [0.19.0-beta.3] - 2025-10-09

### Added

- Support Canister Environment Variable. (#636)
  - Add binding for `env_var_*` API.

### Changed

- [BREAKING] Updated to version 2.0 of the async executor. The `spawn` function now creates protected tasks that panic (or are canceled, with `spawn_weak`) if they outlive the canister method (with a new `spawn_migratory` function for tasks that are supposed to outlive the method). A trap will now cancel all protected tasks in the method it is part of. See the [module docs](https://docs.rs/ic-cdk/0.19.0/ic_cdk/futures/index.html) for more information.
  - The async machinery that is primarily used from macros (i.e. `in_*_context`) has been moved to `ic_cdk::futures::internals`.

- [BREAKING] Upgrade `ic-management-canister-types` which contains the changes for:
  - Canister Environment Variable.
  - Non-replicated HTTP outcalls.

## [0.18.7] - 2025-08-20

### Added

- The macros annotate `#[allow(clippy::disallowed_methods)]` above the invocation of `ic_cdk::futures::spawn`.

The `ic_cdk::futures::spawn` method has a different poll order that can affect canister behavior.
While some projects may wish to enforce a `disallowed-methods` lint rule to prevent its use, the invocations generated by our macros are a false positive.
This annotation prevents the warning from being triggered for the macro-generated code, ensuring a clean linting experience for developers who adopt the new rule.

## [0.18.6] - 2025-08-19

### Added

- Restored the default `skipping_quota` to match the behavior of previous versions of the macros.

### Fixed

- The macros now support 2024 edition.

### Changed

- MSRV raised to 1.85.0.

## [0.18.5] - 2025-06-25

### Fixed

- Tasks which return after canceling futures are no longer marked as trapped

### Changed

- Updated to `ic0` v1.0.0

## [0.18.4] - 2025-06-17

### Added

- New `ic_cdk::futures` function `spawn_017_compat`. This has the code ordering behavior of 0.17, with spawned futures run immediately instead of waiting for the current code to suspend.

## [0.18.3] - 2025-06-04

### Added

- Support `root_key` API. (#619)

### Changed

- Update bitcoin `regtest` cycles cost to be same as the bitcoin `mainnet`.

  ```
  fees = record {
        get_current_fee_percentiles = 10_000_000 : nat;
        get_utxos_maximum = 10_000_000_000 : nat;
        get_block_headers_cycles_per_ten_instructions = 10 : nat;
        get_current_fee_percentiles_maximum = 100_000_000 : nat;
        send_transaction_per_byte = 20_000_000 : nat;
        get_balance = 10_000_000 : nat;
        get_utxos_cycles_per_ten_instructions = 10 : nat;
        get_block_headers_base = 50_000_000 : nat;
        get_utxos_base = 50_000_000 : nat;
        get_balance_maximum = 100_000_000 : nat;
        send_transaction_base = 5_000_000_000 : nat;
        get_block_headers_maximum = 10_000_000_000 : nat;
      };
  ```

  You can get the fees by `get_config` API on the [BTC Mainnet Canister](https://dashboard.internetcomputer.org/canister/ghsi2-tqaaa-aaaan-aaaca-cai).

## [0.18.2] - 2025-05-14

### Added

- New CDK library `ic-cdk-executor` containing the low-level async executor primitives previously in `ic-cdk`. Most users will never need to use this library and should continue using the interface from `ic-cdk`.

### Changed

- Bump `ic-error-types` to v0.2.0 from which we re-export the `RejectCode` type.

## [0.18.1] - 2025-05-09

### Added

- Support VetKD management canister API. (#597)
- Add `Call::take_raw_args` which owns the bytes. (#601)

## [0.18.0] - 2025-04-22

Please check [Version 0.18 Guide](V18_GUIDE.md) for more details.

### Added

- New `Call` API.
  - Supports bounded-wait inter-canister calls.
  - Uses a builder pattern for optional call configuration.
  - Allows chaining `.candid()` decoding only when needed.
  - Provides ergonomic Rust error handling to encourage best practices.
- Support for Wasm64 module compilation.
  - Seamlessly handles 32-bit and 64-bit System APIs.
- Enhanced macros for flexible argument decoding and result encoding.
  - `update`/`query`/`init` macros now support custom argument decoders via `decode_with`.
  - `update`/`query` macros now support custom result encoders via `encode_with`.
- Simplified module hierarchy with one level under the crate root.
  - `api` module offers consistent System API bindings.
  - `management_canister` module for convenient Management Canister calls.
  - `bitcoin_canister` module for direct Bitcoin Canisters calls.
- Enhanced cycles cost calculation for Management Canister API calls:
  - New system APIs exposed through the `api` module:
    - `cost_http_request`, `cost_sign_with_ecdsa`, `cost_sign_with_schnorr`, `cost_vetkd_derive_key`.
  - High-level bindings in the `management_canister` module accept call arguments by reference.
  - All relevant Management Canister methods now automatically attach the required cycles to calls.

### Changed

- Introduces a new task scheduler-based executor.
  - Capable of scheduling any async task, not limited to inter-canister calls.
  - The `futures` module is now public to expose functionalities related to the async executor.
  - The new implementation enables code to have (intended) surprising behavior - it is recommended to read the [module docs](https://docs.rs/ic-cdk/0.18.3/ic_cdk/futures/index.html)

### Deprecated

- Submodules in `api` are now deprecated in favor of root-level modules.
  - `api/call` -> `call`
  - `api/management_canister` -> `management_canister` & `bitcoin_canister`
  - `api/stable` -> `stable`

## [0.17.1] - 2024-12-19

### Added

- Add method `bitcoin_get_block_headers`.
- Support management canister method: `subnet_info`. (#532)
  - Add types: `SubnetInfoArgs` and `SubnetInfoResult`.

### Fixed

- Fix update/query macro could not handle function arguments with the same name as the function itself. (#525)

## [0.17.0] - 2024-11-04

### Changed

- Add `AllowedViewers` variant to `LogVisibility` enum. (#512)

### Added

- Attribute `#[on_low_wasm_memory]` for low-memory hook. (#528)
- Support Threshold Schnorr signing management canister API. (#518)

## [0.16.0] - 2024-08-27

### Changed

- BREAKING: Add the `LoadSnapshot` variant to `CanisterChangeDetails`. (#504)

### Added

- Support Canister State Snapshots. (#504)
  - Add methods: `take_canister_snapshot`, `load_canister_snapshot`, `list_canister_snapshots`, `delete_canister_snapshot`
  - Add types: `LoadSnapshotRecord`, `SnapshotId`, `Snapshot`, `TakeCanisterSnapshotArgs`, `LoadCanisterSnapshotArgs`, `DeleteCanisterSnapshotArgs`

## [0.15.0] - 2024-07-01

### Changed

- BREAKING: Stable Memory always use 64-bit addresses and `stable64_*` system API. (#498)
- BREAKING: Add `log_visibility` to the management canister API types: (#497)
   - `CanisterSettings`
   - `DefiniteCanisterSettings`.

## [0.14.0] - 2024-05-17
## [0.13.3] - 2024-05-10 (yanked)

### Added

- Provide safe wrapper of `in_replicated_execution` in ic-cdk. (#489)

### Changed

- Upgrade `ic0` to v0.23.0. (#489)
- BREAKING: Add `wasm_memory_limit` to the management canister API types: (#483)
   - `CanisterSettings`
   - `DefiniteCanisterSettings`.

## [0.13.2] - 2024-04-08

### Added

- Management canister methods for interacting with the chunk store. (#461)
- Provide safe wrapper of `global_timer_set` in ic-cdk. (#475)

## [0.13.1] - 2024-03-01

### Changed

- Upgrade `ic-cdk-macros` to v0.9.0.

## [0.13.0] - 2024-03-01 (yanked)

### Added

- Add `is_recovering_from_trap` function for implementing trap cleanup logic. (#456)
- Allow setting decoding quota for canister entry points and inter-canister calls. (#465)
  * When defining canister entry points, we add the following attributes: `#[update(decoding_quota = 10000, skipping_quota = 100, debug = true)]`
    - `skipping_quota` limits the amount of work allowed for skipping unneeded data on the wire. If this attributes is not present, we set a default quota of `10_000`. This affects ALL existing canisters, and is mainly used to improve canister throughput. See [docs on the Candid library](https://docs.rs/candid/latest/candid/de/struct.DecoderConfig.html#method.set_skipping_quota) to understand the skipping cost.
    - `decoding_quota` limits the total amount of work the deserializer can perform. See [docs on the Candid library](https://docs.rs/candid/latest/candid/de/struct.DecoderConfig.html#method.set_decoding_quota) to understand the cost model.
    - `debug = true` prints the instruction count and the decoding/skipping cost to the replica log, after a successful deserialization. The decoding/skipping cost is logged only when you have already set a quota in the attributes. The debug mode is useful to determine the right quotas above. Developers can send a few large payloads to the debugging entry point and know the actual decoding cost.
  * When making inter-canister calls, we have a new function `call_with_config` to config the same decoding quotas described above. It's strongly recommended to use `call_with_config` when calling third-party untrusted canisters.

### Changed

- `ic_cdk::api::call::arg_data` takes `ArgDecoderConfig` as argument. (#465)

## [0.12.1] - 2024-01-12

### Changed

- Add "reserved cycles" fields to the management canister API: (#449)
  - `reserved_cycles` to `CanisterStatusResponse`
  - `reserved_cycles_limit` to `CanisterSettings` and `DefiniteCanisterSettings`

### Fixed

- The README file is now more informative and used as the front page of the doc site.
- The `call*` methods are documented with examples and notes.

## [0.12.0] - 2023-11-23

### Changed

- Upgrade `candid` to `0.10`. (#448)

## [0.11.4] - 2023-11-20

### Added

- `query_stats` in `canister_status` response. (#432)
  
## [0.11.3] - 2023-10-12

### Added

- Another type of performance counter: "call context instruction counter".
  Can be fetched using either method below: (#435)
  - `ic_cdk::api::performance_counter(1)`;
  - `ic_cdk::api::call_context_instruction_counter()` as a shorthand;

### Changed

- Deprecate `ic_cdk::api::call::performance_counter()` in favor of `ic_cdk::api::performance_counter()`. (#435)

## [0.11.2] - 2023-10-11

### Added

- `cycles_burn` corresponding to system API `ic0.cycles_burn128`. (#434)

### Changed

- Upgrade `ic0` to `0.21.1`. (#434)

## [0.11.1] - 2023-10-11

### Changed

- Upgrade `ic0` to `0.21.0`. (#433)

## [0.11.0] - 2023-09-18

### Changed

- Candid Export workflow is changed. (#424)
  * No need to compile for WASI separately.
  * Canisters should still invoke `ic_cdk::export_candid!()` to export candid.
  * Then use [`candid-extractor`](../candid-extractor/) to extract candid from the canister WASM.

## [0.10.0] - 2023-07-13

### Changed

- Upgrade `candid` to `0.9`. (#411)
- Remove `export` module. Please use candid directly in your project instead of using `ic_cdk::export::candid`.
- Remove `ic_cdk_macro::import` module. See below for a new way to import canisters.

### Added

- Export Candid: (#386)
  * A wasi feature that builds the canister as a standalone WASI binary. Running the binary in wasmtime outputs the canister interface
  * Build step:
  ```
  cargo build --target wasm32-unknown-unknown \
      --release \
      --package "$package" --features "ic-cdk/wasi"

  wasmtime "target/wasm32-unknown-unknown/release/$package.wasm" > $did_file

  cargo build --target wasm32-unknown-unknown \
      --release \
      --package "$package"

  ic-wasm "target/wasm32-unknown-unknown/release/$package.wasm" \
      -o "target/wasm32-unknown-unknown/release/$package.wasm" \
      metadata candid:service -v public -f $did_file
  ```
  * In the canister code, users have to add `ic_cdk::export_candid!()` at the end of `lib.rs`. In the future we may lift this requirement to provide a better DX.

- Import Candid: (#390)

  * Canister project adds `ic_cdk_bindgen` as a build dependency to generate canister bindings
  * build.rs
  ```
  use ic_cdk_bindgen::{Builder, Config};
  fn main() {
      let counter = Config::new("counter");
      let mut builder = Builder::new();
      builder.add(counter);
      builder.build(None);  // default write to src/declarations
  }
  ```
  * In the canister code,
  ```
  mod declarations;
  use declarations::counter::counter;

  counter.inc().await?
  ```

## [0.9.2] - 2023-06-22

### Changed

- Hardcodes the fee for `sign_with_ecdsa`. (#407)

## [0.9.1] - 2023-06-21 (yanked)

### Changed

- Bitcoin API handles cycles cost under the hood. (#406)

## [0.9.0] - 2023-06-20 (yanked)

### Added

- Set caller's canister version in the field `sender_canister_version` of management canister call payloads. (#401)
- Add management canister types for `canister_info` management canister call (`CanisterInfoRequest` and `CanisterInfoResponse`). (#401)

### Changed

- No hard-coded fees for management canister calls. (#404)

## [0.8.0] - 2023-05-26

### Added

- `ic0.is_controller` as a public function. (#383)

### Changed

- `TransformContext::new` has been replaced with dedicated functions that accept closures. (#385)
- `CallFuture` only makes an inter-canister call if it is awaited. (#391)

## [0.7.4] - 2023-03-21

### Added

- `WASM_PAGE_SIZE_IN_BYTES` made `pub`. (#380)
- `http_request_with_cycles`. (#381)

## [0.7.3] - 2023-03-01

### Fixed

- Addressed a compatibility error in the signature of the `call` family of functions. (#379)

## [0.7.2] - 2023-03-01

### Fixed

- Fix type name in error message when a deserialization error occurs after making a canister-to-canister call. (#355)

## [0.7.1] - 2023-02-22

### Fixed

- Update document for http_request. (#372)

## [0.7.0] - 2023-02-03

### Changed

- The timers API is not a feature anymore, it moved into a separate library, `ic-cdk-timers`. (#368)

## [0.6.10] - 2023-01-20

### Added

- Added `ic0.canister_version` as a public function. (#350)

## [0.6.9] - 2023-01-18

### Fixed

- Allow timers to cancel themselves. (#360)

### Refactored

- Change from pleco to tanton for the chess library in the chess example. (#345)
- Refactor the executor to prevent a double-free on `join_all`. (#357)

## [0.6.8] - 2022-11-28

### Added

- Added composite queries via `#[query(composite = true)]`. (#344)

  Composite queries cannot be run as update calls, but can make inter-canister calls to other query functions.

- Implemented the canister timers API, located in module `ic_cdk::timer`. (#342)

## [0.6.7] - 2022-11-16

### Changed

- Improve error message on trap while decoding arguments. (#339)

## [0.6.6] - 2022-11-09

### Added

- Added `StableIO` to implement both `io::Write` and `io::Read` for stable memory. (#335)
- Added 64-bit support for `io::Write` and `io::Read` via `StableIO`.
- Implement `io::Seek` for stable storage.

### Changed

-  `StableWriter` and `StableReader` are now wrappers around `StableIO`.

## [0.6.5] - 2022-11-04

### Changed

BREAKING CHANGE of experimental API:
- `http_request` to support `context` field in callback function. (#326)

## [0.6.4] - 2022-10-28

### Added

- Expose `offset` of `StableReader` and `StableWriter`. (#330)

## [0.6.3] - 2022-10-26

### Fixed

- Doc can build on docs.rs. (#327)

## [0.6.2] - 2022-10-24

### Refactored

- Separate `ic0` crate for system API. (#324)

## [0.6.1] - 2022-10-14

### Added

- `create_canister_with_extra_cycles` to specify cycles when create canister (#322)

### Fixed

- `create_canister` should charge 0.1T cycles (#322)

## [0.6.0] - 2022-10-03

### Changed

- Upgrade `candid` to `0.8.0` (#321)

## [0.5.7] - 2022-09-27

### Fixed
- Overhaul management canister, especially `transform` type in `http_request`  (#312)

## [0.5.6] - 2022-08-10

### Added
- New `ic_cdk::api::management_canister` module for calling the IC management canister (#295)
- Derive common traits for `RejectionCode` (#294)
- `ManualReply::reject` function (#297)

### Fixed
- Failure to decode the reply in `ic_cdk::call` does not trap anymore (#301)

## [0.5.5] - 2022-07-22

### Added
- Derive `CandidType` and `Deserialize` for `RejectionCode` (#291, #293)

## [0.5.3] - 2022-07-19

### Added
- `instruction_counter` function as a shorthand for `performance_counter(0)` (#283)

### Changed
- Make `CanisterStableMemory` public (#281)
- BREAKING CHANGE: move performance_counter from the `ic_cdk::api::call` to `ic_cdk::api` module (#283)

### Fixed
- Outdated documentation for `ManualReply` (#286)

## [0.5.2] - 2022-06-23
### Added
- `arg_data_raw_size` for checking the size of the arg-data-raw before copying to a vector or deserializing (#263)
- `performance_counter` for getting the value of specified performance counter (#277)

### Fixed
- Use explicitly type u8 in vector initialization (#264)
- Make `reply_raw` avoid writing empty replies
- Uses new format for candid environment variables in import macros. Requires DFX >=0.9.2 (#270)

## [0.5.1] - 2022-05-16
### Added
- `BufferedStableReader` for efficient reading from stable memory (#247)
- `BufferedStableWriter` for efficient writing to stable memory (#245)
- `reply_raw` and publish `arg_data_raw` for serialization-agnostic arguments fetching and replies (#256)
- Support for one-way calls (see `notify` and `notify_raw` functions) (#261)

### Fixed
- Panicking after `.await` does not leak resources anymore (#232, #250)

## [0.5.0] - 2022-03-29
### Added
- Update canister calling API for 128-bit cycles (#228)

### Changed
- Take slice rather than owned Vec as input arg (#217)
- Remove non-stable storage API (#215)
- Allow configuring export macros to not reply (#210)
- Add Clone and Copy to RejectionCode (#202)

### Fixed
- Do not call done() in stable_restore() (#216)
- Remove out-of-bounds vulnerability (#208)
- Run inter-canister calls without awaiting (#233)

## [0.4.0] - 2022-01-26
### Changed
- `candid` is required to be included in `[dependencies]` to use the `#[import]` macro  (#190)
- Deprecate block_on in favour of the new spawn function (#189)
- Trap in setup panic hook (#172)

## [0.3.3] - 2021-11-17
### Added
- Update system API for 128 bit cycles (#167)

## [0.3.2] - 2021-09-16
### Added
- Add support for 64 bit stable memory (#137)
- Add support for 'heartbeat' and 'inspect_message' (#129)



================================================
FILE: ic-cdk/V18_GUIDE.md
================================================
# Version 0.18 Guide

## Introduction

`ic-cdk` v0.18 introduces many new features and changes that improve the developer experience.
This guide covers the major features and changes and provides migration guidance for code written with version 0.17 or earlier.

### How to Upgrade

Update `Cargo.toml`:
```toml
[dependencies]
ic-cdk = "0.18.0"
```

## Features

### New `Call` API

This version introduces a revamped API for inter-canister calls, utilizing a builder pattern for flexible call configuration and execution.

```rust
use ic_cdk::call::Call;
let id : Principal =...;
let method : &str =...;
let res: u32 = Call::bounded_wait(id, method) // Choose the "bounded-wait" constructor
    .with_arg(42)                             // Specify Candid argument
    .with_cycles(1000)                        // Attach cycles
    .await?                                   // Execute the call by awaiting it
    .candid()?;                               // Decode the response bytes as Candid value
```

Please check the [docs](https://docs.rs/ic-cdk/0.18.0/ic_cdk/call/struct.Call.html) for more details.

#### Migration

The functions for inter-canister calls in the `ic_cdk::api::call` module are deprecated in favor of the new `Call` API. These functions were created before the introduction of the [Bounded-Wait Calls](https://internetcomputer.org/docs/references/async-code#ic-call-types) feature. To maintain the same behavior, use the `Call::unbounded_wait()` constructor. You can later evaluate if a specific call should switch to `Call::bounded_wait()`.

| Before                                             | After                                                                                    |
|----------------------------------------------------|------------------------------------------------------------------------------------------|
| `call(id, method, arg)`                            | `Call::unbounded_wait(id, method).with_arg(arg).await?.candid()?`                        |
| `call_raw(id, method, args_raw, payment)`          | `Call::unbounded_wait(id, method).with_raw_args(args_raw).with_cycles(payment).await?`   |
| `call_raw128(id, method, args_raw, payment)`       | `Call::unbounded_wait(id, method).with_raw_args(args_raw).with_cycles(payment).await?`   |
| `call_with_payment(id, method, arg, payment)`      | `Call::unbounded_wait(id, method).with_arg(arg).with_cycles(payment).await?.candid()?`   |
| `call_with_payment128(id, method, arg, payment)`   | `Call::unbounded_wait(id, method).with_arg(arg).with_cycles(payment).await?.candid()?`   |
| `call_with_config(...)`                            | `DecoderConfig` is no longer supported.                                                  |
| `notify(id, method, arg)`                          | `Call::unbounded_wait(id, method).with_arg(arg).oneway()?`                               |
| `notify_raw(id, method, args_raw, payment)`        | `Call::unbounded_wait(id, method).with_raw_args(arg_raw).with_cycles(payment).oneway()?` |
| `notify_with_payment128(id, method, arg, payment)` | `Call::unbounded_wait(id, method).with_arg(arg).with_cycles(payment).oneway()?`          |

> [!NOTE]
> Some deprecated APIs expected a tuple of Candid values as input arguments. Often, there is a single Candid value that needs to be wrapped in parentheses. Therefore, it is recommended to use the `with_arg()` method, which accepts a single `CandidType` value. Use `with_args()` when specifying a Candid tuple.
>
> Similarly, for response decoding, it is recommended to use `candid()`, which decodes to a single `CandidType`. Use `candid_tuple()` when decoding the response as a Candid tuple.

### Futures Ordering Changes

In 0.18, the execution order of `spawn` looks like this:

```rs
runs_first();
spawn(async {
	runs_third().await;
	runs_fourth();
});
runs_second();
```

In contrast, the 0.17 execution order of `spawn` looks like this:

```rs
runs_first();
spawn(async {
	runs_second().await;
	runs_fourth();
});
runs_third();
```

Please check all the places you call `spawn` to ensure that you do not depend on the code in the spawned future running before the code below the `spawn` call. Note that most `spawn` calls are the entire body of timers - if there is no code after `spawn` in the timer, the behavior has not changed.

### Wasm64 Compilation

No changes to the source code are required. However, setting up the Rust toolchain for Wasm64 support requires some additional steps.

1. Install nightly toolchain: 
```bash
rustup toolchain install nightly
```
2. Add rust-src component:
```bash
rustup component add rust-src --toolchain nightly
```
3. Build with necessary flags:
```bash
cargo +nightly build -Z build-std=std,panic_abort --target wasm64-unknown-unknown
```

### Custom Decoders/Encoders in Macros

The `update` and `query` macros now support custom argument decoders and return value encoders, while the `init` macro supports custom argument decoders only. This gives full control over how data is serialized and deserialized for canister entry points.

```rust
#[update(decode_with = "decode_args", encode_with = "encode_result")]
fn custom_serialization(a: u32, b: u32) -> (u32, u32) {
    // ...
}

// Custom decoder transforms raw bytes into the function's parameter types
fn decode_args(arg_bytes: Vec<u8>) -> (u32, u32) {
    // Custom deserialization logic here ...
}

// Custom encoder transforms the function's return value into bytes
fn encode_result(result: (u32, u32)) -> Vec<u8> {
    // Custom serialization logic here ...
}
```

It's possible to define generic custom decoders/encoders for use across multiple entry points, enabling alternative serialization formats. The example below demonstrates using Protocol Buffers instead of Candid for wire format:

```rust
use prost::Message;

#[update(decode_with = "from_proto_bytes", encode_with = "to_proto_bytes")]
fn protobuf_onwire1(a: u32) -> u32 {
    a + 42
}

#[update(decode_with = "from_proto_bytes", encode_with = "to_proto_bytes")]
fn protobuf_onwire2(a: String) -> String {
    format!("{} world!", a)
}

// Generic decoder function that works with any Protobuf message
fn from_proto_bytes<T: Message + Default>(bytes: Vec<u8>) -> T {
    T::decode(&bytes[..]).unwrap_or_default()
}

// Generic encoder function that works with any Protobuf message
fn to_proto_bytes<T: Message>(message: T) -> Vec<u8> {
    message.encode_to_vec()
}
```

Please check the [macros end-to-end test](../e2e-tests/src/bin/macros/) for more details.

### Simplified Module Structure

The module hierarchy has been flattened to improve usability and consistency:
- The `api` module provides consistent System API bindings.
- The `management_canister` module facilitates convenient Management Canister calls.
- The `bitcoin_canister` module will soon support direct Bitcoin Canister calls.

#### Migration

Submodules in `api` are now deprecated in favor of root-level modules.
- `api/call` -> `call`
- `api/management_canister` -> `management_canister` & `bitcoin_canister`
- `api/stable` -> `stable`

### Custom Exports (advanced)

For those who exported canister entry points with their own `#[export_name]` calls instead of using the attribute macros, the required boilerplate has changed:

```rs
#[unsafe(export_name = "canister_global_timer")]
pub extern "C" fn canister_global_timer() {
    ic_cdk::futures::in_executor_context(|| {
        /* code goes here */
    });
}
#[unsafe(export_name = "canister_inspect_message")]
pub extern "C" fn canister_inspect_message() {
    ic_cdk::futures::in_query_executor_context(|| {
        /* code goes here */
    })
}
```

Every entry point must encase its code in `in_executor_context` (or for query methods or inspect_message callbacks, `in_query_executor_context`). This sets the panic hook (otherwise every panic message will be `[TRAP] unreachable`) and creates the ability to call `spawn` (which will otherwise panic).

The attribute macros insert this call for you; it is only needed when exporting your own entry points. If you attempt to create a context inside another context it will panic; it is only necessary at the top level.



================================================
SYMLINK: ic-cdk/LICENSE -> LICENSE
================================================



================================================
FILE: ic-cdk/src/api.rs
================================================
//! System API bindings.
//!
//! This module provides Rust ergonomic bindings to the system APIs.
//!
//! Some APIs require more advanced handling and are organized into separate modules:
//! * For the inter-canister calls API, see the [`call`](mod@crate::call) module.
//! * For the stable memory management API, see the .
//!   * The basic bindings are provided in this module including [`stable_size`], [`stable_grow`], [`stable_read`] and [`stable_write`].
//!   * The [`stable`](crate::stable) module provides more advanced functionalities, e.g. support for `std::io` traits.
//!
//! APIs that are only available for `wasm32` are not included.
//! As a result, system APIs with a numeric postfix (indicating the data bit width) are bound to names without the postfix.
//! For example, `ic0::msg_cycles_available128` is bound to [`msg_cycles_available`], while `ic0::msg_cycles_available` has no binding.
//!
//! Functions that provide bindings for a single system API method share the same name as the system API.
//! For example, `ic0::msg_reject_code` is bound to [`msg_reject_code`].
//!
//! Functions that wrap multiple system API methods are named using the common prefix of the wrapped methods.
//! For example, [`msg_arg_data`] wraps both `ic0::msg_arg_data_size` and `ic0::msg_arg_data_copy`.

use candid::Principal;
use std::{convert::TryFrom, num::NonZeroU64};

#[deprecated(
    since = "0.18.0",
    note = "The `api::call` module is deprecated. Individual items within this module have their own deprecation notices with specific migration guidance."
)]
#[doc(hidden)]
pub mod call;
#[deprecated(
    since = "0.18.0",
    note = "The `api::management_canister` module is deprecated. Please use the `management_canister` and `bitcoin_canister` modules at the crate root."
)]
#[doc(hidden)]
pub mod management_canister;
#[deprecated(
    since = "0.18.0",
    note = "The `api::stable` module has been moved to `stable` (crate root)."
)]
#[doc(hidden)]
pub mod stable;

/// Gets the message argument data.
pub fn msg_arg_data() -> Vec<u8> {
    let len = ic0::msg_arg_data_size();
    let mut buf = vec![0u8; len];
    ic0::msg_arg_data_copy(&mut buf, 0);
    buf
}

/// Gets the identity of the caller, which may be a canister id or a user id.
///
/// During canister installation or upgrade, this is the id of the user or canister requesting the installation or upgrade.
/// During a system task (heartbeat or global timer), this is the id of the management canister.
pub fn msg_caller() -> Principal {
    let len = ic0::msg_caller_size();
    let mut buf = vec![0u8; len];
    ic0::msg_caller_copy(&mut buf, 0);
    // Trust that the system always returns a valid principal.
    Principal::try_from(&buf).unwrap()
}

/// Returns the reject code, if the current function is invoked as a reject callback.
pub fn msg_reject_code() -> u32 {
    ic0::msg_reject_code()
}

/// Gets the reject message.
///
/// This function can only be called in the reject callback.
///
/// Traps if:
/// - There is no reject message (i.e. if `reject_code` is 0).
/// - The message is not valid UTF-8.
pub fn msg_reject_msg() -> String {
    let len = ic0::msg_reject_msg_size();
    let mut buf = vec![0u8; len];
    ic0::msg_reject_msg_copy(&mut buf, 0);
    String::from_utf8(buf).expect("reject message is not valid UTF-8")
}

/// Gets the deadline, in nanoseconds since 1970-01-01, after which the caller might stop waiting for a response.
///
/// For calls to update methods with best-effort responses and their callbacks,
/// the deadline is computed based on the time the call was made,
/// and the `timeout_seconds` parameter provided by the caller.
/// In such cases, the deadline value will be converted to `NonZeroU64` and wrapped in `Some`.
/// To get the deadline value as a `u64`, call `get()` on the `NonZeroU64` value.
///
/// ```rust,no_run
/// use ic_cdk::api::msg_deadline;
/// if let Some(deadline) = msg_deadline() {
///     let deadline_value : u64 = deadline.get();
/// }
/// ```
///
/// For other calls (ingress messages and all calls to query and composite query methods,
/// including calls in replicated mode), a `None` is returned.
/// Please note that the raw `msg_deadline` system API returns 0 in such cases.
/// This function is a wrapper around the raw system API that provides more semantic information through the return type.
pub fn msg_deadline() -> Option<NonZeroU64> {
    let nano_seconds = ic0::msg_deadline();
    match nano_seconds {
        0 => None,
        _ => Some(NonZeroU64::new(nano_seconds).unwrap()),
    }
}

/// Replies to the sender with the data.
pub fn msg_reply<T: AsRef<[u8]>>(data: T) {
    let buf = data.as_ref();
    if !buf.is_empty() {
        ic0::msg_reply_data_append(buf);
    }
    ic0::msg_reply();
}

/// Rejects the call with a diagnostic message.
pub fn msg_reject<T: AsRef<str>>(message: T) {
    let message = message.as_ref();
    ic0::msg_reject(message.as_bytes());
}

/// Gets the number of cycles transferred by the caller of the current call, still available in this message.
pub fn msg_cycles_available() -> u128 {
    ic0::msg_cycles_available128()
}

/// Gets the amount of cycles that came back with the response as a refund
///
/// This function can only be used in a callback handler (reply or reject).
/// The refund has already been added to the canister balance automatically.
pub fn msg_cycles_refunded() -> u128 {
    ic0::msg_cycles_refunded128()
}

/// Moves cycles from the call to the canister balance.
///
/// The actual amount moved will be returned.
pub fn msg_cycles_accept(max_amount: u128) -> u128 {
    ic0::msg_cycles_accept128(max_amount)
}

/// Burns cycles from the canister.
///
/// Returns the amount of cycles that were actually burned.
pub fn cycles_burn(amount: u128) -> u128 {
    ic0::cycles_burn128(amount)
}

/// Gets canister's own identity.
pub fn canister_self() -> Principal {
    let len = ic0::canister_self_size();
    let mut buf = vec![0u8; len];
    ic0::canister_self_copy(&mut buf, 0);
    // Trust that the system always returns a valid principal.
    Principal::try_from(&buf).unwrap()
}

/// Gets the current cycle balance of the canister.
pub fn canister_cycle_balance() -> u128 {
    ic0::canister_cycle_balance128()
}

/// Gets the current amount of cycles that is available for spending in calls and execution.
pub fn canister_liquid_cycle_balance() -> u128 {
    ic0::canister_liquid_cycle_balance128()
}

/// Gets the status of the canister.
///
/// The status is one of the following:
/// - 1: Running
/// - 2: Stopping
/// - 3: Stopped
pub fn canister_status() -> CanisterStatusCode {
    ic0::canister_status().into()
}

/// The status of a canister.
///
/// See [Canister status](https://internetcomputer.org/docs/current/references/ic-interface-spec/#system-api-canister-status).
#[derive(Debug, PartialEq, Eq, Clone, Copy)]
#[repr(u32)]
pub enum CanisterStatusCode {
    /// Running.
    Running = 1,
    /// Stopping.
    Stopping = 2,
    /// Stopped.
    Stopped = 3,
    /// A status code that is not recognized by this library.
    Unrecognized(u32),
}

impl From<u32> for CanisterStatusCode {
    fn from(value: u32) -> Self {
        match value {
            1 => Self::Running,
            2 => Self::Stopping,
            3 => Self::Stopped,
            _ => Self::Unrecognized(value),
        }
    }
}

impl From<CanisterStatusCode> for u32 {
    fn from(value: CanisterStatusCode) -> Self {
        match value {
            CanisterStatusCode::Running => 1,
            CanisterStatusCode::Stopping => 2,
            CanisterStatusCode::Stopped => 3,
            CanisterStatusCode::Unrecognized(value) => value,
        }
    }
}

impl PartialEq<u32> for CanisterStatusCode {
    fn eq(&self, other: &u32) -> bool {
        let self_as_u32: u32 = (*self).into();
        self_as_u32 == *other
    }
}

/// Gets the canister version.
///
/// See [Canister version](https://internetcomputer.org/docs/current/references/ic-interface-spec/#system-api-canister-version).
pub fn canister_version() -> u64 {
    ic0::canister_version()
}

/// Gets the ID of the subnet on which the canister is running.
pub fn subnet_self() -> Principal {
    let len = ic0::subnet_self_size();
    let mut buf = vec![0u8; len];
    ic0::subnet_self_copy(&mut buf, 0);
    // Trust that the system always returns a valid principal.
    Principal::try_from(&buf).unwrap()
}

/// Gets the name of the method to be inspected.
///
/// This function is only available in the `canister_inspect_message` context.
///
/// Traps if the method name is not valid UTF-8.
pub fn msg_method_name() -> String {
    let len = ic0::msg_method_name_size();
    let mut buf = vec![0u8; len];
    ic0::msg_method_name_copy(&mut buf, 0);
    String::from_utf8(buf).expect("msg_method_name is not valid UTF-8")
}

/// Accepts the message in `canister_inspect_message`.
///
/// This function is only available in the `canister_inspect_message` context.
/// This function traps if invoked twice.
pub fn accept_message() {
    ic0::accept_message();
}

/// Gets the current size of the stable memory (in WebAssembly pages).
///
/// One WebAssembly page is 64KiB.
pub fn stable_size() -> u64 {
    ic0::stable64_size()
}

/// Attempts to grow the stable memory by `new_pages` many pages containing zeroes.
///
/// One WebAssembly page is 64KiB.
///
/// If successful, returns the previous size of the memory (in pages).
/// Otherwise, returns `u64::MAX`.
pub fn stable_grow(new_pages: u64) -> u64 {
    ic0::stable64_grow(new_pages)
}

/// Writes data to the stable memory location specified by an offset.
///
/// # Warning
/// This will panic if `offset + buf.len()` exceeds the current size of stable memory.
/// Call [`stable_grow`] to request more stable memory if needed.
pub fn stable_write(offset: u64, buf: &[u8]) {
    ic0::stable64_write(buf, offset);
}

/// Reads data from the stable memory location specified by an offset.
///
/// # Warning
/// This will panic if `offset + buf.len()` exceeds the current size of stable memory.
pub fn stable_read(offset: u64, buf: &mut [u8]) {
    ic0::stable64_read(buf, offset);
}

/// Gets the public key (a DER-encoded BLS key) of the root key of this instance of the Internet Computer Protocol.
///
/// # Note
///
/// This traps in non-replicated mode.
pub fn root_key() -> Vec<u8> {
    let len = ic0::root_key_size();
    let mut buf = vec![0u8; len];
    ic0::root_key_copy(&mut buf, 0);
    buf
}

/// Sets the certified data of this canister.
///
/// Canisters can store up to 32 bytes of data that is certified by
/// the system on a regular basis.  One can call [`data_certificate`]
/// function from a query call to get a certificate authenticating the
/// value set by calling this function.
///
/// This function can only be called from the following contexts:
/// - `canister_init`, `canister_pre_upgrade` and `canister_post_upgrade`
///   hooks.
/// - `canister_update` calls.
/// - reply or reject callbacks.
///
/// # Panics
///
/// - This function traps if `data.len() > 32`.
/// - This function traps if it's called from an illegal context
///   (e.g., from a query call).
pub fn certified_data_set<T: AsRef<[u8]>>(data: T) {
    let buf = data.as_ref();
    ic0::certified_data_set(buf);
}

/// When called from a query call, returns the data certificate authenticating
/// certified data set by this canister.
///
/// Returns `None` if called not from a query call.
pub fn data_certificate() -> Option<Vec<u8>> {
    if ic0::data_certificate_present() == 0 {
        return None;
    }
    let n = ic0::data_certificate_size();
    let mut buf = vec![0u8; n];
    ic0::data_certificate_copy(&mut buf, 0);
    Some(buf)
}

/// Gets current timestamp, in nanoseconds since the epoch (1970-01-01)
pub fn time() -> u64 {
    ic0::time()
}

/// Sets global timer.
///
/// The canister can set a global timer to make the system
/// schedule a call to the exported `canister_global_timer`
/// Wasm method after the specified time.
/// The time must be provided as nanoseconds since 1970-01-01.
///
/// The function returns the previous value of the timer.
/// If no timer is set before invoking the function, then the function returns zero.
///
/// Passing zero as an argument to the function deactivates the timer and thus
/// prevents the system from scheduling calls to the canister's `canister_global_timer` Wasm method.
pub fn global_timer_set(timestamp: u64) -> u64 {
    ic0::global_timer_set(timestamp)
}

/// Gets the value of specified performance counter.
///
/// See [`PerformanceCounterType`] for available counter types.
#[inline]
pub fn performance_counter(counter_type: impl Into<PerformanceCounterType>) -> u64 {
    let counter_type: u32 = counter_type.into().into();
    ic0::performance_counter(counter_type)
}

/// The type of performance counter.
#[derive(Debug, PartialEq, Eq, Clone, Copy)]
#[repr(u32)]
pub enum PerformanceCounterType {
    /// Current execution instruction counter.
    ///
    /// The number of WebAssembly instructions the canister has executed
    /// since the beginning of the current Message execution.
    InstructionCounter,
    /// Call context instruction counter
    ///
    /// The number of WebAssembly instructions the canister has executed
    /// within the call context of the current Message execution
    /// since Call context creation.
    /// The counter monotonically increases across all message executions
    /// in the call context until the corresponding call context is removed.
    CallContextInstructionCounter,
    /// A performance counter type that is not recognized by this library.
    Unrecognized(u32),
}

impl From<u32> for PerformanceCounterType {
    fn from(value: u32) -> Self {
        match value {
            0 => Self::InstructionCounter,
            1 => Self::CallContextInstructionCounter,
            _ => Self::Unrecognized(value),
        }
    }
}

impl From<PerformanceCounterType> for u32 {
    fn from(value: PerformanceCounterType) -> Self {
        match value {
            PerformanceCounterType::InstructionCounter => 0,
            PerformanceCounterType::CallContextInstructionCounter => 1,
            PerformanceCounterType::Unrecognized(value) => value,
        }
    }
}

impl PartialEq<u32> for PerformanceCounterType {
    fn eq(&self, other: &u32) -> bool {
        let self_as_u32: u32 = (*self).into();
        self_as_u32 == *other
    }
}

/// Returns the number of instructions that the canister executed since the last [entry
/// point](https://internetcomputer.org/docs/current/references/ic-interface-spec/#entry-points).
#[inline]
pub fn instruction_counter() -> u64 {
    performance_counter(0)
}

/// Returns the number of WebAssembly instructions the canister has executed
/// within the call context of the current Message execution since
/// Call context creation.
///
/// The counter monotonically increases across all message executions
/// in the call context until the corresponding call context is removed.
#[inline]
pub fn call_context_instruction_counter() -> u64 {
    performance_counter(1)
}

/// Determines if a Principal is a controller of the canister.
pub fn is_controller(principal: &Principal) -> bool {
    let slice = principal.as_slice();
    match ic0::is_controller(slice) {
        0 => false,
        1 => true,
        n => panic!("unexpected return value from is_controller: {n}"),
    }
}

/// Checks if in replicated execution.
///
/// The canister can check whether it is currently running in replicated or non replicated execution.
pub fn in_replicated_execution() -> bool {
    match ic0::in_replicated_execution() {
        0 => false,
        1 => true,
        n => panic!("unexpected return value from in_replicated_execution: {n}"),
    }
}

/// Gets the amount of cycles that a canister needs to be above the freezing threshold in order to successfully make an inter-canister call.
pub fn cost_call(method_name_size: u64, payload_size: u64) -> u128 {
    ic0::cost_call(method_name_size, payload_size)
}

/// Gets the cycle cost of the Management canister method [`creating_canister`](https://internetcomputer.org/docs/references/ic-interface-spec#ic-create_canister).
///
/// # Note
///
/// [`create_canister`](crate::management_canister::create_canister) and
/// [`create_canister_with_extra_cycles`](crate::management_canister::create_canister_with_extra_cycles)
/// invoke this function inside and attach the required cycles to the call.
pub fn cost_create_canister() -> u128 {
    ic0::cost_create_canister()
}

/// Gets the cycle cost of the Management canister method [`http_request`](https://internetcomputer.org/docs/references/ic-interface-spec#ic-http_request).
///
/// # Note
///
/// [`http_request`](crate::management_canister::http_request) and [`http_request_with_closure`](crate::management_canister::http_request_with_closure)
/// invoke this function inside and attach the required cycles to the call.
pub fn cost_http_request(request_size: u64, max_res_bytes: u64) -> u128 {
    ic0::cost_http_request(request_size, max_res_bytes)
}

/// The error type for [`cost_sign_with_ecdsa`] and [`cost_sign_with_schnorr`].
#[derive(thiserror::Error, Debug, Clone)]
pub enum SignCostError {
    /// The ECDSA/vetKD curve or Schnorr algorithm is invalid.
    #[error("invalid curve or algorithm")]
    InvalidCurveOrAlgorithm,

    /// The key name is invalid for the provided curve or algorithm.
    #[error("invalid key name")]
    InvalidKeyName,
    /// Unrecognized error.
    ///
    /// This error is returned when the System API returns an unrecognized error code.
    /// Please report to ic-cdk maintainers.
    #[error("unrecognized error: {0}")]
    UnrecognizedError(u32),
}

/// Helper function to handle the result of a signature cost function.
fn sign_cost_result(dst: u128, code: u32) -> Result<u128, SignCostError> {
    match code {
        0 => Ok(dst),
        1 => Err(SignCostError::InvalidCurveOrAlgorithm),
        2 => Err(SignCostError::InvalidKeyName),
        _ => Err(SignCostError::UnrecognizedError(code)),
    }
}

/// Gets the cycle cost of the Management canister method [`sign_with_ecdsa`](https://internetcomputer.org/docs/references/ic-interface-spec#ic-sign_with_ecdsa).
///
/// # Note
///
/// Alternatively, [`management_canister::cost_sign_with_ecdsa`](crate::management_canister::cost_sign_with_ecdsa) provides a higher-level API that wraps this function.
///
/// # Errors
///
/// This function will return an error if the `key_name` or the `ecdsa_curve` is invalid.
/// The error type [`SignCostError`] provides more information about the reason of the error.
pub fn cost_sign_with_ecdsa<T: AsRef<str>>(
    key_name: T,
    ecdsa_curve: u32,
) -> Result<u128, SignCostError> {
    let key_name = key_name.as_ref();
    let (cost, code) = ic0::cost_sign_with_ecdsa(key_name, ecdsa_curve);
    sign_cost_result(cost, code)
}

/// Gets the cycle cost of the Management canister method [`sign_with_schnorr`](https://internetcomputer.org/docs/references/ic-interface-spec#ic-sign_with_schnorr).
///
/// # Note
///
/// Alternatively, [`management_canister::cost_sign_with_schnorr`](crate::management_canister::cost_sign_with_schnorr) provides a higher-level API that wraps this function.
///
/// # Errors
///
/// This function will return an error if the `key_name` or the `algorithm` is invalid.
/// The error type [`SignCostError`] provides more information about the reason of the error.
pub fn cost_sign_with_schnorr<T: AsRef<str>>(
    key_name: T,
    algorithm: u32,
) -> Result<u128, SignCostError> {
    let key_name = key_name.as_ref();
    let (dst, code) = ic0::cost_sign_with_schnorr(key_name, algorithm);
    sign_cost_result(dst, code)
}

/// Gets the cycle cost of the Management canister method [`vetkd_derive_key`](https://github.com/dfinity/portal/pull/3763).
///
/// Later, the description will be available in [the interface spec](https://internetcomputer.org/docs/current/references/ic-interface-spec/#ic-vetkd_derive_key).
///
/// # Note
///
/// Alternatively, [`management_canister::cost_vetkd_derive_key`](crate::management_canister::cost_vetkd_derive_key) provides a higher-level API that wraps this function.
///
/// # Errors
///
/// This function will return an error if the `key_name` or the `vetkd_curve` is invalid.
/// The error type [`SignCostError`] provides more information about the reason of the error.
pub fn cost_vetkd_derive_key<T: AsRef<str>>(
    key_name: T,
    vetkd_curve: u32,
) -> Result<u128, SignCostError> {
    let key_name = key_name.as_ref();
    let (cost, code) = ic0::cost_vetkd_derive_key(key_name, vetkd_curve);
    sign_cost_result(cost, code)
}

/// Gets the number of environment variables available in the canister.
pub fn env_var_count() -> usize {
    ic0::env_var_count()
}

/// Gets the size of the name of the environment variable at the given index.
///
/// # Panics
///
/// This function traps if:
/// - The index is out of bounds (>= than value provided by [`env_var_count`])
/// - The name is not valid UTF-8.
pub fn env_var_name(index: usize) -> String {
    let len = ic0::env_var_name_size(index);
    let mut buf = vec![0u8; len];
    ic0::env_var_name_copy(index, &mut buf, 0);
    String::from_utf8(buf).expect("env_var_name is not valid UTF-8")
}

/// Checks if the environment variable with the given name exists.
///
/// # Panics
///
/// This function traps if the length of `name` exceeds `MAX_ENV_VAR_NAME_LENGTH`.
pub fn env_var_name_exists<T: AsRef<str>>(name: T) -> bool {
    match ic0::env_var_name_exists(name.as_ref()) {
        0 => false,
        1 => true,
        n => panic!("unexpected return value from env_var_name_exists: {n}"),
    }
}

/// Gets the value of the environment variable with the given name.
///
/// It's recommended to use [`env_var_name_exists`] to check if the variable exists before calling this function.
///
/// # Panics
///
/// This function traps if:
/// - The length of `name` exceeds `MAX_ENV_VAR_NAME_LENGTH`.
/// - The name does not match any existing environment variable.
/// - The value is not valid UTF-8.
pub fn env_var_value<T: AsRef<str>>(name: T) -> String {
    let name = name.as_ref();
    let len = ic0::env_var_value_size(name);
    let mut buf = vec![0u8; len];
    ic0::env_var_value_copy(name, &mut buf, 0);
    String::from_utf8(buf).expect("env_var_value is not valid UTF-8")
}

/// Emits textual trace messages.
///
/// On the "real" network, these do not do anything.
///
/// When executing in an environment that supports debugging, this copies out the data
/// and logs, prints or stores it in an environment-appropriate way.
pub fn debug_print<T: AsRef<str>>(data: T) {
    let buf = data.as_ref();
    ic0::debug_print(buf.as_bytes());
}

/// Traps with the given message.
///
/// The environment may copy out the data and log, print or store it in an environment-appropriate way,
/// or include it in system-generated reject messages where appropriate.
pub fn trap<T: AsRef<str>>(data: T) -> ! {
    let buf = data.as_ref();
    ic0::trap(buf.as_bytes());
}

// # Deprecated API bindings
//
// The following functions are deprecated and will be removed in the future.
// They are kept here for compatibility with existing code.

/// Prints the given message.
#[deprecated(since = "0.18.0", note = "Use `debug_print` instead")]
#[doc(hidden)]
pub fn print<S: std::convert::AsRef<str>>(s: S) {
    let s = s.as_ref();
    ic0::debug_print(s.as_bytes());
}

/// Returns the caller of the current call.
#[deprecated(since = "0.18.0", note = "Use `msg_caller` instead")]
#[doc(hidden)]
pub fn caller() -> Principal {
    let len = ic0::msg_caller_size();
    let mut bytes = vec![0u8; len];
    ic0::msg_caller_copy(&mut bytes, 0);
    Principal::try_from(&bytes).unwrap()
}

/// Returns the canister id as a blob.
#[deprecated(since = "0.18.0", note = "Use `canister_self` instead")]
#[doc(hidden)]
pub fn id() -> Principal {
    let len = ic0::canister_self_size();
    let mut bytes = vec![0u8; len];
    ic0::canister_self_copy(&mut bytes, 0);
    Principal::try_from(&bytes).unwrap()
}

/// Gets the amount of funds available in the canister.
///
/// # Panic
///
/// When the cycle balance is greater than `u64::MAX`, this function will panic.
/// As this function is deprecated, it is recommended to use [`canister_cycle_balance`].
#[deprecated(since = "0.18.0", note = "Use `canister_cycle_balance` instead")]
#[doc(hidden)]
pub fn canister_balance() -> u64 {
    // ic0 no longer provides `ic0.canister_cycle_balance` which returns a u64,
    // so we use the u128 version and convert it to u64.
    // When the cycle balance is greater than `u64::MAX`, `ic0.canister_cycle_balance` also panics.
    canister_cycle_balance()
        .try_into()
        .expect("the cycle balance is greater than u64::MAX, please use canister_cycle_balance which returns u128")
}

/// Gets the amount of funds available in the canister.
#[deprecated(since = "0.18.0", note = "Use `canister_cycle_balance` instead")]
#[doc(hidden)]
pub fn canister_balance128() -> u128 {
    canister_cycle_balance()
}

/// Sets the certified data of this canister.
///
/// Canisters can store up to 32 bytes of data that is certified by
/// the system on a regular basis.  One can call [`data_certificate`]
/// function from a query call to get a certificate authenticating the
/// value set by calling this function.
///
/// This function can only be called from the following contexts:
/// - `canister_init`, `canister_pre_upgrade` and `canister_post_upgrade`
///   hooks.
/// - `canister_update` calls.
/// - reply or reject callbacks.
///
/// # Panics
///
/// - This function traps if `data.len() > 32`.
/// - This function traps if it's called from an illegal context
///   (e.g., from a query call).
#[deprecated(since = "0.18.0", note = "Use `certified_data_set` instead")]
#[doc(hidden)]
pub fn set_certified_data(data: &[u8]) {
    ic0::certified_data_set(data);
}

/// Sets global timer.
///
/// The canister can set a global timer to make the system
/// schedule a call to the exported `canister_global_timer`
/// Wasm method after the specified time.
/// The time must be provided as nanoseconds since 1970-01-01.
///
/// The function returns the previous value of the timer.
/// If no timer is set before invoking the function, then the function returns zero.
///
/// Passing zero as an argument to the function deactivates the timer and thus
/// prevents the system from scheduling calls to the canister's `canister_global_timer` Wasm method.
#[deprecated(since = "0.18.0", note = "Use `global_timer_set` instead")]
#[doc(hidden)]
pub fn set_global_timer(timestamp: u64) -> u64 {
    ic0::global_timer_set(timestamp)
}



================================================
FILE: ic-cdk/src/bitcoin_canister.rs
================================================
//! This module provides functionality for making inter-canister calls to the [Bitcoin canisters][1].
//!
//! The Bitcoin canisters allow for interactions with the Bitcoin network from within the Internet Computer.
//! This module includes functions and types that facilitate these interactions, adhering to the
//! [Bitcoin Canisters Interface Specification][2].
//!
//! # Bounded-wait vs. Unbounded-wait
//!
//! Interacting with the Bitcoin canisters involves making inter-canister calls,
//! which can be either [bounded-wait](crate::call::Call::bounded_wait) or [unbounded-wait](crate::call::Call::unbounded_wait).
//!
//! Most of the functions in this module use the bounded-wait calls because they only read state.
//! The only function that uses the unbounded-wait call is [`bitcoin_send_transaction`].
//!
//! If the default behavior is not suitable for a particular use case, the [`Call`] struct can be used directly to make the call.
//!
//! For example, [`bitcoin_get_utxos`] makes an bounded-wait call. If an unbounded-wait call is preferred, the call can be made as follows:
//! ```rust, no_run
//! # use ic_cdk::bitcoin_canister::{cost_get_utxos, get_bitcoin_canister_id, GetUtxosRequest, GetUtxosResponse};
//! # use ic_cdk::call::Call;
//! # async fn example() -> ic_cdk::call::CallResult<GetUtxosResponse> {
//! let arg = GetUtxosRequest::default();
//! let canister_id = get_bitcoin_canister_id(&arg.network);
//! let cycles = cost_get_utxos(&arg);
//! let res: GetUtxosResponse = Call::unbounded_wait(canister_id, "bitcoin_get_utxos")
//!     .with_arg(&arg)
//!     .with_cycles(cycles)
//!     .await?
//!     .candid()?;
//! # Ok(res)
//! # }
//! ```
//!
//! ## Cycle Cost
//!
//! All the Bitcoin canister methods require cycles to be attached to the call.
//! The helper functions in this module automatically calculate the required cycles and attach them to the call.
//!
//! For completeness, this module also provides functions to calculate the cycle cost:
//! - [`cost_get_utxos`]
//! - [`cost_get_balance`]
//! - [`cost_get_current_fee_percentiles`]
//! - [`cost_get_block_headers`]
//! - [`cost_send_transaction`]
//!
//! # Bitcoin Canister ID
//!
//! The Bitcoin canister ID is determined by the network.
//! The helper functions in this module automatically determine the canister ID based on the `network` field in the request.
//!
//! For completeness, the [`get_bitcoin_canister_id`] function can be used to get the canister ID manually.
//!
//! [1]: https://github.com/dfinity/bitcoin-canister
//! [2]: https://github.com/dfinity/bitcoin-canister/blob/master/INTERFACE_SPECIFICATION.md

use crate::call::{Call, CallResult};
use candid::{CandidType, Principal};
use serde::{Deserialize, Serialize};

const MAINNET_ID: Principal = Principal::from_slice(&[0, 0, 0, 0, 1, 160, 0, 4, 1, 1]); // "ghsi2-tqaaa-aaaan-aaaca-cai"
const TESTNET_ID: Principal = Principal::from_slice(&[0, 0, 0, 0, 1, 160, 0, 1, 1, 1]); // "g4xu7-jiaaa-aaaan-aaaaq-cai"
const REGTEST_ID: Principal = Principal::from_slice(&[0, 0, 0, 0, 1, 160, 0, 1, 1, 1]); // "g4xu7-jiaaa-aaaan-aaaaq-cai"

// The cycles costs below are from the [API fees & Pricing](https://internetcomputer.org/docs/references/bitcoin-how-it-works#api-fees-and-pricing) documentation.
// They are unlikely to change, so hardcoded here for simplicity.
const GET_UTXO_MAINNET: u128 = 10_000_000_000;
const GET_UTXO_TESTNET: u128 = 4_000_000_000;

const GET_BALANCE_MAINNET: u128 = 100_000_000;
const GET_BALANCE_TESTNET: u128 = 40_000_000;

const GET_CURRENT_FEE_PERCENTILES_MAINNET: u128 = 100_000_000;
const GET_CURRENT_FEE_PERCENTILES_TESTNET: u128 = 40_000_000;

const GET_BLOCK_HEADERS_MAINNET: u128 = 10_000_000_000;
const GET_BLOCK_HEADERS_TESTNET: u128 = 4_000_000_000;

const SEND_TRANSACTION_SUBMISSION_MAINNET: u128 = 5_000_000_000;
const SEND_TRANSACTION_SUBMISSION_TESTNET: u128 = 2_000_000_000;

const SEND_TRANSACTION_PAYLOAD_MAINNET: u128 = 20_000_000;
const SEND_TRANSACTION_PAYLOAD_TESTNET: u128 = 8_000_000;

/// Gets the canister ID of the Bitcoin canister for the specified network.
pub fn get_bitcoin_canister_id(network: &Network) -> Principal {
    match network {
        Network::Mainnet => MAINNET_ID,
        Network::Testnet => TESTNET_ID,
        Network::Regtest => REGTEST_ID,
    }
}

/// Bitcoin Network.
#[derive(
    CandidType,
    Serialize,
    Deserialize,
    Debug,
    PartialEq,
    Eq,
    PartialOrd,
    Ord,
    Hash,
    Clone,
    Copy,
    Default,
)]
pub enum Network {
    /// The Bitcoin mainnet.
    #[default]
    #[serde(rename = "mainnet")]
    Mainnet,
    /// The Bitcoin testnet.
    #[serde(rename = "testnet")]
    Testnet,
    /// The Bitcoin regtest, used for local testing purposes.
    #[serde(rename = "regtest")]
    Regtest,
}

/// Satoshi.
///
/// The smallest unit of Bitcoin, equal to 0.00000001 BTC.
pub type Satoshi = u64;

/// Bitcoin Address.
///
/// Please check the [Bitcoin Canisters Interface Specification](https://github.com/dfinity/bitcoin-canister/blob/master/INTERFACE_SPECIFICATION.md#bitcoin_get_utxos) for supported address formats.
pub type Address = String;

/// Block Hash.
pub type BlockHash = Vec<u8>;

/// Block Height.
pub type BlockHeight = u32;

/// Outpoint.
#[derive(
    CandidType, Serialize, Deserialize, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Default,
)]
pub struct Outpoint {
    /// Transaction ID (TxID).
    ///
    /// The hash of the transaction that created the UTXO.
    pub txid: Vec<u8>,
    /// Output Index (vout).
    ///
    /// The index of the specific output within that transaction (since a transaction can have multiple outputs).
    pub vout: u32,
}

/// Unspent Transaction Output (UTXO).
#[derive(
    CandidType, Serialize, Deserialize, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Default,
)]
pub struct Utxo {
    /// The outpoint of the UTXO.
    pub outpoint: Outpoint,
    /// The value of the UTXO in satoshis.
    pub value: Satoshi,
    /// The block height at which the UTXO was created.
    pub height: BlockHeight,
}

/// Filter to restrict the set of returned UTXOs.
#[derive(
    CandidType, Serialize, Deserialize, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone,
)]
pub enum UtxosFilter {
    /// Filter by minimum number of confirmations.
    #[serde(rename = "min_confirmations")]
    MinConfirmations(u32),
    /// Filter by a page reference.
    #[serde(rename = "page")]
    Page(Vec<u8>),
}

/// Argument type of [`bitcoin_get_utxos`].
#[derive(
    CandidType, Serialize, Deserialize, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Default,
)]
pub struct GetUtxosRequest {
    /// The Bitcoin network.
    pub network: Network,
    /// The Bitcoin address.
    pub address: Address,
    /// An optional filter to restrict the set of returned UTXOs.
    pub filter: Option<UtxosFilter>,
}

/// Result type of [`bitcoin_get_utxos`].
#[derive(
    CandidType, Serialize, Deserialize, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Default,
)]
pub struct GetUtxosResponse {
    /// List of UTXOs.
    pub utxos: Vec<Utxo>,
    /// Hash of the tip block.
    pub tip_block_hash: BlockHash,
    /// Height of the tip height.
    pub tip_height: u32,
    /// Page reference when the response needs to be paginated.
    ///
    /// To be used in [`UtxosFilter::Page`].
    pub next_page: Option<Vec<u8>>,
}

/// Gets all unspent transaction outputs (UTXOs) associated with the provided address.
///
/// **Bounded-wait call**
///
/// Check the [Bitcoin Canisters Interface Specification](https://github.com/dfinity/bitcoin-canister/blob/master/INTERFACE_SPECIFICATION.md#bitcoin_get_utxos) for more details.
pub async fn bitcoin_get_utxos(arg: &GetUtxosRequest) -> CallResult<GetUtxosResponse> {
    let canister_id = get_bitcoin_canister_id(&arg.network);
    let cycles = cost_get_utxos(arg);
    Ok(Call::bounded_wait(canister_id, "bitcoin_get_utxos")
        .with_arg(arg)
        .with_cycles(cycles)
        .await?
        .candid()?)
}

/// Gets the cycles cost for the [`bitcoin_get_utxos`] function.
///
/// # Note
///
/// [`bitcoin_get_utxos`] calls this function internally so it's not necessary to call this function directly.
/// When it is preferred to construct a [`Call`] manually, this function can be used to get the cycles cost.
pub fn cost_get_utxos(arg: &GetUtxosRequest) -> u128 {
    match arg.network {
        Network::Mainnet => GET_UTXO_MAINNET,
        Network::Testnet => GET_UTXO_TESTNET,
        Network::Regtest => GET_UTXO_MAINNET,
    }
}

/// Argument type of [`bitcoin_get_balance`].
#[derive(
    CandidType, Serialize, Deserialize, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Default,
)]
pub struct GetBalanceRequest {
    /// The Bitcoin network.
    pub network: Network,
    /// The Bitcoin address.
    pub address: Address,
    /// Minimum number of confirmations.
    ///
    /// There is an upper bound of 144. Typically set to a value around 6 in practice.
    pub min_confirmations: Option<u32>,
}

/// Gets the current balance of a Bitcoin address in Satoshi.
///
/// **Bounded-wait call**
///
/// Check the [Bitcoin Canisters Interface Specification](https://github.com/dfinity/bitcoin-canister/blob/master/INTERFACE_SPECIFICATION.md#bitcoin_get_balance) for more details.
pub async fn bitcoin_get_balance(arg: &GetBalanceRequest) -> CallResult<Satoshi> {
    let canister_id = get_bitcoin_canister_id(&arg.network);
    let cycles = cost_get_balance(arg);
    Ok(Call::bounded_wait(canister_id, "bitcoin_get_balance")
        .with_arg(arg)
        .with_cycles(cycles)
        .await?
        .candid()?)
}

/// Gets the cycles cost for the [`bitcoin_get_balance`] function.
///
/// # Note
///
/// [`bitcoin_get_balance`] calls this function internally so it's not necessary to call this function directly.
/// When it is preferred to construct a [`Call`] manually, this function can be used to get the cycles cost.
pub fn cost_get_balance(arg: &GetBalanceRequest) -> u128 {
    match arg.network {
        Network::Mainnet => GET_BALANCE_MAINNET,
        Network::Testnet => GET_BALANCE_TESTNET,
        Network::Regtest => GET_BALANCE_MAINNET,
    }
}

/// Argument type of the [`bitcoin_get_current_fee_percentiles`] function.
#[derive(
    CandidType,
    Serialize,
    Deserialize,
    Debug,
    PartialEq,
    Eq,
    PartialOrd,
    Ord,
    Hash,
    Clone,
    Copy,
    Default,
)]
pub struct GetCurrentFeePercentilesRequest {
    /// The Bitcoin network.
    pub network: Network,
}

/// Unit of Bitcoin transaction fee.
///
/// This is the element in the [`bitcoin_get_current_fee_percentiles`] response.
pub type MillisatoshiPerByte = u64;

/// Gets the Bitcoin transaction fee percentiles.
///
/// **Bounded-wait call**
///
/// The percentiles are measured in millisatoshi/byte (1000 millisatoshi = 1 satoshi),
/// over the last 10,000 transactions in the specified network,
/// i.e., over the transactions in the last approximately 4-10 blocks.
pub async fn bitcoin_get_current_fee_percentiles(
    arg: &GetCurrentFeePercentilesRequest,
) -> CallResult<Vec<MillisatoshiPerByte>> {
    let canister_id = get_bitcoin_canister_id(&arg.network);
    let cycles = cost_get_current_fee_percentiles(arg);
    Ok(
        Call::bounded_wait(canister_id, "bitcoin_get_current_fee_percentiles")
            .with_arg(arg)
            .with_cycles(cycles)
            .await?
            .candid()?,
    )
}

/// Gets the cycles cost for the [`bitcoin_get_current_fee_percentiles`] function.
///
/// # Note
///
/// [`bitcoin_get_current_fee_percentiles`] calls this function internally so it's not necessary to call this function directly.
/// When it is preferred to construct a [`Call`] manually, this function can be used to get the cycles cost.
pub fn cost_get_current_fee_percentiles(arg: &GetCurrentFeePercentilesRequest) -> u128 {
    match arg.network {
        Network::Mainnet => GET_CURRENT_FEE_PERCENTILES_MAINNET,
        Network::Testnet => GET_CURRENT_FEE_PERCENTILES_TESTNET,
        Network::Regtest => GET_CURRENT_FEE_PERCENTILES_MAINNET,
    }
}

/// Argument type of the [`bitcoin_get_block_headers`] function.
#[derive(
    CandidType, Serialize, Deserialize, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Default,
)]
pub struct GetBlockHeadersRequest {
    /// The starting block height for the request.
    pub start_height: BlockHeight,
    /// The ending block height for the request, or `None` for the current tip.
    pub end_height: Option<BlockHeight>,
    /// The Bitcoin network.
    pub network: Network,
}

/// Block Header.
pub type BlockHeader = Vec<u8>;

/// Response type of the [`bitcoin_get_block_headers`] function.
#[derive(
    CandidType, Serialize, Deserialize, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Default,
)]
pub struct GetBlockHeadersResponse {
    /// The tip of the blockchain when this request was filled.
    pub tip_height: BlockHeight,
    /// The requested block headers.
    pub block_headers: Vec<BlockHeader>,
}

/// Gets the block headers in the provided range of block heights.
///
/// **Bounded-wait call**
///
/// Check the [Bitcoin Canisters Interface Specification](https://github.com/dfinity/bitcoin-canister/blob/master/INTERFACE_SPECIFICATION.md#bitcoin_get_block_headers) for more details.
pub async fn bitcoin_get_block_headers(
    arg: &GetBlockHeadersRequest,
) -> CallResult<GetBlockHeadersResponse> {
    let canister_id = get_bitcoin_canister_id(&arg.network);
    let cycles = cost_get_block_headers(arg);
    Ok(Call::bounded_wait(canister_id, "bitcoin_get_block_headers")
        .with_arg(arg)
        .with_cycles(cycles)
        .await?
        .candid()?)
}

/// Gets the cycles cost for the [`bitcoin_get_block_headers`] function.
///
/// # Note
///
/// [`bitcoin_get_block_headers`] calls this function internally so it's not necessary to call this function directly.
/// When it is preferred to construct a [`Call`] manually, this function can be used to get the cycles cost.
pub fn cost_get_block_headers(arg: &GetBlockHeadersRequest) -> u128 {
    match arg.network {
        Network::Mainnet => GET_BLOCK_HEADERS_MAINNET,
        Network::Testnet => GET_BLOCK_HEADERS_TESTNET,
        Network::Regtest => GET_BLOCK_HEADERS_MAINNET,
    }
}

/// Argument type of the [`bitcoin_send_transaction`] function.
#[derive(
    CandidType, Serialize, Deserialize, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Default,
)]
pub struct SendTransactionRequest {
    /// The Bitcoin network.
    pub network: Network,
    /// The Bitcoin transaction.
    pub transaction: Vec<u8>,
}

/// Sends a Bitcoin transaction to the Bitcoin network.
///
/// **Unbounded-wait call**
///
/// Check the [Bitcoin Canisters Interface Specification](https://github.com/dfinity/bitcoin-canister/blob/master/INTERFACE_SPECIFICATION.md#bitcoin_send_transaction) for more details.
pub async fn bitcoin_send_transaction(arg: &SendTransactionRequest) -> CallResult<()> {
    let canister_id = get_bitcoin_canister_id(&arg.network);
    let cycles = cost_send_transaction(arg);
    Ok(
        Call::unbounded_wait(canister_id, "bitcoin_send_transaction")
            .with_arg(arg)
            .with_cycles(cycles)
            .await?
            .candid()?,
    )
}

/// Gets the cycles cost for the [`bitcoin_send_transaction`] function.
///
/// # Note
///
/// [`bitcoin_send_transaction`] calls this function internally so it's not necessary to call this function directly.
/// When it is preferred to construct a [`Call`] manually, this function can be used to get the cycles cost.
pub fn cost_send_transaction(arg: &SendTransactionRequest) -> u128 {
    let (submission, payload) = match arg.network {
        Network::Mainnet => (
            SEND_TRANSACTION_SUBMISSION_MAINNET,
            SEND_TRANSACTION_PAYLOAD_MAINNET,
        ),
        Network::Testnet => (
            SEND_TRANSACTION_SUBMISSION_TESTNET,
            SEND_TRANSACTION_PAYLOAD_TESTNET,
        ),
        Network::Regtest => (
            SEND_TRANSACTION_SUBMISSION_MAINNET,
            SEND_TRANSACTION_PAYLOAD_MAINNET,
        ),
    };
    submission + payload * arg.transaction.len() as u128
}



================================================
FILE: ic-cdk/src/call.rs
================================================
//! Inter-canister Call API
//!
//! This module provides the necessary APIs to make and manage inter-canister calls within a canister.
//! It offers a builder pattern to configure and execute calls, allowing for flexible and customizable interactions
//! between canisters.
//!
//! # Overview
//!
//! The primary type in this module is [`Call`], which represents an inter-canister call. For detailed usage and examples,
//! refer to the [`Call`] type documentation.
//!
//! ```rust, no_run
//! # use ic_cdk::call::Call;
//! # async fn bar() {
//! # let canister_id = ic_cdk::api::canister_self();
//! # let method = "foo";
//! let result: u32 = Call::bounded_wait(canister_id, method).await.unwrap().candid().unwrap();
//! # }
//! ```
//!
//! # Error Handling
//!
//! The module defines various error types to handle different failure scenarios during inter-canister calls:
//!
//! - The base error cases:
//!   - [`InsufficientLiquidCycleBalance`]: Errors when the liquid cycle balance is insufficient to perform the call.
//!   - [`CallPerformFailed`]: Errors when the `ic0.call_perform` operation fails.
//!   - [`CallRejected`]: Errors when an inter-canister call is rejected.
//!   - [`CandidDecodeFailed`]: Errors when the response cannot be decoded as Candid.
//! - The composite error types:
//!   - [`enum@Error`]: The top-level error type encapsulating all possible errors.
//!   - [`CallFailed`]: Errors related to the execution of the call itself, i.e. all the errors except for the Candid decoding failure.
//!   - [`OnewayError`]: The error type for when sending a [`oneway`](Call::oneway) call.
//!
//! # Internal Details
//!
//! The module also includes internal types and functions to manage the state and execution of inter-canister calls,
//! such as [`CallFuture`] and its associated state management.

use crate::api::{cost_call, msg_arg_data, msg_reject_code, msg_reject_msg};
use crate::{futures::is_recovering_from_trap, trap};
use candid::utils::{ArgumentDecoder, ArgumentEncoder, encode_args_ref};
use candid::{CandidType, Deserialize, Principal, decode_args, decode_one, encode_one};
use ic_cdk_executor::{MethodHandle, TaskHandle};
use std::borrow::Cow;
use std::future::IntoFuture;
use std::mem;
use std::pin::Pin;
use std::sync::{Arc, RwLock};
use std::task::{Context, Poll, Waker};
use thiserror::Error;

pub use ic_error_types::RejectCode;

/// Inter-canister Call.
///
/// This type enables the configuration and execution of inter-canister calls using a builder pattern.
///
/// # Constructors
///
/// [`Call`] has two constructors that differentiate whether the call's response is waited for an unbounded amount of time or not.
/// - [`bounded_wait`][Self::bounded_wait]: wait boundedly (defaults with 300-second timeout).
/// - [`unbounded_wait`][Self::unbounded_wait]: wait unboundedly.
///
/// # Configuration
///
/// Before execution, a [`Call`] can be configured in following aspects:
///
/// - Arguments:
///   - [`with_arg`][Self::with_arg]: single `CandidType` value that will be encoded.
///   - [`with_args`][Self::with_args]: a tuple of multiple `CandidType` values that will be encoded.
///   - [`with_raw_args`][Self::with_raw_args]: raw bytes that won't be encoded.
///   - *Note*: If no methods in this category are invoked, the [`Call`] defaults to sending a **Candid empty tuple `()`**.
/// - Cycles:
///   - [`with_cycles`][Self::with_cycles]: set the cycles attached in this call.
/// - Response waiting timeout:
///   - [`change_timeout`][Self::change_timeout]: change the timeout for **`bounded_wait`** call.
///
/// Please note that all the configuration methods are chainable and can be called multiple times.
/// For each **aspect** of the call, the **last** configuration takes effect.
///
/// ## Example
///
/// ```rust, no_run
/// # use ic_cdk::call::Call;
/// # async fn bar() {
/// # let canister_id = ic_cdk::api::canister_self();
/// # let method = "foo";
/// let call = Call::bounded_wait(canister_id, method)
///     .with_raw_args(&[1,0])
///     .with_cycles(1000)
///     .change_timeout(5)
///     .with_arg(42)
///     .with_cycles(2000);
/// # }
/// ```
///
/// The `call` above will have the following configuration in effect:
/// - Arguments: `42` encoded as Candid bytes.
/// - Attach 2000 cycles.
/// - Boundedly waiting for response with a 5-second timeout.
///
/// # Execution
///
/// A [`Call`] can be executed in two ways:
/// - **Asynchronously**: Convert to a [`CallFuture`] and await the response.
///   - Direct approach: Use `.await` on the call (e.g., `call.await`).
///   - Collective approach: Use [`IntoFuture::into_future`] to obtain futures explicitly,
///     then combine them with `join!`, `select!`, or other combinators.
/// - **One-way**: Send a call with [`oneway`][Self::oneway] when you don't need a response.
///
/// ## Example
///
/// ```rust, no_run
/// # use ic_cdk::call::Call;
/// # use candid::Principal;
/// # async fn bar() {
/// # let canister_id : Principal = todo!();
/// # let method: &str = todo!();
/// # let canister_id1 : Principal = todo!();
/// # let method1: &str = todo!();
/// # let canister_id2 : Principal = todo!();
/// # let method2: &str = todo!();
/// let response = Call::bounded_wait(canister_id, method).await;
/// let calls = vec![
///   Call::bounded_wait(canister_id1, method1).into_future(),
///   Call::bounded_wait(canister_id2, method2).into_future(),
/// ];
/// let responses = futures::future::join_all(calls).await;
/// Call::bounded_wait(canister_id, method).oneway().unwrap();
/// # }
/// ```
///
/// # Decoding the response
///
/// If an asynchronous [`Call`] succeeds, the response can be decoded in two ways:
/// - [`candid`][Response::candid]: decode the response as a single Candid type.
/// - [`candid_tuple`][Response::candid_tuple]: decode the response as a tuple of Candid types.
///
/// ## Example
///
/// ```rust, no_run
/// # use ic_cdk::call::{Call, Response};
/// # async fn bar() {
/// # let canister_id = ic_cdk::api::canister_self();
/// # let method = "foo";
/// let res: Response = Call::bounded_wait(canister_id, method).await.unwrap();
/// let result: u32 = res.candid().unwrap();
/// let result_tuple: (u32,) = res.candid_tuple().unwrap();
/// # }
/// ```
///
/// <div class="warning">
///
/// Using an inter-canister call creates the possibility that your async function will be canceled partway through.
/// Read the [`futures`](crate::futures) module docs for why and how this happens.
///
/// </div>
#[derive(Debug, Clone)]
pub struct Call<'m, 'a> {
    canister_id: Principal,
    method: &'m str,
    cycles: u128,
    timeout_seconds: Option<u32>,
    encoded_args: Cow<'a, [u8]>,
}

// Constructors
impl<'m> Call<'m, '_> {
    /// Constructs a [`Call`] which will **boundedly** wait for response.
    ///
    /// # Note
    ///
    /// The bounded waiting is set with a default 300-second timeout.
    /// It aligns with the `MAX_CALL_TIMEOUT` constant in the current IC implementation.
    /// The timeout can be changed using the [`change_timeout`][Self::change_timeout] method.
    ///
    /// To unboundedly wait for response, use the [`Call::unbounded_wait`] constructor instead.
    #[must_use]
    pub fn bounded_wait(canister_id: Principal, method: &'m str) -> Self {
        Self {
            canister_id,
            method,
            cycles: 0,
            // Default to 300-second timeout.
            timeout_seconds: Some(300),
            // Bytes for empty arguments.
            // `candid::Encode!(&()).unwrap()`
            encoded_args: Cow::Owned(vec![0x44, 0x49, 0x44, 0x4c, 0x00, 0x00]),
        }
    }

    /// Constructs a [`Call`] which will **unboundedly** wait for response.
    ///
    /// To boundedly wait for response, use the  [`Call::bounded_wait`] constructor instead.
    #[must_use]
    pub fn unbounded_wait(canister_id: Principal, method: &'m str) -> Self {
        Self {
            canister_id,
            method,
            cycles: 0,
            timeout_seconds: None,
            // Bytes for empty arguments.
            // `candid::Encode!(&()).unwrap()`
            encoded_args: Cow::Owned(vec![0x44, 0x49, 0x44, 0x4c, 0x00, 0x00]),
        }
    }
}

// Configuration
impl<'a> Call<'_, 'a> {
    /// Sets the argument for the call.
    ///
    /// The argument must implement [`CandidType`].
    #[must_use]
    pub fn with_arg<A: CandidType>(self, arg: A) -> Self {
        Self {
            encoded_args: Cow::Owned(encode_one(&arg).unwrap_or_else(panic_when_encode_fails)),
            ..self
        }
    }

    /// Sets the arguments for the call.
    ///
    /// The arguments are a tuple of types, each implementing [`CandidType`].
    #[must_use]
    pub fn with_args<A: ArgumentEncoder>(self, args: &A) -> Self {
        Self {
            encoded_args: Cow::Owned(encode_args_ref(args).unwrap_or_else(panic_when_encode_fails)),
            ..self
        }
    }

    /// Sets the arguments for the call as raw bytes.
    ///
    /// # Note
    ///
    /// This method just borrows the bytes, so it is useful when making multiple calls with the same argument data.
    ///
    /// The `Call` object will be tied to the lifetime of the argument bytes,
    /// which may prevent storing the call in collections or returning it from functions
    /// if the arguments don't live long enough.
    ///
    /// For cases where you need to transfer ownership of the arguments bytes consider using [`Self::take_raw_args`] instead.
    #[must_use]
    pub fn with_raw_args(self, raw_args: &'a [u8]) -> Self {
        Self {
            encoded_args: Cow::Borrowed(raw_args),
            ..self
        }
    }

    /// Sets the arguments for the call as raw bytes and consumes the bytes.
    ///
    /// # Note
    ///
    /// This method takes ownership of the arguments bytes, so it is useful
    /// when you want to store the call in collections or return a `Call` from functions.
    ///
    /// For cases where you want to make multiple calls with the same argument data,
    /// consider using [`Self::with_raw_args`] instead to avoid unnecessary cloning.
    #[must_use]
    pub fn take_raw_args(self, raw_args: Vec<u8>) -> Self {
        Self {
            encoded_args: Cow::Owned(raw_args),
            ..self
        }
    }

    /// Sets the cycles payment for the call.
    ///
    /// # Note
    ///
    /// The behavior of this method when invoked multiple times is as follows:
    /// - Overrides any previously set cycle value
    /// - Last invocation determines the final cycles amount
    /// - Does not accumulate cycles across multiple invocations
    #[must_use]
    pub fn with_cycles(mut self, cycles: u128) -> Self {
        self.cycles = cycles;
        self
    }

    /// Changes the timeout for bounded response waiting.
    ///
    /// If invoked multiple times, the last value takes effect.
    ///
    /// The timeout value is silently capped by the `MAX_CALL_TIMEOUT` constant which is currently set to 300 seconds.
    /// Therefore, setting a timeout greater than 300 seconds will actually result in a 300-second timeout.
    ///
    /// # Panics
    ///
    /// This method will panic if invoked on an unbounded response waiting call constructed by [`Call::unbounded_wait`] .
    ///
    /// # Note
    ///
    /// A timeout of 0 second **DOES NOT** mean unbounded response waiting.
    /// The call would most likely time out (result in a [`SysUnknown`](RejectCode::SysUnknown) reject).
    /// Unless it's a call to the canister on the same subnet,
    /// and the execution manages to schedule both the request and the response in the same round.
    ///
    /// To unboundedly wait for response, use the [`Call::unbounded_wait`] constructor instead.
    #[must_use]
    pub fn change_timeout(mut self, timeout_seconds: u32) -> Self {
        match self.timeout_seconds {
            Some(_) => self.timeout_seconds = Some(timeout_seconds),
            None => {
                panic!("Cannot set a timeout for an instance created with Call::unbounded_wait")
            }
        }
        self
    }

    /// Returns the amount of cycles a canister needs to be above the freezing threshold in order to
    /// successfully perform this call. Takes into account the attached cycles ([`with_cycles`](Self::with_cycles))
    /// as well as
    /// - the method name byte length
    /// - the payload length
    /// - the cost of transmitting the request
    /// - the cost for the reservation of response transmission (may be partially refunded)
    /// - the cost for the reservation of callback execution (may be partially refunded).
    #[must_use]
    pub fn get_cost(&self) -> u128 {
        self.cycles.saturating_add(cost_call(
            self.method.len() as u64,
            self.encoded_args.len() as u64,
        ))
    }
}

/// Response of a successful call.
#[derive(Debug)]
pub struct Response(Vec<u8>);

impl Response {
    /// Gets the raw bytes of the response.
    pub fn into_bytes(self) -> Vec<u8> {
        self.0
    }

    /// Decodes the response as a single Candid type.
    pub fn candid<R>(&self) -> Result<R, CandidDecodeFailed>
    where
        R: CandidType + for<'de> Deserialize<'de>,
    {
        decode_one(&self.0).map_err(|e| CandidDecodeFailed {
            type_name: std::any::type_name::<R>().to_string(),
            candid_error: e.to_string(),
        })
    }

    /// Decodes the response as a tuple of Candid types.
    pub fn candid_tuple<R>(&self) -> Result<R, CandidDecodeFailed>
    where
        R: for<'de> ArgumentDecoder<'de>,
    {
        decode_args(&self.0).map_err(|e| CandidDecodeFailed {
            type_name: std::any::type_name::<R>().to_string(),
            candid_error: e.to_string(),
        })
    }
}

impl PartialEq<&[u8]> for Response {
    fn eq(&self, other: &&[u8]) -> bool {
        self.0 == *other
    }
}

impl PartialEq<Vec<u8>> for Response {
    fn eq(&self, other: &Vec<u8>) -> bool {
        self.0 == *other
    }
}

impl PartialEq for Response {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}

impl std::ops::Deref for Response {
    type Target = [u8];

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl AsRef<[u8]> for Response {
    fn as_ref(&self) -> &[u8] {
        &self.0
    }
}

impl std::borrow::Borrow<[u8]> for Response {
    fn borrow(&self) -> &[u8] {
        &self.0
    }
}

// Errors ---------------------------------------------------------------------

/// Represents errors that can occur during inter-canister calls.
///
/// This is the top-level error type for the inter-canister call API.
///
/// This encapsulates all possible errors that can arise, including:
/// - Insufficient liquid cycle balance.
/// - `ic0.call_perform` failed.
/// - Asynchronously rejected.
/// - Candid decoding of the response failed.
#[derive(Error, Debug, Clone)]
pub enum Error {
    /// The liquid cycle balance is insufficient to perform the call.
    #[error(transparent)]
    InsufficientLiquidCycleBalance(#[from] InsufficientLiquidCycleBalance),

    /// The `ic0.call_perform` operation failed.
    #[error(transparent)]
    CallPerformFailed(#[from] CallPerformFailed),

    /// The inter-canister call is rejected.
    #[error(transparent)]
    CallRejected(#[from] CallRejected),

    /// The response from the inter-canister call could not be decoded as Candid.
    ///
    /// This variant wraps errors that occur when attempting to decode the response
    /// into the expected Candid type.
    #[error(transparent)]
    CandidDecodeFailed(#[from] CandidDecodeFailed),
}

/// The error type when awaiting a [`CallFuture`].
///
/// This encapsulates all possible [`enum@Error`] except for the [`CandidDecodeFailed`] variant.
#[derive(Error, Debug, Clone)]
pub enum CallFailed {
    /// The liquid cycle balance is insufficient to perform the call.
    #[error(transparent)]
    InsufficientLiquidCycleBalance(#[from] InsufficientLiquidCycleBalance),

    /// The `ic0.call_perform` operation failed.
    #[error(transparent)]
    CallPerformFailed(#[from] CallPerformFailed),

    /// The inter-canister call is rejected.
    #[error(transparent)]
    CallRejected(#[from] CallRejected),
}

/// The error type of [`Call::oneway`].
///
/// This encapsulates all possible errors that can occur when sending a oneway call.
/// Therefore, it includes the [`InsufficientLiquidCycleBalance`] and [`CallPerformFailed`] variants.
#[derive(Error, Debug, Clone)]
pub enum OnewayError {
    /// The liquid cycle balance is insufficient to perform the call.
    #[error(transparent)]
    InsufficientLiquidCycleBalance(#[from] InsufficientLiquidCycleBalance),
    /// The `ic0.call_perform` operation failed.
    #[error(transparent)]
    CallPerformFailed(#[from] CallPerformFailed),
}

impl From<OnewayError> for Error {
    fn from(e: OnewayError) -> Self {
        match e {
            OnewayError::InsufficientLiquidCycleBalance(e) => {
                Error::InsufficientLiquidCycleBalance(e)
            }
            OnewayError::CallPerformFailed(e) => Error::CallPerformFailed(e),
        }
    }
}

impl From<CallFailed> for Error {
    fn from(e: CallFailed) -> Self {
        match e {
            CallFailed::InsufficientLiquidCycleBalance(e) => {
                Error::InsufficientLiquidCycleBalance(e)
            }
            CallFailed::CallPerformFailed(e) => Error::CallPerformFailed(e),
            CallFailed::CallRejected(e) => Error::CallRejected(e),
        }
    }
}

/// Represents an error that occurs when the liquid cycle balance is insufficient to perform the call.
///
/// The liquid cycle balance is determined by [`canister_liquid_cycle_balance`](crate::api::canister_liquid_cycle_balance).
/// The cost of the call is determined by [`Call::get_cost`].
///
/// The call won't be performed if the former is less than the latter.
#[derive(Error, Debug, Clone)]
#[error("insufficient liquid cycles balance, available: {available}, required: {required}")]
pub struct InsufficientLiquidCycleBalance {
    /// The liquid cycle balance available in the canister.
    pub available: u128,
    /// The required cycles to perform the call.
    pub required: u128,
}

/// Represents an error that occurs when the `ic0.call_perform` operation fails.
///
/// This error type indicates that the underlying `ic0.call_perform` operation
/// returned a non-zero code, signaling a failure.
#[derive(Error, Debug, Clone)]
#[error("call perform failed")]
pub struct CallPerformFailed;

/// Represents an error that occurs when an inter-canister call is rejected.
///
/// The [`reject_code`][`Self::reject_code`] and [`reject_message`][`Self::reject_message`]
/// are exposed to provide details of the rejection.
///
/// This is wrapped by the [`CallFailed::CallRejected`] variant.
#[derive(Error, Debug, Clone)]
#[error("call rejected: {raw_reject_code} - {reject_message}")]
pub struct CallRejected {
    /// All fields are private so we will be able to change the implementation without breaking the API.
    /// Once we have `ic0.msg_error_code` system API, we will only store the `error_code` in this struct.
    /// It will still be possible to get the [`RejectCode`] using the public getter,
    /// because every `error_code` can map to a [`RejectCode`].
    raw_reject_code: u32,
    reject_message: String,
}

/// The error type for when an unrecognized reject code is encountered.
#[derive(Error, Debug, Clone, PartialEq, Eq)]
#[error("unrecognized reject code: {0}")]
pub struct UnrecognizedRejectCode(u32);

impl CallRejected {
    /// Constructs a [`CallRejected`] instance with the reject code and message.
    ///
    /// # Note
    ///
    /// This constructor is primarily intended for testing scenarios where you need to simulate
    /// rejected inter-canister calls. In production code, instances of this error are typically
    /// created by the system when actual rejections occur during inter-canister communication.
    /// Use this constructor with caution outside of test environments.
    pub fn with_rejection(raw_reject_code: u32, reject_message: String) -> Self {
        Self {
            raw_reject_code,
            reject_message,
        }
    }

    /// Gets the [`RejectCode`].
    ///
    /// The value is converted from [`api::msg_reject_code`](`msg_reject_code`).
    ///
    /// # Errors
    ///
    /// If the raw reject code is not recognized, this method will return an [`UnrecognizedRejectCode`] error.
    /// This can happen if the IC produces a new reject code that hasn't been included in [`ic_error_types::RejectCode`].
    /// Please check if your `ic-error-types` dependency is up-to-date.
    /// If the latest version of `ic-error-types` doesn't include the new reject code, please report it to the `ic-cdk` maintainers.
    pub fn reject_code(&self) -> Result<RejectCode, UnrecognizedRejectCode> {
        RejectCode::try_from(u64::from(self.raw_reject_code))
            .map_err(|_| UnrecognizedRejectCode(self.raw_reject_code))
    }

    /// Gets the raw numeric [`RejectCode`] value.
    ///
    /// This is a "never-fail" version of [`reject_code`](Self::reject_code) that returns the raw numeric value.
    pub fn raw_reject_code(&self) -> u32 {
        self.raw_reject_code
    }

    /// Retrieves the reject message associated with the call.
    ///
    /// This message is obtained from [`api::msg_reject_msg`](`msg_reject_msg`).
    pub fn reject_message(&self) -> &str {
        &self.reject_message
    }
}

/// Represents an error that occurs when the response from an inter-canister call
/// cannot be decoded as Candid.
///
/// This error type provides details about the Candid decoding failure, including
/// the type that was being decoded and the specific Candid error that occurred.
///
/// This is the only possible error that can occur in [`Response::candid`] and [`Response::candid_tuple`].
///
/// It is wrapped by the top-level [`Error::CandidDecodeFailed`] variant.
#[derive(Error, Debug, Clone)]
#[error("candid decode failed for type: {type_name}, candid error: {candid_error}")]
pub struct CandidDecodeFailed {
    type_name: String,
    candid_error: String,
}

/// Extension trait for error types to provide additional methods.
pub trait CallErrorExt {
    /// Checks if the error is a clean reject.
    /// A clean reject means that there must be no state changes on the callee side.
    fn is_clean_reject(&self) -> bool;
    /// Determines if the failed call can be retried immediately within the update method
    /// that's handling the error, as opposed to relying on a background timer or heartbeat.
    ///
    /// A return value of `true` indicates that an immediate retry *might* succeed, i.e., not result in another error.
    /// However, the caller is responsible for ensuring that retries are safe in their specific context.
    /// For idempotent methods, immediate retries are generally safe. For non-idempotent ones,
    /// checking [`is_clean_reject`](CallErrorExt::is_clean_reject) before retrying is recommended.
    fn is_immediately_retryable(&self) -> bool;
}

impl CallErrorExt for InsufficientLiquidCycleBalance {
    fn is_clean_reject(&self) -> bool {
        // The call was not performed.
        true
    }

    fn is_immediately_retryable(&self) -> bool {
        // Caller should top up cycles before retrying.
        false
    }
}

impl CallErrorExt for CallPerformFailed {
    fn is_clean_reject(&self) -> bool {
        true
    }

    fn is_immediately_retryable(&self) -> bool {
        false
    }
}

impl CallErrorExt for CallRejected {
    fn is_clean_reject(&self) -> bool {
        // Here we apply a conservative whitelist of reject codes that are considered clean.
        // Once finer `error_code` is available, we can allow more cases to be clean.
        let clean_reject_codes: Vec<u32> = vec![
            RejectCode::SysFatal as u32,
            RejectCode::SysTransient as u32,
            RejectCode::DestinationInvalid as u32,
        ];
        clean_reject_codes.contains(&self.raw_reject_code)
    }

    fn is_immediately_retryable(&self) -> bool {
        // Here we apply a conservative whitelist of reject codes that are considered immediately retryable.
        // Once finer `error_code` is available, we can allow more cases to be immediately retryable.
        let immediately_retryable_codes: Vec<u32> = vec![
            RejectCode::SysTransient as u32,
            RejectCode::SysUnknown as u32,
        ];
        immediately_retryable_codes.contains(&self.raw_reject_code)
    }
}

impl CallErrorExt for CandidDecodeFailed {
    fn is_clean_reject(&self) -> bool {
        // Decoding failure suggests that the inter-canister call was successfully processed by the callee.
        // Therefore, the callee state is likely changed (unless the method doesn't change its own state).
        false
    }

    fn is_immediately_retryable(&self) -> bool {
        // Decoding failure suggests a mismatch between the expected and actual response types.
        // Either the callee or the caller has a bug, and retrying the call immediately is unlikely to succeed.
        false
    }
}

impl CallErrorExt for Error {
    fn is_clean_reject(&self) -> bool {
        match self {
            Error::InsufficientLiquidCycleBalance(e) => e.is_clean_reject(),
            Error::CallPerformFailed(e) => e.is_clean_reject(),
            Error::CallRejected(e) => e.is_clean_reject(),
            Error::CandidDecodeFailed(e) => e.is_clean_reject(),
        }
    }

    fn is_immediately_retryable(&self) -> bool {
        match self {
            Error::InsufficientLiquidCycleBalance(e) => e.is_immediately_retryable(),
            Error::CallPerformFailed(e) => e.is_immediately_retryable(),
            Error::CallRejected(e) => e.is_immediately_retryable(),
            Error::CandidDecodeFailed(e) => e.is_immediately_retryable(),
        }
    }
}

impl CallErrorExt for CallFailed {
    fn is_clean_reject(&self) -> bool {
        match self {
            CallFailed::InsufficientLiquidCycleBalance(e) => e.is_clean_reject(),
            CallFailed::CallPerformFailed(e) => e.is_clean_reject(),
            CallFailed::CallRejected(e) => e.is_clean_reject(),
        }
    }

    fn is_immediately_retryable(&self) -> bool {
        match self {
            CallFailed::InsufficientLiquidCycleBalance(e) => e.is_immediately_retryable(),
            CallFailed::CallPerformFailed(e) => e.is_immediately_retryable(),
            CallFailed::CallRejected(e) => e.is_immediately_retryable(),
        }
    }
}

impl CallErrorExt for OnewayError {
    fn is_clean_reject(&self) -> bool {
        match self {
            OnewayError::InsufficientLiquidCycleBalance(e) => e.is_clean_reject(),
            OnewayError::CallPerformFailed(e) => e.is_clean_reject(),
        }
    }

    fn is_immediately_retryable(&self) -> bool {
        match self {
            OnewayError::InsufficientLiquidCycleBalance(e) => e.is_immediately_retryable(),
            OnewayError::CallPerformFailed(e) => e.is_immediately_retryable(),
        }
    }
}

// Errors END -----------------------------------------------------------------

/// Result of a inter-canister call.
pub type CallResult<R> = Result<R, Error>;

impl<'m, 'a> IntoFuture for Call<'m, 'a> {
    type Output = Result<Response, CallFailed>;
    type IntoFuture = CallFuture<'m, 'a>;

    fn into_future(self) -> Self::IntoFuture {
        CallFuture {
            state: Arc::new(RwLock::new(CallFutureState::Prepared { call: self })),
        }
    }
}

// Execution
impl Call<'_, '_> {
    /// Sends the call and ignores the reply.
    pub fn oneway(&self) -> Result<(), OnewayError> {
        self.check_liquid_cycle_balance_sufficient()?;
        match self.perform(None) {
            0 => Ok(()),
            _ => Err(CallPerformFailed.into()),
        }
    }

    /// Checks if the liquid cycle balance is sufficient to perform the call.
    fn check_liquid_cycle_balance_sufficient(&self) -> Result<(), InsufficientLiquidCycleBalance> {
        let required = self.get_cost();
        let available = crate::api::canister_liquid_cycle_balance();
        if available >= required {
            Ok(())
        } else {
            Err(InsufficientLiquidCycleBalance {
                available,
                required,
            })
        }
    }

    /// Performs the call.
    ///
    /// This is an internal helper function only for [`Self::call_oneway`] and [`CallFuture::poll`].
    ///
    /// # Arguments
    ///
    /// - `state_ptr`: An optional pointer to the internal state of the [`CallFuture`].
    ///   - If `Some`, the call will be prepared for asynchronous execution:
    ///     - `ic0.call_new` will be invoked with [`callback`] and state pointer.
    ///     - `ic0.call_on_cleanup` will be invoked with [`cleanup`].
    ///   - If `None`, the call will be prepared for oneway execution:
    ///     - `ic0.call_new` will be invoked with invalid callback functions.
    ///     - `ic0.call_on_cleanup` won't be invoked.
    ///
    /// # Returns
    ///
    /// The return value of `ic0.call_perform`.
    fn perform(&self, state_opt: Option<Arc<RwLock<CallFutureState<'_, '_>>>>) -> u32 {
        let callee = self.canister_id.as_slice();
        let method = self.method;
        let arg = match &self.encoded_args {
            Cow::Owned(vec) => vec,
            Cow::Borrowed(r) => *r,
        };
        let state_ptr_opt = state_opt.map(Arc::<RwLock<CallFutureState<'_, '_>>>::into_raw);
        match state_ptr_opt {
            Some(state_ptr) => {
                // asynchronous execution
                //
                // # SAFETY:
                // - `callback` is intended as an entrypoint and therefore can be called as both reply and reject fn
                //      for ic0.call_new.
                // - `cleanup` is intended as an entrypoint and therefore can be called as cleanup fn for ic0.call_on_cleanup.
                // - `state_ptr` is a pointer created via Arc::<RwLock<CallFutureState>>::into_raw, and can therefore be passed as the userdata for
                //      `callback` and `cleanup`.
                // - if-and-only-if ic0.call_perform returns 0, exactly one() of `callback` or `cleanup`
                //      receive ownership of `state_ptr`
                // - both functions deallocate `state_ptr`, and this enclosing function deallocates `state_ptr` if ic0.call_perform
                //      returns !=0, and therefore `state_ptr`'s ownership can be passed to FFI without leaking memory.
                //
                //  The flow from outside the WASM runtime is that the callback runs, it traps, state is rolled back,
                //   and the cleanup callback runs afterwards. Inside the runtime, there is no difference between
                //   'state is rolled back to before the callback was called' and 'the callback was never called'.
                //   So from the code's perspective, exactly one function is called.
                unsafe {
                    ic0::call_new(
                        callee,
                        method,
                        callback,
                        state_ptr as usize,
                        callback,
                        state_ptr as usize,
                    );
                    ic0::call_on_cleanup(cleanup, state_ptr as usize);
                }
            }

            None => {
                ic0::call_new_oneway(callee, method);
                // There is no `call_on_cleanup` invocation because:
                // - the callback does not exist, and so cannot trap to require cleanup
                // - under the current behavior of the IC, this produces an error,
                //   which would unconditionally call the cleanup callback
            }
        }
        if !arg.is_empty() {
            ic0::call_data_append(arg);
        }
        if self.cycles > 0 {
            ic0::call_cycles_add128(self.cycles);
        }
        if let Some(timeout_seconds) = self.timeout_seconds {
            ic0::call_with_best_effort_response(timeout_seconds);
        }
        let res = ic0::call_perform();
        if res != 0 {
            if let Some(state_ptr) = state_ptr_opt {
                // SAFETY:
                // - `state_ptr_opt` is `Some` if-and-only-if ic0.call_new was called with ownership of `state`
                // - by returning !=0, ic0.call_new relinquishes ownership of `state_ptr`; it will never be passed
                //      to any functions
                // therefore, there is an outstanding handle to `state`, which it is safe to deallocate
                unsafe {
                    Arc::from_raw(state_ptr);
                }
            }
        }
        res
    }
}

// # Internal =================================================================

/// Internal state for the Future when sending a call.
#[derive(Debug, Default)]
enum CallFutureState<'m, 'a> {
    /// The future has been constructed, and the call has not yet been performed.
    /// Needed because futures are supposed to do nothing unless polled.
    /// Polling will attempt to fire off the request. Success returns `Pending` and transitions to `Executing`,
    /// failure returns `Ready` and transitions to `PostComplete.`
    Prepared { call: Call<'m, 'a> },
    /// The call has been performed and the message is in flight. Neither callback has been called. Polling will return `Pending`.
    /// This state will transition to `Trapped` if the future is canceled because of a trap in another future.
    Executing {
        waker: Waker,
        method: MethodHandle,
        task: Option<TaskHandle>,
    },
    /// `callback` has been called, so the call has been completed. This completion state has not yet been read by the user.
    /// Polling will return `Ready` and transition to `PostComplete`.
    Complete {
        result: Result<Response, CallFailed>,
    },
    /// The completion state of `Complete` has been returned from `poll` as `Poll::Ready`. Polling again will trap.
    #[default]
    PostComplete,
    /// The future (*not* the state) was canceled because of a trap in another future during `Executing`. Polling will trap.
    Trapped,
}

/// Represents a future that resolves to the result of an inter-canister call.
///
/// This type is returned by [`IntoFuture::into_future`] when called on a [`Call`].
/// The [`Call`] type implements the [`IntoFuture`] trait, allowing it to be converted
/// into a [`CallFuture`]. The future can be awaited to retrieve the result of the call.
#[derive(Debug)]
pub struct CallFuture<'m, 'a> {
    state: Arc<RwLock<CallFutureState<'m, 'a>>>,
}

impl std::future::Future for CallFuture<'_, '_> {
    type Output = Result<Response, CallFailed>;

    fn poll(self: Pin<&mut Self>, context: &mut Context<'_>) -> Poll<Self::Output> {
        let self_ref = Pin::into_inner(self);
        let mut state = self_ref.state.write().unwrap();
        match mem::take(&mut *state) {
            CallFutureState::Prepared { call } => {
                if let Err(e) = call.check_liquid_cycle_balance_sufficient() {
                    *state = CallFutureState::PostComplete;
                    Poll::Ready(Err(e.into()))
                } else {
                    match call.perform(Some(self_ref.state.clone())) {
                        0 => {
                            // call_perform returns 0 means the call was successfully enqueued.
                            *state = CallFutureState::Executing {
                                waker: context.waker().clone(),
                                method: ic_cdk_executor::extend_current_method_context(),
                                task: TaskHandle::current(),
                            };
                            Poll::Pending
                        }
                        _ => {
                            *state = CallFutureState::PostComplete;
                            Poll::Ready(Err(CallPerformFailed.into()))
                        }
                    }
                }
            }
            CallFutureState::Executing { method, task, .. } => {
                *state = CallFutureState::Executing {
                    waker: context.waker().clone(),
                    method,
                    task,
                };
                Poll::Pending
            }
            CallFutureState::Complete { result } => {
                *state = CallFutureState::PostComplete;
                Poll::Ready(result)
            }
            CallFutureState::Trapped => trap("Call already trapped"),
            CallFutureState::PostComplete => trap("CallFuture polled after completing"),
        }
    }
}

impl Drop for CallFuture<'_, '_> {
    fn drop(&mut self) {
        // If this future is dropped while is_recovering_from_trap is true,
        // then it has been canceled due to a trap in another future.
        if is_recovering_from_trap() {
            *self.state.write().unwrap() = CallFutureState::Trapped;
        }
    }
}

/// The reply/reject callback for `ic0.call_new`.
///
/// It dereferences the future from a raw pointer, assigns the result and calls the waker.
/// We cannot use a closure here because we pass raw pointers to the System and back.
///
/// # Safety
///
/// This function must only be passed to the IC with a pointer from `Arc::<RwLock<CallFutureState>>::into_raw` as userdata.
unsafe extern "C" fn callback(env: usize) {
    let state_ptr = env as *const RwLock<CallFutureState<'_, '_>>;
    // SAFETY: This function is only ever called by the IC, and we only ever pass an Arc as userdata.
    let state = unsafe { Arc::from_raw(state_ptr) };
    let completed_state = CallFutureState::Complete {
        result: match msg_reject_code() {
            0 => Ok(Response(msg_arg_data())),
            code => {
                // The conversion is safe because the code is not 0.
                Err(CallFailed::CallRejected(CallRejected {
                    raw_reject_code: code,
                    reject_message: msg_reject_msg(),
                }))
            }
        },
    };
    let (waker, method) = match mem::replace(&mut *state.write().unwrap(), completed_state) {
        CallFutureState::Executing { waker, method, .. } => (waker, method),
        // This future has already been cancelled and waking it will do nothing.
        // All that's left is to explicitly trap in case this is the last call being multiplexed,
        // to replace an automatic trap from not replying.
        CallFutureState::Trapped => trap("Call already trapped"),
        _ => {
            unreachable!(
                "CallFutureState for in-flight calls should only be Executing or Trapped (callback)"
            )
        }
    };
    ic_cdk_executor::in_callback_executor_context_for(method, || {
        waker.wake();
    });
}

/// The cleanup callback for `ic0.call_on_cleanup`.
///
/// This function is called when [`callback`] was just called with the same parameter, and trapped.
/// We can't guarantee internal consistency at this point, but we can at least e.g. drop mutex guards.
/// Waker is a very opaque API, so the best we can do is set a global flag and proceed normally.
///
/// # Safety
///
/// This function must only be passed to the IC with a pointer from `Arc::<RwLock<CallFutureState>>::into_raw` as userdata.
unsafe extern "C" fn cleanup(env: usize) {
    let state_ptr = env as *const RwLock<CallFutureState<'_, '_>>;
    // SAFETY: This function is only ever called by the IC, and we only ever pass a Arc as userdata.
    let state = unsafe { Arc::from_raw(state_ptr) };
    // We set the call result, even though it won't be read on the
    // default executor, because we can't guarantee it was called on
    // our executor. However, we are not allowed to inspect
    // reject_code() inside of a cleanup callback, so always set the
    // result to a reject.
    //
    // Borrowing does not trap - the rollback from the
    // previous trap ensures that the RwLock can be borrowed again.
    let err_state = CallFutureState::Complete {
        result: Err(CallFailed::CallRejected(CallRejected {
            raw_reject_code: RejectCode::CanisterReject as u32,
            reject_message: "cleanup".into(),
        })),
    };
    let (method, task) = match mem::replace(&mut *state.write().unwrap(), err_state) {
        CallFutureState::Executing { method, task, .. } => (method, task),
        CallFutureState::Trapped => {
            // The future has already been canceled and dropped. There is nothing
            // more to clean up except for the CallFutureState.
            return;
        }
        _ => {
            unreachable!(
                "CallFutureState for in-flight calls should only be Executing or Trapped (cleanup)"
            )
        }
    };
    ic_cdk_executor::in_trap_recovery_context_for(method, || {
        ic_cdk_executor::cancel_all_tasks_attached_to_current_method();
        if let Some(task) = task {
            ic_cdk_executor::cancel_task(&task);
        }
    });
}

// # Internal END =============================================================

/// Panics with an informative message when argument encoding fails.
///
/// Currently, Candid encoding only fails when heap memory is exhausted,
/// in which case execution would trap before reaching the unwrap.
///
/// However, since future implementations might introduce other failure cases,
/// we provide an informative panic message for better debuggability.
fn panic_when_encode_fails(err: candid::error::Error) -> Vec<u8> {
    panic!("failed to encode args: {err}")
}



================================================
FILE: ic-cdk/src/futures.rs
================================================
//! Functions relating to the async executor.
//!
//! ## Running async tasks
//!
//! Most async tasks can be run just by changing your canister entry point to `async`:
//!
//! ```
//! # use ic_cdk::update;
//! # async fn some_other_async_fn() {}
//! #[update]
//! async fn foo() {
//!     some_other_async_fn().await;
//! }
//! ```
//!
//! To run async tasks in the *background*, however, use [`spawn`]:
//!
//! ```
//! # use ic_cdk::{update, futures::spawn};
//! # async fn some_other_async_fn() {}
//! #[update]
//! async fn foo() {
//!     spawn(async { some_other_async_fn().await; });
//!     // do other stuff
//! }
//! ```
//!
//! The spawned future will not be run at the same time as the remaining code, nor will it run immediately. It will start
//! running while `foo` awaits (or after it ends if it does not await). Unlike some other libraries, `spawn` does not
//! return a join-handle; if you want to await multiple results concurrently, use `futures`' [`join_all`] function.
//!
//! ## Method lifetime
//!
//! The default [`spawn`] function will ensure a task does not outlive the canister method it was spawned in. If
//! the method ends, and the task has `await`s that are not completed yet, it will trap. The method's lifetime lasts until
//! it stops making inter-canister calls. What this means is that any await in a task created with `spawn` should be,
//! or be driven by, an inter-canister call. If you instead await something dependent on a
//! different canister method, or a timer, or similar, it is likely to trap. (This is unlikely to impact you if you
//! don't use any 'remote' futures like channels or signals.)
//!
//! Where a task spawned with [`spawn`] will panic if it outlives the canister method, [`spawn_weak`] will simply
//! cancel the task in such a case, dropping it.
//!
//! Note: for purposes of the executor, each invocation of a repeated [timer] is considered a separate canister method.
//!
//! ## `spawn_migratory`
//!
//! The [`spawn_migratory`] function is a little different. Migratory tasks can outlive the canister method they were
//! spawned in, and will migrate between different canister methods as needed; when awoken, they will resume in whatever
//! context they were awoken in, instead of the context they were originally spawned in. Because they can move around,
//! any functions referencing the current method (i.e. `msg_*`) are unreliable and should not be used from these tasks.
//!
//! "Background" is a tricky subject on the IC. Migratory tasks can only run in the context of a canister message.
//! It takes from that call's instruction limit, which can introduce hidden sources of instruction limit based traps;
//! if that call runs multiple concurrent tasks, state changes made by the migratory task may be observable in between them.
//!
//! Most importantly, a migratory task must never trap. When it traps, it will cancel (see below) the execution of the call
//! whose context it's in, even though that call didn't do anything wrong, and it may not undo whatever caused it to trap,
//! meaning the canister could end up bricked.
//!
//! ## Automatic cancellation
//!
//! Asynchronous tasks can be *canceled*, meaning that a partially completed function will halt at an
//! `await` point, never complete, and drop its local variables as though it had returned. Cancellation
//! (not counting [`spawn_weak`]) is caused by panics and traps: if an async function panics, time will be rewound to the
//! previous await as though the code since then never ran, and then the task will be canceled.
//!
//! When a protected task traps, *all* protected tasks in the method will be canceled, as well as any pending migratory tasks.
//! The system cannot know exactly which task panicked, so a conservatively large 'blast radius' is assumed.
//!
//! Use panics sparingly in async functions after the first await, and beware system functions that trap
//! (which is most of them in the right context). Make atomic transactions between awaits wherever
//! possible, and use [`scopeguard`] or a [`Drop`] impl for any cleanup functions that must run no matter what.
//! If an await cannot be removed from the middle of a transaction, and it must be rolled back if it fails,
//! [`is_recovering_from_trap`] can be used to detect when the task is being automatically canceled.
//!
//! [`scopeguard`]: https://docs.rs/scopeguard
//! [`join_all`]: https://docs.rs/futures/latest/futures/future/fn.join_all.html
//! [timer]: https://docs.rs/ic-cdk-timers
//! [`caller`]: crate::api::caller
//! [`in_replicated_execution`]: crate::api::in_replicated_execution
//! [`canister_self`]: crate::api::canister_self

use std::{
    future::Future,
    pin::Pin,
    sync::{
        Arc,
        atomic::{AtomicBool, Ordering},
    },
    task::{Context, Poll, Wake, Waker},
};

pub mod internals;

/// Spawn a protected asynchronous task to run during the current canister method.
///
/// The task will panic if it outlives the canister method. To cancel it instead, use [`spawn_weak`].
pub fn spawn<F: 'static + Future<Output = ()>>(future: F) {
    pin_project_lite::pin_project! {
        struct ProtectedTask<F> {
            #[pin]
            future: F,
            completed: bool,
        }
        impl<F> PinnedDrop for ProtectedTask<F> {
            #[track_caller]
            fn drop(this: Pin<&mut Self>) {
                if !this.completed && !ic_cdk_executor::is_recovering_from_trap() {
                    panic!("protected task outlived its canister method (did you mean to use spawn_weak or spawn_migratory?)")
                }
            }
        }
    }
    impl<F> Future for ProtectedTask<F>
    where
        F: Future<Output = ()>,
    {
        type Output = ();

        fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
            let this = self.project();
            let res = this.future.poll(cx);
            if res.is_ready() {
                *this.completed = true;
            }
            res
        }
    }
    ic_cdk_executor::spawn_protected(ProtectedTask {
        future,
        completed: false,
    });
}

/// Spawn a weak asynchronous task to run during the current canister method.
///
/// If the task outlives the canister method, it will be dropped.
pub fn spawn_weak<F: 'static + Future<Output = ()>>(future: F) {
    ic_cdk_executor::spawn_protected(future);
}

/// Spawn an asynchronous task that can outlive the current canister method.
pub fn spawn_migratory<F: 'static + Future<Output = ()>>(future: F) {
    ic_cdk_executor::spawn_migratory(future);
}

/// Tells you whether the current async fn is being canceled due to a trap/panic.
///
/// In a destructor, `is_recovering_from_trap` serves the same purpose as
/// [`std::thread::panicking`] - it tells you whether the destructor is executing *because* of a trap,
/// as opposed to just because the scope was exited, so you could e.g. implement mutex poisoning.
///
/// For information about when and how this occurs, see [the module docs](self).
pub fn is_recovering_from_trap() -> bool {
    ic_cdk_executor::is_recovering_from_trap()
}

/// Like `spawn`, but preserves the code ordering behavior of `ic-cdk` 0.17 and before.
///
/// Namely, the spawned future will start executing immediately, with control returning to the surrounding code
/// after the first `await`.
pub fn spawn_017_compat<F: 'static + Future<Output = ()>>(fut: F) {
    struct DummyWaker(AtomicBool);
    impl Wake for DummyWaker {
        fn wake(self: Arc<Self>) {
            self.0.store(true, Ordering::SeqCst);
        }
    }
    // Emulated behavior: A spawned future is polled once immediately, then backgrounded and run at a normal pace.
    // We poll it once with an unimplemented waker, then spawn it, which will poll it again with the real waker.
    // In a correctly implemented future, this second poll should overwrite the fake waker with the real one.
    // If the `poll` function calls `wake`, call it again until it is 'really' pending.
    let mut pin = Box::pin(fut);
    loop {
        let dummy = Arc::new(DummyWaker(AtomicBool::new(false)));
        let poll = pin
            .as_mut()
            .poll(&mut Context::from_waker(&Waker::from(dummy.clone())));
        match poll {
            Poll::Ready(()) => break,
            Poll::Pending => {
                if dummy.0.load(Ordering::SeqCst) {
                    continue;
                } else {
                    spawn(pin);
                    break;
                }
            }
        }
    }
}



================================================
FILE: ic-cdk/src/lib.rs
================================================
#![doc = include_str!("../README.md")]
#![warn(
    elided_lifetimes_in_paths,
    missing_debug_implementations,
    missing_docs,
    unsafe_op_in_unsafe_fn,
    clippy::undocumented_unsafe_blocks,
    clippy::missing_safety_doc
)]
#![cfg_attr(docsrs, feature(doc_cfg))]

#[cfg(target_feature = "atomics")]
compile_error!("This version of the CDK does not support multithreading.");

pub mod api;
pub mod bitcoin_canister;
pub mod call;
pub mod futures;
mod macros;
pub mod management_canister;
pub mod stable;
pub mod storage;

use std::future::Future;

#[doc(inline)]
pub use api::trap;

#[doc(hidden)]
#[allow(deprecated)]
pub use api::{
    call::{call, notify},
    caller, id, print,
};

#[doc(inline)]
pub use macros::*;

/// Format and then print the formatted message
#[cfg(target_family = "wasm")]
#[macro_export]
macro_rules! println {
    ($fmt:expr) => ($crate::api::debug_print(format!($fmt)));
    ($fmt:expr, $($arg:tt)*) => ($crate::api::debug_print(format!($fmt, $($arg)*)));
}

/// Format and then print the formatted message
#[cfg(not(target_family = "wasm"))]
#[macro_export]
macro_rules! println {
    ($fmt:expr) => (std::println!($fmt));
    ($fmt:expr, $($arg:tt)*) => (std::println!($fmt, $($arg)*));
}

/// Format and then print the formatted message
#[cfg(target_family = "wasm")]
#[macro_export]
macro_rules! eprintln {
    ($fmt:expr) => ($crate::api::debug_print(format!($fmt)));
    ($fmt:expr, $($arg:tt)*) => ($crate::api::debug_print(format!($fmt, $($arg)*)));
}

/// Format and then print the formatted message
#[cfg(not(target_family = "wasm"))]
#[macro_export]
macro_rules! eprintln {
    ($fmt:expr) => (std::eprintln!($fmt));
    ($fmt:expr, $($arg:tt)*) => (std::eprintln!($fmt, $($arg)*));
}

#[doc(hidden)]
#[deprecated(
    since = "0.18.0",
    note = "Use ic_cdk::futures::spawn_017_compat. Alternatively, migrate to ic_cdk::futures::spawn;
    code execution order will change, see https://github.com/dfinity/cdk-rs/blob/0.18.3/ic-cdk/V18_GUIDE.md#futures-ordering-changes"
)]
pub fn spawn<F: 'static + Future<Output = ()>>(fut: F) {
    crate::futures::spawn_017_compat(fut);
}



================================================
FILE: ic-cdk/src/macros.rs
================================================
/// Create a `get_candid_pointer` method so that `dfx` can execute it to extract candid definition.
///
/// Call this macro only if you want the Candid export behavior.
/// Only call it once at the end of canister code outside query/update definition.
pub use ic_cdk_macros::export_candid;

/// Register a query call entry point.
///
/// This attribute macro will export a function with name `canister_query <name>`
/// in the canister module.
///
/// # Examples
///
/// ## Basic Usage
///
/// ```rust
/// # use ic_cdk::query;
/// #[query]
/// fn query_function() {
///     // ...
/// # unimplemented!()
/// }
/// ```
///
/// ## Custom Export Name
///
/// You can customize the name of the exported function.
///
/// ```rust
/// # use ic_cdk::query;
/// #[query(name = "some_name")]
/// fn query_function() {
///     // ...
/// # unimplemented!()
/// }
/// ```
///
/// ## Hide From Candid Generation
///
/// If you want to hide this method in the Candid generated by [`export_candid!`],
/// you will need to set `hidden` to `true`. The entry point still exists in the canister.
///
/// ```rust
/// # use ic_cdk::query;
/// #[query(hidden = true)]
/// fn query_function() {
///     // ...
/// # unimplemented!()
/// }
/// ```
///
/// ## Guard Functions
///
/// You can specify one or more guard functions to be executed before the query function.
/// Each guard function must return a `Result<(), String>`.
/// If any guard function returns an error, the query function will not proceed.
///
/// ```rust
/// # use ic_cdk::query;
/// fn guard1() -> Result<(), String> {
///     // ...
/// # unimplemented!()
/// }
/// fn guard2() -> Result<(), String> {
///     // ...
/// # unimplemented!()
/// }
/// #[query(guard = "guard1", guard = "guard2")]
/// fn query_function() {
///     // ...
/// # unimplemented!()
/// }
/// ```
///
/// ## Custom Argument Decoding
///
/// You can specify a custom function to decode the arguments.
/// The function must take a `Vec<u8>` as an argument and return the same type as the query arguments.
///
/// ```rust
/// # use ic_cdk::query;
/// fn decode_args(arg_bytes: Vec<u8>) -> (u32, u32) {
///    // ...
/// # unimplemented!()
/// }
/// #[query(decode_with = "decode_args")]
/// fn query_function(a: u32, b: u32) {
///    // ...
/// # unimplemented!()
/// }
/// ```
///
/// ## Custom Return Value Encoding
///
/// You can specify a custom function to encode the return value.
/// The function must take the query return value as argument and return a `Vec<u8>`.
///
/// ```rust
/// # use ic_cdk::query;
/// fn encode_result(result: (u32, u32)) -> Vec<u8> {
///   // ...
/// # unimplemented!()
/// }
/// #[query(encode_with = "encode_result")]
/// fn query_function() -> (u32, u32) {
///  // ...
/// # unimplemented!()
/// }
/// ```
///
/// ## Composite Queries
///
/// To be able to make inter-canister calls from a query call, it must be a *composite* query (which cannot be executed in replicated mode).
///
/// ```rust
/// # use ic_cdk::query;
/// # fn wallet_canister_principal() -> candid::Principal { unimplemented!() }
/// #[query(composite = true)]
/// async fn composite_query_function() {
///    let (wallet_name,): (Option<String>,) = ic_cdk::call(wallet_canister_principal(), "name", ()).await.unwrap();
/// }
/// ```
///
/// ## Manual Reply
///
/// The query macro defaults to invoke [`msg_reply()`](crate::api::msg_reply) after the function execution.
/// If you want to execute other code after [`msg_reply()`](crate::api::msg_reply), you can:
/// - set `manual_reply` to `true` in macro attribute;
/// - set the return type to `PhantomData<T>` where `T` is the return type of the update method;
/// - call the [`msg_reply()`](crate::api::msg_reply) function explicitly;
/// - do other stuff;
/// - return `PhantomData`;
///
/// ```rust
/// # fn calculate_result() {}
/// # type MyResult = ();
/// # use ic_cdk::query;
/// # use std::marker::PhantomData;
/// #[query(manual_reply = true)]
/// fn query_function() -> PhantomData<MyResult> {
///     let result = calculate_result();
///     let reply_bytes = candid::encode_one(result).unwrap();
///     ic_cdk::api::msg_reply(reply_bytes);
///     PhantomData
/// }
/// ```
pub use ic_cdk_macros::query;

/// Register an update call entry point.
///
/// This attribute macro will export a function with name `canister_update <name>`
/// in the canister module.
///
/// # Examples
///
/// ## Basic Usage
///
/// ```rust
/// # use ic_cdk::update;
/// #[update]
/// fn update_function() {
///     // ...
/// # unimplemented!()
/// }
/// ```
///
/// ## Custom Export Name
///
/// You can customize the name of the exported function.
///
/// ```rust
/// # use ic_cdk::update;
/// #[update(name = "some_name")]
/// fn update_function() {
///     // ...
/// # unimplemented!()
/// }
/// ```
///
/// ## Hide From Candid Generation
///
/// If you want to hide this method in the Candid generated by [`export_candid!`],
/// you will need to set `hidden` to `true`. The entry point still exists in the canister.
///
/// ```rust
/// # use ic_cdk::update;
/// #[update(hidden = true)]
/// fn update_function() {
///     // ...
/// # unimplemented!()
/// }
/// ```
///
/// ## Guard Functions
///
/// You can specify one or more guard functions to be executed before the update function.
/// Each guard function must return a `Result<(), String>`.
/// If any guard function returns an error, the update function will not proceed.
///
/// ```rust
/// # use ic_cdk::update;
/// fn guard1() -> Result<(), String> {
///     // ...
/// # unimplemented!()
/// }
/// fn guard2() -> Result<(), String> {
///     // ...
/// # unimplemented!()
/// }
/// #[update(guard = "guard1", guard = "guard2")]
/// fn update_function() {
///     // ...
/// # unimplemented!()
/// }
/// ```
///
/// ## Custom Argument Decoding
///
/// You can specify a custom function to decode the arguments.
/// The function must take a `Vec<u8>` as an argument and return the same type as the update arguments.
///
/// ```rust
/// # use ic_cdk::update;
/// fn decode_args(arg_bytes: Vec<u8>) -> (u32, u32) {
///    // ...
/// # unimplemented!()
/// }
/// #[update(decode_with = "decode_args")]
/// fn update_function(a: u32, b: u32) {
///    // ...
/// # unimplemented!()
/// }
/// ```
///
/// ## Custom Return Value Encoding
///
/// You can specify a custom function to encode the return value.
/// The function must take the update return value as an argument and return a `Vec<u8>`.
///
/// ```rust
/// # use ic_cdk::update;
/// fn encode_result(result: (u32, u32)) -> Vec<u8> {
///   // ...
/// # unimplemented!()
/// }
/// #[update(encode_with = "encode_result")]
/// fn update_function() -> (u32, u32) {
///  // ...
/// # unimplemented!()
/// }
/// ```
///
/// ## Manual Reply
///
/// The update macro defaults to invoke [`msg_reply()`](crate::api::msg_reply) after the function execution.
/// If you want to execute other code after [`msg_reply()`](crate::api::msg_reply), you can:
/// - set `manual_reply` to `true` in macro attribute;
/// - set the return type to `PhantomData<T>` where `T` is the return type of the update method;
/// - call the [`msg_reply()`](crate::api::msg_reply) function explicitly;
/// - do other stuff;
/// - return `PhantomData`;
///
/// ```rust
/// # fn calculate_result() {}
/// # type MyResult = ();
/// # use ic_cdk::update;
/// # use std::marker::PhantomData;
/// #[update(manual_reply = true)]
/// fn update_function() -> PhantomData<MyResult> {
///     let result = calculate_result();
///     let reply_bytes = candid::encode_one(result).unwrap();
///     ic_cdk::api::msg_reply(reply_bytes);
///     PhantomData
/// }
/// ```
pub use ic_cdk_macros::update;

/// Register the `canister_init` entry point of a canister.
///
/// This attribute macro will export the function `canister_init`
/// in the canister module.
///
/// The function under this attribute must have no return value.
///
/// Each canister can only have one `canister_init` entry point.
///
/// # Example
///
/// ## Basic Usage
///
/// ```rust
/// # use ic_cdk::init;
/// #[init]
/// fn init_function() {
///     // ...
/// # unimplemented!()
/// }
/// ```
///
/// ## Argument
///
/// The `init` function may accept an argument.
///
/// The argument must implement the `CandidType` trait.
///
/// And it should match the initialization parameters of the service constructor in the Candid interface.
///
/// ```rust
/// # use ic_cdk::init;
/// # use candid::*;
/// #[derive(Clone, Debug, CandidType, Deserialize)]
/// struct InitArg {
///     foo: u8,
/// }
///
/// #[init]
/// fn init_function(arg: InitArg) {
///     // ...
/// # unimplemented!()
/// }
/// ```
///
/// In this case, the argument will be read from `ic0.msg_arg_data_size/copy` and passed to the
/// init function upon successful deserialization.
///
/// ## Custom Argument Decoding
///
/// You can specify a custom function to decode the arguments.
/// The function must take a `Vec<u8>` as an argument and return the same type as the init arguments.
///
/// ```rust
/// # use ic_cdk::init;
/// # use candid::*;
/// # #[derive(Clone, Debug, CandidType, Deserialize)]
/// # struct InitArg {
/// #    foo: u8,
/// # }
/// fn decode_args(arg_bytes: Vec<u8>) -> InitArg {
///     // ...
/// # unimplemented!()
/// }
/// #[init(decode_with = "decode_args")]
/// fn init_function(arg: InitArg) {
///     // ...
/// # unimplemented!()
/// }
/// ```
///
/// Refer to the [`canister_init` Specification](https://internetcomputer.org/docs/references/ic-interface-spec/#system-api-init) for more information.
pub use ic_cdk_macros::init;

/// Register the `canister_pre_upgrade` entry point of a canister.
///
/// This attribute macro will export the function `canister_pre_upgrade`
/// in the canister module.
///
/// The function under this attribute must have no return value.
///
/// Each canister can only have one `canister_pre_upgrade` entry point.
///
/// # Example
///
/// ```rust
/// # use ic_cdk::pre_upgrade;
/// #[pre_upgrade]
/// fn pre_upgrade_function() {
///     // ...
/// # unimplemented!()
/// }
/// ```
pub use ic_cdk_macros::pre_upgrade;

/// Register the `canister_post_upgrade` entry point of a canister.
///
/// This attribute macro will export the function `canister_post_upgrade`
/// in the canister module.
///
/// The function under this attribute must have no return value.
///
/// Each canister can only have one `canister_post_upgrade` entry point.
///
/// # Example
///
/// ```rust
/// # use ic_cdk::post_upgrade;
/// #[post_upgrade]
/// fn post_upgrade_function() {
///     // ...
/// # unimplemented!()
/// }
/// ```
///
/// ## Argument
///
/// The `post_upgrade` function may accept an argument.
///
/// The argument must implement the `CandidType` trait.
///
/// And it should match the initialization parameters of the service constructor in the Candid interface.
/// Therefore, the `init` function and the `post_upgrade` function should take the same argument type.
///
/// ```rust
/// # use ic_cdk::post_upgrade;
/// # use candid::*;
/// #[derive(Clone, Debug, CandidType, Deserialize)]
/// struct InitArg {
///     foo: u8,
/// }
///
/// #[post_upgrade]
/// fn post_upgrade_function(arg: InitArg) {
///     // ...
/// # unimplemented!()
/// }
/// ```
///
/// In this case, the argument will be read from `ic0.msg_arg_data_size/copy` and passed to the
/// `post_upgrade` function upon successful deserialization.
///
/// ## Custom Argument Decoding
///
/// You can specify a custom function to decode the arguments.
/// The function must take a `Vec<u8>` as an argument and return the same type as the `post_upgrade` arguments.
///
/// ```rust
/// # use ic_cdk::post_upgrade;
/// # use candid::*;
/// # #[derive(Clone, Debug, CandidType, Deserialize)]
/// # struct InitArg {
/// #    foo: u8,
/// # }
/// fn decode_args(arg_bytes: Vec<u8>) -> InitArg {
///    // ...
/// # unimplemented!()
/// }
/// #[post_upgrade(decode_with = "decode_args")]
/// fn post_upgrade_function(arg: InitArg) {
///    // ...
/// # unimplemented!()
/// }
/// ```
pub use ic_cdk_macros::post_upgrade;

/// Register the `canister_heartbeat` entry point of a canister.
///
/// This attribute macro will export the function `canister_heartbeat`
/// in the canister module.
///
/// The function under this attribute must have no return value.
///
/// Each canister can only have one `canister_heartbeat` entry point.
///
/// # Example
///
/// ```rust
/// # use ic_cdk::heartbeat;
/// #[heartbeat]
/// fn heartbeat_function() {
///     // ...
/// # unimplemented!()
/// }
/// ```
pub use ic_cdk_macros::heartbeat;

/// Register the `canister_inspect_message` entry point of a canister.
///
/// This attribute macro will export the function `canister_inspect_message`
/// in the canister module.
///
/// The function under this attribute must have no return value.
///
/// Each canister can only have one `canister_inspect_message` entry point.
///
/// # Example
///
/// ```rust
/// # use ic_cdk::inspect_message;
/// #[inspect_message]
/// fn inspect_message_function() {
///     // ...
/// # unimplemented!()
/// }
/// ```
pub use ic_cdk_macros::inspect_message;

/// Register the `canister_on_low_wasm_memory` entry point of a canister.
///
/// This attribute macro will export the function `canister_on_low_wasm_memory`
/// in the canister module.
///
/// The function under this attribute must have no return value.
///
/// Each canister can only have one `canister_on_low_wasm_memory` entry point.
///
/// # Example
///
/// ```rust
/// # use ic_cdk::on_low_wasm_memory;
/// #[on_low_wasm_memory]
/// fn low_memory_handler() {
///     // ...
/// # unimplemented!()
/// }
/// ```
pub use ic_cdk_macros::on_low_wasm_memory;



================================================
FILE: ic-cdk/src/management_canister.rs
================================================
//! Functions and types for interacting with the [IC management canister](https://internetcomputer.org/docs/current/references/ic-interface-spec/#ic-management-canister).
//!
//! # Type Definitions
//!
//! This module defines the types of arguments and results for the management canister entry points.
//! Most of these types are re-exported from the `ic-management-canister-types` crate.
//!
//! The only exception is that for the argument types that has a `sender_canister_version` field, this module provides reduced versions instead.
//! The reduced versions don't need the `sender_canister_version` field as it is set automatically in the corresponding functions.
//!
//! # Call
//!
//! The majority of the functions in this module are for making calls to the management canister.
//!
//! ## Bounded-wait vs. Unbounded-wait
//!
//! Interacting with the IC management canister involves making inter-canister calls,
//! which can be either [bounded-wait](crate::call::Call::bounded_wait) or [unbounded-wait](crate::call::Call::unbounded_wait).
//! This module selects the appropriate type of wait call for each method based on the characteristics of the entry point.
//!
//! The strategy for choosing the type of wait call is as follows:
//! - Unbounded-wait call by default because the management canister is universally trusted.
//! - Bounded-wait call (with the default 300s timeout) for methods that only read state.
//!
//! Please check the documentation of each function for the type of wait call it uses.
//!
//! If the default behavior is not suitable for a particular use case, the [`Call`] struct can be used directly to make the call.
//!
//! For example, [`sign_with_ecdsa`] makes an unbounded-wait call. If a bounded-wait call is preferred, the call can be made as follows:
//! ```rust, no_run
//! # use ic_cdk::management_canister::{cost_sign_with_ecdsa, SignCallError, SignWithEcdsaArgs, SignWithEcdsaResult};
//! # use ic_cdk::call::Call;
//! # use candid::Principal;
//! # async fn example() -> Result<SignWithEcdsaResult, SignCallError> {
//! let callee = Principal::management_canister();
//! let arg = SignWithEcdsaArgs::default();
//! let cycles = cost_sign_with_ecdsa(&arg)?;
//! let res: SignWithEcdsaResult = Call::bounded_wait(callee, "sign_with_ecdsa")
//!     .with_arg(&arg)
//!     .with_cycles(cycles)
//!     .await?
//!     .candid()?;
//! # Ok(res)
//! # }
//! ```
//!
//! ## Cycle Cost
//!
//! Some management canister entry points require cycles to be attached to the call.
//! The functions for calling management canister automatically calculate the required cycles and attach them to the call.
//!
//! For completeness, this module also provides functions to calculate the cycle cost:
//! - [`cost_http_request`]
//! - [`cost_sign_with_ecdsa`]
//! - [`cost_sign_with_schnorr`]
//! - [`cost_vetkd_derive_key`]

use crate::api::{
    SignCostError, canister_version, cost_create_canister,
    cost_http_request as ic0_cost_http_request, cost_sign_with_ecdsa as ic0_cost_sign_with_ecdsa,
    cost_sign_with_schnorr as ic0_cost_sign_with_schnorr,
    cost_vetkd_derive_key as ic0_cost_vetkd_derive_key,
};
use crate::call::{Call, CallFailed, CallResult, CandidDecodeFailed};
use candid::{CandidType, Nat, Principal};
use serde::{Deserialize, Serialize};

// Re-export types from the `ic-management-canister-types` crate.
pub use ic_management_canister_types::{
    Bip341, CanisterId, CanisterInfoArgs, CanisterInfoResult, CanisterInstallMode,
    CanisterSettings, CanisterStatusArgs, CanisterStatusResult, CanisterStatusType, Change,
    ChangeDetails, ChangeOrigin, ChunkHash, ClearChunkStoreArgs, CodeDeploymentMode,
    CodeDeploymentRecord, ControllersChangeRecord, CreateCanisterResult, CreationRecord,
    DefiniteCanisterSettings, DeleteCanisterArgs, DeleteCanisterSnapshotArgs, DepositCyclesArgs,
    EcdsaCurve, EcdsaKeyId, EcdsaPublicKeyArgs, EcdsaPublicKeyResult, EnvironmentVariable,
    FromCanisterRecord, FromUserRecord, HttpHeader, HttpMethod, HttpRequestArgs, HttpRequestResult,
    ListCanisterSnapshotsArgs, ListCanisterSnapshotsResult, LoadSnapshotRecord, LogVisibility,
    NodeMetrics, NodeMetricsHistoryArgs, NodeMetricsHistoryRecord, NodeMetricsHistoryResult,
    ProvisionalCreateCanisterWithCyclesResult, ProvisionalTopUpCanisterArgs, QueryStats,
    RawRandResult, SchnorrAlgorithm, SchnorrAux, SchnorrKeyId, SchnorrPublicKeyArgs,
    SchnorrPublicKeyResult, SettingsChangeRecord, SignWithEcdsaArgs, SignWithEcdsaResult,
    SignWithSchnorrArgs, SignWithSchnorrResult, Snapshot, SnapshotId, StartCanisterArgs,
    StopCanisterArgs, StoredChunksArgs, StoredChunksResult, SubnetInfoArgs, SubnetInfoResult,
    TakeCanisterSnapshotArgs, TakeCanisterSnapshotResult, TransformArgs, TransformContext,
    TransformFunc, UpgradeFlags, UploadChunkArgs, UploadChunkResult, VetKDCurve,
    VetKDDeriveKeyArgs, VetKDDeriveKeyResult, VetKDKeyId, VetKDPublicKeyArgs, VetKDPublicKeyResult,
    WasmMemoryPersistence, WasmModule,
};
// Following Args types contain `sender_canister_version` field which is set automatically in the corresponding functions.
// We provide reduced versions of these types to avoid duplication of the field.
use ic_management_canister_types::{
    CreateCanisterArgs as CreateCanisterArgsComplete,
    InstallChunkedCodeArgs as InstallChunkedCodeArgsComplete,
    InstallCodeArgs as InstallCodeArgsComplete,
    LoadCanisterSnapshotArgs as LoadCanisterSnapshotArgsComplete,
    ProvisionalCreateCanisterWithCyclesArgs as ProvisionalCreateCanisterWithCyclesArgsComplete,
    UninstallCodeArgs as UninstallCodeArgsComplete,
    UpdateSettingsArgs as UpdateSettingsArgsComplete,
};

/// The error type for the [`sign_with_ecdsa`] and [`sign_with_schnorr`] functions.
#[derive(thiserror::Error, Debug, Clone)]
pub enum SignCallError {
    /// The signature cost calculation failed.
    #[error(transparent)]
    SignCostError(#[from] SignCostError),
    /// Failed to make the inter-canister call to the management canister.
    #[error(transparent)]
    CallFailed(#[from] CallFailed),
    /// Failed to decode the response from the management canister.
    #[error(transparent)]
    CandidDecodeFailed(#[from] CandidDecodeFailed),
}

/// Creates a new canister.
///
/// **Unbounded-wait call**
///
/// See [IC method `create_canister`](https://internetcomputer.org/docs/current/references/ic-interface-spec/#ic-create_canister).
///
/// # Note
///
/// Canister creation costs cycles. That amount will be deducted from the newly created canister.
/// This method will only attach the required cycles for the canister creation (detemined by [`cost_create_canister`]).
/// The new canister will have a 0 cycle balance.
///
/// To ensure the new canister has extra cycles after creation, use [`create_canister_with_extra_cycles`] instead.
///
/// Cycles can also be deposited to the new canister using [`deposit_cycles`].
///
/// Check [Gas and cycles cost](https://internetcomputer.org/docs/current/developer-docs/gas-cost#canister-creation) for more details.
pub async fn create_canister(arg: &CreateCanisterArgs) -> CallResult<CreateCanisterResult> {
    let complete_arg = CreateCanisterArgsComplete {
        settings: arg.settings.clone(),
        sender_canister_version: Some(canister_version()),
    };
    let cycles = cost_create_canister();
    Ok(
        Call::unbounded_wait(Principal::management_canister(), "create_canister")
            .with_arg(&complete_arg)
            .with_cycles(cycles)
            .await?
            .candid()?,
    )
}

/// Creates a new canister with extra cycles.
///
/// **Unbounded-wait call**
///
/// See [IC method `create_canister`](https://internetcomputer.org/docs/current/references/ic-interface-spec/#ic-create_canister).
///
/// # Note
///
/// Canister creation costs cycles. That amount will be deducted from the newly created canister.
/// This method will attach the required cycles for the canister creation (detemined by [`cost_create_canister`]) plus the `extra_cycles` to the call.
/// The new cansiter will have a cycle balance of `extra_cycles`.
///
/// To simply create a canister with 0 cycle balance, use [`create_canister`] instead.
///
/// Check [Gas and cycles cost](https://internetcomputer.org/docs/current/developer-docs/gas-cost#canister-creation) for more details.
pub async fn create_canister_with_extra_cycles(
    arg: &CreateCanisterArgs,
    extra_cycles: u128,
) -> CallResult<CreateCanisterResult> {
    let complete_arg = CreateCanisterArgsComplete {
        settings: arg.settings.clone(),
        sender_canister_version: Some(canister_version()),
    };
    let cycles = cost_create_canister() + extra_cycles;
    Ok(
        Call::unbounded_wait(Principal::management_canister(), "create_canister")
            .with_arg(&complete_arg)
            .with_cycles(cycles)
            .await?
            .candid()?,
    )
}

/// Argument type of [`create_canister`] and [`create_canister_with_extra_cycles`].
///
/// # Note
///
/// This type is a reduced version of [`ic_management_canister_types::CreateCanisterArgs`].
///
/// The `sender_canister_version` field is removed as it is set automatically in [`create_canister`] and [`create_canister_with_extra_cycles`].
#[derive(
    CandidType, Serialize, Deserialize, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Default,
)]
pub struct CreateCanisterArgs {
    /// See [`CanisterSettings`].
    pub settings: Option<CanisterSettings>,
}

/// Updates the settings of a canister.
///
/// **Unbounded-wait call**
///
/// See [IC method `update_settings`](https://internetcomputer.org/docs/current/references/ic-interface-spec/#ic-update_settings).
pub async fn update_settings(arg: &UpdateSettingsArgs) -> CallResult<()> {
    let complete_arg = UpdateSettingsArgsComplete {
        canister_id: arg.canister_id,
        settings: arg.settings.clone(),
        sender_canister_version: Some(canister_version()),
    };
    Ok(
        Call::unbounded_wait(Principal::management_canister(), "update_settings")
            .with_arg(&complete_arg)
            .await?
            .candid()?,
    )
}

/// Argument type of [`update_settings`]
///
/// # Note
///
/// This type is a reduced version of [`ic_management_canister_types::UpdateSettingsArgs`].
///
/// The `sender_canister_version` field is removed as it is set automatically in [`update_settings`].
#[derive(
    CandidType, Serialize, Deserialize, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone,
)]
pub struct UpdateSettingsArgs {
    /// Canister ID.
    pub canister_id: CanisterId,
    /// See [`CanisterSettings`].
    pub settings: CanisterSettings,
}

/// Uploads a chunk to the chunk store of a canister.
///
/// **Unbounded-wait call**
///
/// See [IC method `upload_chunk`](https://internetcomputer.org/docs/current/references/ic-interface-spec/#ic-upload_chunk).
pub async fn upload_chunk(arg: &UploadChunkArgs) -> CallResult<UploadChunkResult> {
    Ok(
        Call::unbounded_wait(Principal::management_canister(), "upload_chunk")
            .with_arg(arg)
            .await?
            .candid()?,
    )
}

/// Clears the chunk store of a canister.
///
/// **Unbounded-wait call**
///
/// See [IC method `clear_chunk_store`](https://internetcomputer.org/docs/current/references/ic-interface-spec/#ic-clear_chunk_store).
pub async fn clear_chunk_store(arg: &ClearChunkStoreArgs) -> CallResult<()> {
    Ok(
        Call::unbounded_wait(Principal::management_canister(), "clear_chunk_store")
            .with_arg(arg)
            .await?
            .candid()?,
    )
}

/// Gets the hashes of all chunks stored in the chunk store of a canister.
///
/// **Bounded-wait call**
///
/// See [IC method `stored_chunks`](https://internetcomputer.org/docs/current/references/ic-interface-spec/#ic-stored_chunks).
pub async fn stored_chunks(arg: &StoredChunksArgs) -> CallResult<StoredChunksResult> {
    Ok(
        Call::bounded_wait(Principal::management_canister(), "stored_chunks")
            .with_arg(arg)
            .await?
            .candid()?,
    )
}

/// Installs code into a canister.
///
/// **Unbounded-wait call**
///
/// See [IC method `install_code`](https://internetcomputer.org/docs/current/references/ic-interface-spec/#ic-install_code).
pub async fn install_code(arg: &InstallCodeArgs) -> CallResult<()> {
    let complete_arg = InstallCodeArgsComplete {
        mode: arg.mode,
        canister_id: arg.canister_id,
        wasm_module: arg.wasm_module.clone(),
        arg: arg.arg.clone(),
        sender_canister_version: Some(canister_version()),
    };
    Ok(
        Call::unbounded_wait(Principal::management_canister(), "install_code")
            .with_arg(&complete_arg)
            .await?
            .candid()?,
    )
}

/// Argument type of [`install_code`].
///
/// # Note
///
/// This type is a reduced version of [`ic_management_canister_types::InstallCodeArgs`].
///
/// The `sender_canister_version` field is removed as it is set automatically in [`install_code`].
#[derive(
    CandidType, Serialize, Deserialize, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone,
)]
pub struct InstallCodeArgs {
    /// See [`CanisterInstallMode`].
    pub mode: CanisterInstallMode,
    /// Canister ID.
    pub canister_id: CanisterId,
    /// Code to be installed.
    pub wasm_module: WasmModule,
    /// The argument to be passed to `canister_init` or `canister_post_upgrade`.
    #[serde(with = "serde_bytes")]
    pub arg: Vec<u8>,
}

/// Installs code into a canister where the code has previously been uploaded in chunks.
///
/// **Unbounded-wait call**
///
/// See [IC method `install_chunked_code`](https://internetcomputer.org/docs/current/references/ic-interface-spec/#ic-install_chunked_code).
pub async fn install_chunked_code(arg: &InstallChunkedCodeArgs) -> CallResult<()> {
    let complete_arg = InstallChunkedCodeArgsComplete {
        mode: arg.mode,
        target_canister: arg.target_canister,
        store_canister: arg.store_canister,
        chunk_hashes_list: arg.chunk_hashes_list.clone(),
        wasm_module_hash: arg.wasm_module_hash.clone(),
        arg: arg.arg.clone(),
        sender_canister_version: Some(canister_version()),
    };
    Ok(
        Call::unbounded_wait(Principal::management_canister(), "install_chunked_code")
            .with_arg(&complete_arg)
            .await?
            .candid()?,
    )
}

/// Argument type of [`install_chunked_code`].
///
/// # Note
///
/// This type is a reduced version of [`ic_management_canister_types::InstallChunkedCodeArgs`].
///
/// The `sender_canister_version` field is removed as it is set automatically in [`install_chunked_code`].
#[derive(
    CandidType, Serialize, Deserialize, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone,
)]
pub struct InstallChunkedCodeArgs {
    /// See [`CanisterInstallMode`].
    pub mode: CanisterInstallMode,
    /// Principal of the canister being installed.
    pub target_canister: CanisterId,
    /// The canister in whose chunk storage the chunks are stored (defaults to `target_canister` if not specified).
    pub store_canister: Option<CanisterId>,
    /// The list of chunks that make up the canister wasm.
    pub chunk_hashes_list: Vec<ChunkHash>,
    /// The sha256 hash of the wasm.
    #[serde(with = "serde_bytes")]
    pub wasm_module_hash: Vec<u8>,
    /// The argument to be passed to `canister_init` or `canister_post_upgrade`.
    #[serde(with = "serde_bytes")]
    pub arg: Vec<u8>,
}

/// Removes a canister's code and state, making the canister empty again.
///
/// **Unbounded-wait call**
///
/// See [IC method `uninstall_code`](https://internetcomputer.org/docs/current/references/ic-interface-spec/#ic-uninstall_code).
pub async fn uninstall_code(arg: &UninstallCodeArgs) -> CallResult<()> {
    let complete_arg = UninstallCodeArgsComplete {
        canister_id: arg.canister_id,
        sender_canister_version: Some(canister_version()),
    };
    Ok(
        Call::unbounded_wait(Principal::management_canister(), "uninstall_code")
            .with_arg(&complete_arg)
            .await?
            .candid()?,
    )
}

/// Argument type of [`uninstall_code`].
///
/// # Note
///
/// This type is a reduced version of [`ic_management_canister_types::UninstallCodeArgs`].
///
/// The `sender_canister_version` field is removed as it is set automatically in [`uninstall_code`].
#[derive(
    CandidType, Serialize, Deserialize, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone,
)]
pub struct UninstallCodeArgs {
    /// Canister ID.
    pub canister_id: CanisterId,
}

/// Starts a canister if the canister status was `stopped` or `stopping`.
///
/// **Unbounded-wait call**
///
/// See [IC method `start_canister`](https://internetcomputer.org/docs/current/references/ic-interface-spec/#ic-start_canister).
pub async fn start_canister(arg: &StartCanisterArgs) -> CallResult<()> {
    Ok(
        Call::unbounded_wait(Principal::management_canister(), "start_canister")
            .with_arg(arg)
            .await?
            .candid()?,
    )
}

/// Stops a canister.
///
/// **Unbounded-wait call**
///
/// See [IC method `stop_canister`](https://internetcomputer.org/docs/current/references/ic-interface-spec/#ic-stop_canister).
pub async fn stop_canister(arg: &StopCanisterArgs) -> CallResult<()> {
    Ok(
        Call::unbounded_wait(Principal::management_canister(), "stop_canister")
            .with_arg(arg)
            .await?
            .candid()?,
    )
}

/// Gets status information about the canister.
///
/// **Bounded-wait call**
///
/// See [IC method `canister_status`](https://internetcomputer.org/docs/current/references/ic-interface-spec/#ic-canister_status).
pub async fn canister_status(arg: &CanisterStatusArgs) -> CallResult<CanisterStatusResult> {
    Ok(
        Call::bounded_wait(Principal::management_canister(), "canister_status")
            .with_arg(arg)
            .await?
            .candid()?,
    )
}

/// Gets public information about the canister.
///
/// **Bounded-wait call**
///
/// See [IC method `canister_info`](https://internetcomputer.org/docs/current/references/ic-interface-spec/#ic-canister_info).
pub async fn canister_info(arg: &CanisterInfoArgs) -> CallResult<CanisterInfoResult> {
    Ok(
        Call::bounded_wait(Principal::management_canister(), "canister_info")
            .with_arg(arg)
            .await?
            .candid()?,
    )
}

/// Deletes a canister.
///
/// **Unbounded-wait call**
///
/// See [IC method `delete_canister`](https://internetcomputer.org/docs/current/references/ic-interface-spec/#ic-delete_canister).
pub async fn delete_canister(arg: &DeleteCanisterArgs) -> CallResult<()> {
    Ok(
        Call::unbounded_wait(Principal::management_canister(), "delete_canister")
            .with_arg(arg)
            .await?
            .candid()?,
    )
}

/// Deposits cycles to a canister.
///
/// **Unbounded-wait call**
///
/// See [IC method `deposit_cycles`](https://internetcomputer.org/docs/current/references/ic-interface-spec/#ic-deposit_cycles).
pub async fn deposit_cycles(arg: &DepositCyclesArgs, cycles: u128) -> CallResult<()> {
    Ok(
        Call::unbounded_wait(Principal::management_canister(), "deposit_cycles")
            .with_arg(arg)
            .with_cycles(cycles)
            .await?
            .candid()?,
    )
}

/// Gets 32 pseudo-random bytes.
///
/// **Bounded-wait call**
///
/// See [IC method `raw_rand`](https://internetcomputer.org/docs/current/references/ic-interface-spec/#ic-raw_rand).
pub async fn raw_rand() -> CallResult<RawRandResult> {
    Ok(
        Call::bounded_wait(Principal::management_canister(), "raw_rand")
            .await?
            .candid()?,
    )
}

/// Calculates the cost of making an HTTP outcall with the given [`HttpRequestArgs`].
///
/// [`http_request`] and [`http_request_with_closure`] invoke this method internally and attach the required cycles to the call.
///
/// # Note
///
/// Alternatively, [`api::cost_http_request`][ic0_cost_http_request] requires manually calculating the request size and the maximum response size.
/// This method handles the calculation internally.
pub fn cost_http_request(arg: &HttpRequestArgs) -> u128 {
    let request_size = (arg.url.len()
        + arg
            .headers
            .iter()
            .map(|h| h.name.len() + h.value.len())
            .sum::<usize>()
        + arg.body.as_ref().map_or(0, |b| b.len())
        + arg
            .transform
            .as_ref()
            .map_or(0, |t| t.context.len() + t.function.0.method.len()))
        as u64;
    // As stated here: https://internetcomputer.org/docs/references/ic-interface-spec#ic-http_request:
    // "The upper limit on the maximal size for the response is 2MB (2,000,000B) and this value also applies if no maximal size value is specified."
    let max_res_bytes = arg.max_response_bytes.unwrap_or(2_000_000);
    ic0_cost_http_request(request_size, max_res_bytes)
}

/// Makes an HTTP outcall.
///
/// **Unbounded-wait call**
///
/// See [IC method `http_request`](https://internetcomputer.org/docs/current/references/ic-interface-spec/#ic-http_request).
///
/// # Note
///
/// HTTP outcall costs cycles which varies with the request size and the maximum response size.
/// This method attaches the required cycles (detemined by [`cost_http_request`]) to the call.
///
/// Check [HTTPS outcalls cycles cost](https://internetcomputer.org/docs/current/developer-docs/gas-cost#https-outcalls) for more details.
pub async fn http_request(arg: &HttpRequestArgs) -> CallResult<HttpRequestResult> {
    let cycles = cost_http_request(arg);
    Ok(
        Call::unbounded_wait(Principal::management_canister(), "http_request")
            .with_arg(arg)
            .with_cycles(cycles)
            .await?
            .candid()?,
    )
}

/// Constructs a [`TransformContext`] from a query method name and context.
pub fn transform_context_from_query(
    candid_function_name: String,
    context: Vec<u8>,
) -> TransformContext {
    TransformContext {
        context,
        function: TransformFunc(candid::Func {
            method: candid_function_name,
            principal: crate::api::canister_self(),
        }),
    }
}

#[cfg(feature = "transform-closure")]
mod transform_closure {
    use super::{
        CallResult, HttpRequestArgs, HttpRequestResult, Principal, TransformArgs, http_request,
        transform_context_from_query,
    };
    use candid::{decode_one, encode_one};
    use slotmap::{DefaultKey, Key, KeyData, SlotMap};
    use std::cell::RefCell;

    thread_local! {
        #[allow(clippy::type_complexity)]
        static TRANSFORMS: RefCell<SlotMap<DefaultKey, Box<dyn FnOnce(HttpRequestResult) -> HttpRequestResult>>> = RefCell::default();
    }

    #[cfg_attr(
        target_family = "wasm",
        unsafe(export_name = "canister_query <ic-cdk internal> http_transform")
    )]
    #[cfg_attr(
        not(target_family = "wasm"),
        unsafe(export_name = "canister_query_ic_cdk_internal.http_transform")
    )]
    extern "C" fn http_transform() {
        ic_cdk_executor::in_tracking_query_executor_context(|| {
            use crate::api::{msg_arg_data, msg_caller, msg_reply};
            if msg_caller() != Principal::management_canister() {
                crate::trap(
                    "This function is internal to ic-cdk and should not be called externally.",
                );
            }
            let arg_bytes = msg_arg_data();
            let transform_args: TransformArgs = decode_one(&arg_bytes).unwrap();
            let int = u64::from_be_bytes(transform_args.context[..].try_into().unwrap());
            let key = DefaultKey::from(KeyData::from_ffi(int));
            let func = TRANSFORMS.with(|transforms| transforms.borrow_mut().remove(key));
            let Some(func) = func else {
                crate::trap(format!("Missing transform function for request {int}"));
            };
            let transformed = func(transform_args.response);
            let encoded = encode_one(transformed).unwrap();
            msg_reply(encoded);
        });
    }

    /// Makes an HTTP outcall and transforms the response using a closure.
    ///
    /// **Unbounded-wait call**
    ///
    /// See [IC method `http_request`](https://internetcomputer.org/docs/current/references/ic-interface-spec/#ic-http_request).
    ///
    /// # Panics
    ///
    /// This method will panic if the `transform` field in `arg` is not `None`,
    /// as it would conflict with the transform function provided by the closure.
    ///
    /// # Note
    ///
    /// This method provides a straightforward way to transform the HTTP outcall result.
    /// If you need to specify a custom transform [`context`](`ic_management_canister_types::TransformContext::context`),
    /// please use [`http_request`] instead.
    ///
    /// HTTP outcall costs cycles which varies with the request size and the maximum response size.
    /// This method attaches the required cycles (detemined by [`cost_http_request`](crate::api::cost_http_request)) to the call.
    ///
    /// Check [Gas and cycles cost](https://internetcomputer.org/docs/current/developer-docs/gas-cost) for more details.
    #[cfg_attr(docsrs, doc(cfg(feature = "transform-closure")))]
    pub async fn http_request_with_closure(
        arg: &HttpRequestArgs,
        transform_func: impl FnOnce(HttpRequestResult) -> HttpRequestResult + 'static,
    ) -> CallResult<HttpRequestResult> {
        assert!(
            arg.transform.is_none(),
            "The `transform` field in `HttpRequestArgs` must be `None` when using a closure"
        );
        let transform_func = Box::new(transform_func) as _;
        let key = TRANSFORMS.with(|transforms| transforms.borrow_mut().insert(transform_func));
        struct DropGuard(DefaultKey);
        impl Drop for DropGuard {
            fn drop(&mut self) {
                TRANSFORMS.with(|transforms| transforms.borrow_mut().remove(self.0));
            }
        }
        let key = DropGuard(key);
        let context = key.0.data().as_ffi().to_be_bytes().to_vec();
        let arg = HttpRequestArgs {
            transform: Some(transform_context_from_query(
                "<ic-cdk internal> http_transform".to_string(),
                context,
            )),
            ..arg.clone()
        };
        http_request(&arg).await
    }
}

#[cfg(feature = "transform-closure")]
pub use transform_closure::http_request_with_closure;

/// Gets a SEC1 encoded ECDSA public key for the given canister using the given derivation path.
///
/// **Bounded-wait call**
///
/// See [IC method `ecdsa_public_key`](https://internetcomputer.org/docs/current/references/ic-interface-spec/#ic-ecdsa_public_key).
pub async fn ecdsa_public_key(arg: &EcdsaPublicKeyArgs) -> CallResult<EcdsaPublicKeyResult> {
    Ok(
        Call::bounded_wait(Principal::management_canister(), "ecdsa_public_key")
            .with_arg(arg)
            .await?
            .candid()?,
    )
}

/// Calculates the cost of ECDSA signanature with the given [`SignWithEcdsaArgs`].
///
/// [`sign_with_ecdsa`] invokes this method internally and attaches the required cycles to the call.
///
/// # Note
///
/// Alternatively, [`api::cost_sign_with_ecdsa`][ic0_cost_sign_with_ecdsa] takes the numeric representation of the curve.
pub fn cost_sign_with_ecdsa(arg: &SignWithEcdsaArgs) -> Result<u128, SignCostError> {
    ic0_cost_sign_with_ecdsa(&arg.key_id.name, arg.key_id.curve.into())
}

/// Gets a new ECDSA signature of the given `message_hash` with a user-specified amount of cycles.
///
/// **Unbounded-wait call**
///
/// The signature can be separately verified against a derived ECDSA public key.
///
/// See [IC method `sign_with_ecdsa`](https://internetcomputer.org/docs/current/references/ic-interface-spec/#ic-sign_with_ecdsa).
///
/// # Errors
///
/// This method returns an error of type [`SignCallError`].
///
/// The signature cost calculation may fail before the inter-canister call is made, resulting in a [`SignCallError::SignCostError`].
///
/// Since the call argument is constructed as [`SignWithEcdsaArgs`], the `ecdsa_curve` field is guaranteed to be valid.
/// Therefore, [`SignCostError::InvalidCurveOrAlgorithm`] should not occur. If it does, it is likely an issue with the IC. Please report it.
///
/// # Note
///
/// Signature costs cycles which varies for different curves and key names.
/// This method attaches the required cycles (detemined by [`cost_sign_with_ecdsa`]) to the call.
///
/// Check [Threshold signatures](https://internetcomputer.org/docs/current/references/t-sigs-how-it-works/#api-fees) for more details.
pub async fn sign_with_ecdsa(
    arg: &SignWithEcdsaArgs,
) -> Result<SignWithEcdsaResult, SignCallError> {
    let cycles = cost_sign_with_ecdsa(arg)?;
    Ok(
        Call::unbounded_wait(Principal::management_canister(), "sign_with_ecdsa")
            .with_arg(arg)
            .with_cycles(cycles)
            .await?
            .candid()?,
    )
}

/// Gets a SEC1 encoded Schnorr public key for the given canister using the given derivation path.
///
/// **Bounded-wait call**
///
/// See [IC method `schnorr_public_key`](https://internetcomputer.org/docs/current/references/ic-interface-spec/#ic-schnorr_public_key).
pub async fn schnorr_public_key(arg: &SchnorrPublicKeyArgs) -> CallResult<SchnorrPublicKeyResult> {
    Ok(
        Call::bounded_wait(Principal::management_canister(), "schnorr_public_key")
            .with_arg(arg)
            .await?
            .candid()?,
    )
}

/// Calculates the cost of Schnorr signanature with the given [`SignWithSchnorrArgs`].
///
/// [`sign_with_schnorr`] invokes this method internally and attaches the required cycles to the call.
///
/// # Note
///
/// Alternatively, [`api::cost_sign_with_schnorr`][ic0_cost_sign_with_schnorr] takes the numeric representation of the algorithm.
pub fn cost_sign_with_schnorr(arg: &SignWithSchnorrArgs) -> Result<u128, SignCostError> {
    ic0_cost_sign_with_schnorr(&arg.key_id.name, arg.key_id.algorithm.into())
}

/// Gets a new Schnorr signature of the given message with a user-specified amount of cycles.
///
/// **Unbounded-wait call**
///
/// The signature can be separately verified against a derived Schnorr public key.
///
/// See [IC method `sign_with_schnorr`](https://internetcomputer.org/docs/current/references/ic-interface-spec/#ic-sign_with_schnorr).
///
/// # Errors
///
/// This method returns an error of type [`SignCallError`].
///
/// The signature cost calculation may fail before the inter-canister call is made, resulting in a [`SignCallError::SignCostError`].
///
/// Since the call argument is constructed as [`SignWithSchnorrArgs`], the `algorithm` field is guaranteed to be valid.
/// Therefore, [`SignCostError::InvalidCurveOrAlgorithm`] should not occur. If it does, it is likely an issue with the IC. Please report it.
///
/// # Note
///
/// Signature costs cycles which varies for different algorithms and key names.
/// This method attaches the required cycles (detemined by [`cost_sign_with_schnorr`]) to the call.
///
/// Check [Threshold signatures](https://internetcomputer.org/docs/current/references/t-sigs-how-it-works/#api-fees) for more details.
pub async fn sign_with_schnorr(
    arg: &SignWithSchnorrArgs,
) -> Result<SignWithSchnorrResult, SignCallError> {
    let cycles = cost_sign_with_schnorr(arg)?;
    Ok(
        Call::unbounded_wait(Principal::management_canister(), "sign_with_schnorr")
            .with_arg(arg)
            .with_cycles(cycles)
            .await?
            .candid()?,
    )
}

/// Gets a VetKD public key.
///
/// **Bounded-wait call**
///
/// As of 2025-05-01, the vetKD feature is not yet available on the IC mainnet.
/// The lastest PocketIC with the `with_nonmainnet_features(true)` flag can be used to test it.
///
/// See [IC method `vetkd_public_key`](https://github.com/dfinity/portal/pull/3763).
///
/// Later, the description will be available in [the interface spec](https://internetcomputer.org/docs/current/references/ic-interface-spec/#ic-vetkd_public_key).
pub async fn vetkd_public_key(arg: &VetKDPublicKeyArgs) -> CallResult<VetKDPublicKeyResult> {
    Ok(
        Call::bounded_wait(Principal::management_canister(), "vetkd_public_key")
            .with_arg(arg)
            .await?
            .candid()?,
    )
}

/// Calculates the cost of VetKD key derivation with the given [`VetKDDeriveKeyArgs`].
///
/// [`vetkd_derive_key`] invokes this method internally and attaches the required cycles to the call.
///
/// # Note
///
/// Alternatively, [`api::cost_vetkd_derive_key`][ic0_cost_vetkd_derive_key] takes the numeric representation of the algorithm.
pub fn cost_vetkd_derive_key(arg: &VetKDDeriveKeyArgs) -> Result<u128, SignCostError> {
    ic0_cost_vetkd_derive_key(&arg.key_id.name, arg.key_id.curve.into())
}

/// Derives a key from the given input.
///
/// **Unbounded-wait call**
///
/// The returned encrypted key can be separately decrypted using the private secret key corresponding to the transport public key provided in the request, and the derivation correctness can be verified against the input and context provided in the request. See the [`ic_vetkeys` frontend library](https://github.com/dfinity/vetkd-devkit/tree/main/frontend/ic_vetkeys) for more details.
///
/// As of 2025-05-01, the vetKD feature is not yet available on the IC mainnet.
/// The lastest PocketIC with the `with_nonmainnet_features(true)` flag can be used to test it.
///
/// See [IC method `vetkd_derive_key`](https://github.com/dfinity/portal/pull/3763) for the API specification.
///
/// Later, the description will be available in [the interface spec](https://internetcomputer.org/docs/current/references/ic-interface-spec/#ic-vetkd_derive_key).
///
/// # Errors
///
/// This method returns an error of type [`SignCallError`].
///
/// The signature cost calculation may fail before the inter-canister call is made, resulting in a [`SignCallError::SignCostError`].
///
/// Since the call argument is constructed as [`VetKDDeriveKeyArgs`], the `curve` field is guaranteed to be valid.
/// Therefore, [`SignCostError::InvalidCurveOrAlgorithm`] should not occur. If it does, it is likely an issue with the IC. Please report it.
///
/// # Note
///
/// VetKD key derivation costs cycles which varies for different algorithms and key names.
/// This method attaches the required cycles (detemined by [`cost_vetkd_derive_key`]) to the call.
///
/// Check [Threshold signatures](https://internetcomputer.org/docs/current/references/t-sigs-how-it-works/#api-fees) for more details.
pub async fn vetkd_derive_key(
    arg: &VetKDDeriveKeyArgs,
) -> Result<VetKDDeriveKeyResult, SignCallError> {
    let cycles = cost_vetkd_derive_key(arg)?;
    Ok(
        Call::unbounded_wait(Principal::management_canister(), "vetkd_derive_key")
            .with_arg(arg)
            .with_cycles(cycles)
            .await?
            .candid()?,
    )
}

/// Gets a time series of subnet's node metrics.
///
/// **Bounded-wait call**
///
/// See [IC method `node_metrics_history`](https://internetcomputer.org/docs/current/references/ic-interface-spec/#ic-node_metrics_history).
pub async fn node_metrics_history(
    arg: &NodeMetricsHistoryArgs,
) -> CallResult<NodeMetricsHistoryResult> {
    Ok(
        Call::bounded_wait(Principal::management_canister(), "node_metrics_history")
            .with_arg(arg)
            .await?
            .candid()?,
    )
}

/// Gets the metadata about a subnet.
///
/// **Bounded-wait call**
///
/// See [IC method `subnet_info`](https://internetcomputer.org/docs/current/references/ic-interface-spec/#ic-subnet_info).
pub async fn subnet_info(arg: &SubnetInfoArgs) -> CallResult<SubnetInfoResult> {
    Ok(
        Call::bounded_wait(Principal::management_canister(), "subnet_info")
            .with_arg(arg)
            .await?
            .candid()?,
    )
}

/// Creates a new canister with specified amount of cycles balance.
///
/// **Unbounded-wait call**
///
/// # Note
///
/// This method is only available in local development instances.
///
/// See [IC method `provisional_create_canister_with_cycles`](https://internetcomputer.org/docs/current/references/ic-interface-spec/#ic-provisional_create_canister_with_cycles).
pub async fn provisional_create_canister_with_cycles(
    arg: &ProvisionalCreateCanisterWithCyclesArgs,
) -> CallResult<ProvisionalCreateCanisterWithCyclesResult> {
    let complete_arg = ProvisionalCreateCanisterWithCyclesArgsComplete {
        amount: arg.amount.clone(),
        settings: arg.settings.clone(),
        specified_id: arg.specified_id,
        sender_canister_version: Some(canister_version()),
    };
    Ok(Call::unbounded_wait(
        Principal::management_canister(),
        "provisional_create_canister_with_cycles",
    )
    .with_arg(&complete_arg)
    .await?
    .candid()?)
}

/// Argument type of [`provisional_create_canister_with_cycles`].
///
/// # Note
///
/// This type is a reduced version of [`ic_management_canister_types::ProvisionalCreateCanisterWithCyclesArgs`].
///
/// The `sender_canister_version` field is removed as it is set automatically in [`provisional_create_canister_with_cycles`].
#[derive(
    CandidType, Serialize, Deserialize, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Default,
)]
pub struct ProvisionalCreateCanisterWithCyclesArgs {
    /// The created canister will have this amount of cycles.
    pub amount: Option<Nat>,
    /// Canister settings.
    pub settings: Option<CanisterSettings>,
    /// If set, the canister will be created under this id.
    pub specified_id: Option<CanisterId>,
}

/// Adds cycles to a canister.
///
/// **Unbounded-wait call**
///
/// # Note
///
/// This method is only available in local development instances.
///
/// See [IC method `provisional_top_up_canister`](https://internetcomputer.org/docs/current/references/ic-interface-spec/#ic-provisional_top_up_canister).
pub async fn provisional_top_up_canister(arg: &ProvisionalTopUpCanisterArgs) -> CallResult<()> {
    Ok(Call::unbounded_wait(
        Principal::management_canister(),
        "provisional_top_up_canister",
    )
    .with_arg(arg)
    .await?
    .candid()?)
}

/// Takes a snapshot of the specified canister.
///
/// **Unbounded-wait call**
///
/// A snapshot consists of the wasm memory, stable memory, certified variables, wasm chunk store and wasm binary.
///
/// See [IC method `take_canister_snapshot`](https://internetcomputer.org/docs/current/references/ic-interface-spec/#ic-take_canister_snapshot).
pub async fn take_canister_snapshot(
    arg: &TakeCanisterSnapshotArgs,
) -> CallResult<TakeCanisterSnapshotResult> {
    Ok(
        Call::unbounded_wait(Principal::management_canister(), "take_canister_snapshot")
            .with_arg(arg)
            .await?
            .candid()?,
    )
}

/// Loads a snapshot onto the canister.
///
/// **Unbounded-wait call**
///
/// It fails if no snapshot with the specified `snapshot_id` can be found.
///
/// See [IC method `load_canister_snapshot`](https://internetcomputer.org/docs/current/references/ic-interface-spec/#ic-load_canister_snapshot).
pub async fn load_canister_snapshot(arg: &LoadCanisterSnapshotArgs) -> CallResult<()> {
    let complete_arg = LoadCanisterSnapshotArgsComplete {
        canister_id: arg.canister_id,
        snapshot_id: arg.snapshot_id.clone(),
        sender_canister_version: Some(canister_version()),
    };
    Ok(
        Call::unbounded_wait(Principal::management_canister(), "load_canister_snapshot")
            .with_arg(&complete_arg)
            .await?
            .candid()?,
    )
}

/// Argument type of [`load_canister_snapshot`].
///
/// # Note
///
/// This type is a reduced version of [`ic_management_canister_types::LoadCanisterSnapshotArgs`].
///
/// The `sender_canister_version` field is removed as it is set automatically in [`load_canister_snapshot`].
#[derive(
    CandidType, Serialize, Deserialize, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone,
)]
pub struct LoadCanisterSnapshotArgs {
    /// Canister ID.
    pub canister_id: CanisterId,
    /// ID of the snapshot to be loaded.
    pub snapshot_id: SnapshotId,
}

/// Lists the snapshots of the canister.
///
/// **Bounded-wait call**
///
/// See [IC method `list_canister_snapshots`](https://internetcomputer.org/docs/current/references/ic-interface-spec/#ic-list_canister_snapshots).
pub async fn list_canister_snapshots(
    arg: &ListCanisterSnapshotsArgs,
) -> CallResult<ListCanisterSnapshotsResult> {
    Ok(
        Call::bounded_wait(Principal::management_canister(), "list_canister_snapshots")
            .with_arg(arg)
            .await?
            .candid()?,
    )
}

/// Deletes a specified snapshot that belongs to an existing canister.
///
/// **Unbounded-wait call**
///
/// An error will be returned if the snapshot is not found.
///
/// See [IC method `delete_canister_snapshot`](https://internetcomputer.org/docs/current/references/ic-interface-spec/#ic-delete_canister_snapshot).
pub async fn delete_canister_snapshot(arg: &DeleteCanisterSnapshotArgs) -> CallResult<()> {
    Ok(
        Call::unbounded_wait(Principal::management_canister(), "delete_canister_snapshot")
            .with_arg(arg)
            .await?
            .candid()?,
    )
}



================================================
FILE: ic-cdk/src/stable.rs
================================================
//! APIs to manage stable memory.
//!
//! You can check the [Internet Computer Specification](https://internetcomputer.org/docs/current/references/ic-interface-spec/#system-api-stable-memory)
//! for a in-depth explanation of stable memory.
// mod canister;
// #[cfg(test)]
// mod tests;

use std::{error, fmt, io};

/// WASM page size in bytes.
pub const WASM_PAGE_SIZE_IN_BYTES: u64 = 64 * 1024; // 64KB

static CANISTER_STABLE_MEMORY: CanisterStableMemory = CanisterStableMemory {};

/// A trait defining the stable memory API which each canister running on the IC can make use of
pub trait StableMemory {
    /// Gets current size of the stable memory (in WASM pages).
    fn stable_size(&self) -> u64;

    /// Attempts to grow the stable memory by `new_pages` (added pages).
    ///
    /// Returns an error if it wasn't possible. Otherwise, returns the previous
    /// size that was reserved.
    ///
    /// *Note*: Pages are 64KiB in WASM.
    fn stable_grow(&self, new_pages: u64) -> Result<u64, StableMemoryError>;

    /// Writes data to the stable memory location specified by an offset.
    ///
    /// Warning - this will panic if `offset + buf.len()` exceeds the current size of stable memory.
    /// Use `stable_grow` to request more stable memory if needed.
    fn stable_write(&self, offset: u64, buf: &[u8]);

    /// Reads data from the stable memory location specified by an offset.
    fn stable_read(&self, offset: u64, buf: &mut [u8]);
}

/// A possible error value when dealing with stable memory.
#[derive(Debug)]
pub enum StableMemoryError {
    /// No more stable memory could be allocated.
    OutOfMemory,
    /// Attempted to read more stable memory than had been allocated.
    OutOfBounds,
}

impl fmt::Display for StableMemoryError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::OutOfMemory => f.write_str("Out of memory"),
            Self::OutOfBounds => f.write_str("Read exceeds allocated memory"),
        }
    }
}

impl error::Error for StableMemoryError {}

/// A standard implementation of [`StableMemory`].
///
/// Useful for creating [`StableWriter`] and [`StableReader`].
#[derive(Default, Debug, Copy, Clone)]
pub struct CanisterStableMemory {}

impl StableMemory for CanisterStableMemory {
    fn stable_size(&self) -> u64 {
        ic0::stable64_size()
    }

    fn stable_grow(&self, new_pages: u64) -> Result<u64, StableMemoryError> {
        match ic0::stable64_grow(new_pages) {
            u64::MAX => Err(StableMemoryError::OutOfMemory),
            x => Ok(x),
        }
    }

    fn stable_write(&self, offset: u64, buf: &[u8]) {
        ic0::stable64_write(buf, offset);
    }

    fn stable_read(&self, offset: u64, buf: &mut [u8]) {
        ic0::stable64_read(buf, offset);
    }
}

/// Gets current size of the stable memory (in WASM pages).
pub fn stable_size() -> u64 {
    CANISTER_STABLE_MEMORY.stable_size()
}

/// Attempts to grow the stable memory by `new_pages` (added pages).
///
/// Returns an error if it wasn't possible. Otherwise, returns the previous
/// size that was reserved.
///
/// *Note*: Pages are 64KiB in WASM.
pub fn stable_grow(new_pages: u64) -> Result<u64, StableMemoryError> {
    CANISTER_STABLE_MEMORY.stable_grow(new_pages)
}

/// Writes data to the stable memory location specified by an offset.
///
/// Warning - this will panic if `offset + buf.len()` exceeds the current size of stable memory.
/// Use `stable_grow` to request more stable memory if needed.
pub fn stable_write(offset: u64, buf: &[u8]) {
    CANISTER_STABLE_MEMORY.stable_write(offset, buf);
}

/// Reads data from the stable memory location specified by an offset.
pub fn stable_read(offset: u64, buf: &mut [u8]) {
    CANISTER_STABLE_MEMORY.stable_read(offset, buf);
}

/// Returns a copy of the stable memory.
///
/// This will map the whole memory (even if not all of it has been written to).
///
/// # Panics
///
/// When the bytes of the stable memory cannot fit into a `Vec` which constrained by the usize.
pub fn stable_bytes() -> Vec<u8> {
    let size = (stable_size() << 16)
        .try_into()
        .expect("overflow: stable memory too large to read in one go");
    let mut vec = Vec::with_capacity(size);
    ic0::stable64_read_uninit(&mut vec.spare_capacity_mut()[..size], 0);
    // SAFETY: ic0::stable64_read writes to all of `vec[0..size]`, so `set_len` is safe to call with the new size.
    unsafe {
        vec.set_len(size);
    }
    vec
}

/// Performs generic IO (read, write, and seek) on stable memory.
///
/// Warning: When using write functionality, this will overwrite any existing
/// data in stable memory as it writes, so ensure you set the `offset` value
/// accordingly if you wish to preserve existing data.
///
/// Will attempt to grow the memory as it writes,
/// and keep offsets and total capacity.
#[derive(Debug)]
pub struct StableIO<M: StableMemory = CanisterStableMemory> {
    /// The offset of the next write.
    offset: u64,

    /// The capacity, in pages.
    capacity: u64,

    /// The stable memory to write data to.
    memory: M,
}

impl Default for StableIO {
    fn default() -> Self {
        Self::with_memory(CanisterStableMemory::default(), 0)
    }
}

impl<M: StableMemory> StableIO<M> {
    /// Creates a new `StableIO` which writes to the selected memory
    pub fn with_memory(memory: M, offset: u64) -> Self {
        let capacity = memory.stable_size();
        Self {
            offset,
            capacity,
            memory,
        }
    }

    /// Returns the offset of the writer
    pub fn offset(&self) -> u64 {
        self.offset
    }

    /// Attempts to grow the memory by adding new pages.
    pub fn grow(&mut self, new_pages: u64) -> Result<(), StableMemoryError> {
        let old_page_count = self.memory.stable_grow(new_pages)?;
        self.capacity = old_page_count + new_pages;
        Ok(())
    }

    /// Writes a byte slice to the buffer.
    ///
    /// # Errors
    ///
    /// When it cannot grow the memory to accommodate the new data.
    pub fn write(&mut self, buf: &[u8]) -> Result<usize, StableMemoryError> {
        let required_capacity_bytes = self.offset + buf.len() as u64;
        let required_capacity_pages = required_capacity_bytes.div_ceil(WASM_PAGE_SIZE_IN_BYTES);
        let current_pages = self.capacity;
        let additional_pages_required = required_capacity_pages.saturating_sub(current_pages);

        if additional_pages_required > 0 {
            self.grow(additional_pages_required)?;
        }

        self.memory.stable_write(self.offset, buf);
        self.offset += buf.len() as u64;
        Ok(buf.len())
    }

    /// Reads data from the stable memory location specified by an offset.
    ///
    /// # Errors
    ///
    /// The stable memory size is cached on creation of the `StableReader`.
    /// Therefore, in following scenario, it will get an `OutOfBounds` error:
    /// 1. Create a `StableReader`
    /// 2. Write some data to the stable memory which causes it grow
    /// 3. call `read()` to read the newly written bytes
    pub fn read(&mut self, buf: &mut [u8]) -> Result<usize, StableMemoryError> {
        let capacity_bytes = self.capacity * WASM_PAGE_SIZE_IN_BYTES;
        let read_buf = if buf.len() as u64 + self.offset > capacity_bytes {
            if self.offset < capacity_bytes {
                // When usize=u32:
                //   (capacity_bytes - self.offset) < buf.len() <= u32::MAX == usize::MAX.
                // So the cast below won't panic.
                &mut buf[..(capacity_bytes - self.offset).try_into().unwrap()]
            } else {
                return Err(StableMemoryError::OutOfBounds);
            }
        } else {
            buf
        };
        self.memory.stable_read(self.offset, read_buf);
        self.offset += read_buf.len() as u64;
        Ok(read_buf.len())
    }

    // Helper used to implement io::Seek
    fn seek(&mut self, offset: io::SeekFrom) -> io::Result<u64> {
        self.offset = match offset {
            io::SeekFrom::Start(offset) => offset,
            io::SeekFrom::End(offset) => {
                ((self.capacity * WASM_PAGE_SIZE_IN_BYTES) as i64 + offset) as u64
            }
            io::SeekFrom::Current(offset) => (self.offset as i64 + offset) as u64,
        };

        Ok(self.offset)
    }
}

impl<M: StableMemory> io::Write for StableIO<M> {
    fn write(&mut self, buf: &[u8]) -> Result<usize, io::Error> {
        self.write(buf)
            .map_err(|e| io::Error::new(io::ErrorKind::OutOfMemory, e))
    }

    fn flush(&mut self) -> Result<(), io::Error> {
        // Noop.
        Ok(())
    }
}

impl<M: StableMemory> io::Read for StableIO<M> {
    fn read(&mut self, buf: &mut [u8]) -> Result<usize, io::Error> {
        Self::read(self, buf).or(Ok(0)) // Read defines EOF to be success
    }
}

impl<M: StableMemory> io::Seek for StableIO<M> {
    fn seek(&mut self, offset: io::SeekFrom) -> io::Result<u64> {
        self.seek(offset)
    }
}

// impl_stable_io!(u32);
// impl_stable_io!(u64);

/// A writer to the stable memory.
///
/// Warning: This will overwrite any existing data in stable memory as it writes, so ensure you set
/// the `offset` value accordingly if you wish to preserve existing data.
///
/// Will attempt to grow the memory as it writes,
/// and keep offsets and total capacity.
#[derive(Debug)]
pub struct StableWriter<M: StableMemory = CanisterStableMemory>(StableIO<M>);

#[allow(clippy::derivable_impls)]
impl Default for StableWriter {
    #[inline]
    fn default() -> Self {
        Self(StableIO::default())
    }
}

impl<M: StableMemory> StableWriter<M> {
    /// Creates a new `StableWriter` which writes to the selected memory
    #[inline]
    pub fn with_memory(memory: M, offset: u64) -> Self {
        Self(StableIO::<M>::with_memory(memory, offset))
    }

    /// Returns the offset of the writer
    #[inline]
    pub fn offset(&self) -> u64 {
        self.0.offset()
    }

    /// Attempts to grow the memory by adding new pages.
    #[inline]
    pub fn grow(&mut self, new_pages: u64) -> Result<(), StableMemoryError> {
        self.0.grow(new_pages)
    }

    /// Writes a byte slice to the buffer.
    ///
    /// The only condition where this will
    /// error out is if it cannot grow the memory.
    #[inline]
    pub fn write(&mut self, buf: &[u8]) -> Result<usize, StableMemoryError> {
        self.0.write(buf)
    }
}

impl<M: StableMemory> io::Write for StableWriter<M> {
    #[inline]
    fn write(&mut self, buf: &[u8]) -> Result<usize, io::Error> {
        io::Write::write(&mut self.0, buf)
    }

    #[inline]
    fn flush(&mut self) -> Result<(), io::Error> {
        io::Write::flush(&mut self.0)
    }
}

impl<M: StableMemory> io::Seek for StableWriter<M> {
    #[inline]
    fn seek(&mut self, pos: io::SeekFrom) -> io::Result<u64> {
        io::Seek::seek(&mut self.0, pos)
    }
}

impl<M: StableMemory> From<StableIO<M>> for StableWriter<M> {
    fn from(io: StableIO<M>) -> Self {
        Self(io)
    }
}

/// A writer to the stable memory which first writes the bytes to an in memory buffer and flushes
/// the buffer to stable memory each time it becomes full.
///
/// Warning: This will overwrite any existing data in stable memory as it writes, so ensure you set
/// the `offset` value accordingly if you wish to preserve existing data.
///
/// Note: Each call to grow or write to stable memory is a relatively expensive operation, so pick a
/// buffer size large enough to avoid excessive calls to stable memory.
#[derive(Debug)]
pub struct BufferedStableWriter<M: StableMemory = CanisterStableMemory> {
    inner: io::BufWriter<StableWriter<M>>,
}

impl BufferedStableWriter {
    /// Creates a new `BufferedStableWriter`
    pub fn new(buffer_size: usize) -> BufferedStableWriter {
        BufferedStableWriter::with_writer(buffer_size, StableWriter::default())
    }
}

impl<M: StableMemory> BufferedStableWriter<M> {
    /// Creates a new `BufferedStableWriter` which writes to the selected memory
    pub fn with_writer(buffer_size: usize, writer: StableWriter<M>) -> BufferedStableWriter<M> {
        BufferedStableWriter {
            inner: io::BufWriter::with_capacity(buffer_size, writer),
        }
    }

    /// Returns the offset of the writer
    pub fn offset(&self) -> u64 {
        self.inner.get_ref().offset()
    }
}

impl<M: StableMemory> io::Write for BufferedStableWriter<M> {
    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
        self.inner.write(buf)
    }

    fn flush(&mut self) -> io::Result<()> {
        self.inner.flush()
    }
}

impl<M: StableMemory> io::Seek for BufferedStableWriter<M> {
    #[inline]
    fn seek(&mut self, pos: io::SeekFrom) -> io::Result<u64> {
        io::Seek::seek(&mut self.inner, pos)
    }
}

// A reader to the stable memory.
///
/// Keeps an offset and reads off stable memory consecutively.
#[derive(Debug)]
pub struct StableReader<M: StableMemory = CanisterStableMemory>(StableIO<M>);

#[allow(clippy::derivable_impls)]
impl Default for StableReader {
    fn default() -> Self {
        Self(StableIO::default())
    }
}

impl<M: StableMemory> StableReader<M> {
    /// Creates a new `StableReader` which reads from the selected memory
    #[inline]
    pub fn with_memory(memory: M, offset: u64) -> Self {
        Self(StableIO::<M>::with_memory(memory, offset))
    }

    /// Returns the offset of the reader
    #[inline]
    pub fn offset(&self) -> u64 {
        self.0.offset()
    }

    /// Reads data from the stable memory location specified by an offset.
    ///
    /// Note:
    /// The stable memory size is cached on creation of the `StableReader`.
    /// Therefore, in following scenario, it will get an `OutOfBounds` error:
    /// 1. Create a `StableReader`
    /// 2. Write some data to the stable memory which causes it grow
    /// 3. call `read()` to read the newly written bytes
    #[inline]
    pub fn read(&mut self, buf: &mut [u8]) -> Result<usize, StableMemoryError> {
        self.0.read(buf)
    }
}

impl<M: StableMemory> io::Read for StableReader<M> {
    #[inline]
    fn read(&mut self, buf: &mut [u8]) -> Result<usize, io::Error> {
        io::Read::read(&mut self.0, buf)
    }
}

impl<M: StableMemory> io::Seek for StableReader<M> {
    #[inline]
    fn seek(&mut self, pos: io::SeekFrom) -> io::Result<u64> {
        io::Seek::seek(&mut self.0, pos)
    }
}

impl<M: StableMemory> From<StableIO<M>> for StableReader<M> {
    fn from(io: StableIO<M>) -> Self {
        Self(io)
    }
}

/// A reader to the stable memory which reads bytes a chunk at a time as each chunk is required.
#[derive(Debug)]
pub struct BufferedStableReader<M: StableMemory = CanisterStableMemory> {
    inner: io::BufReader<StableReader<M>>,
}

impl BufferedStableReader {
    /// Creates a new `BufferedStableReader`
    pub fn new(buffer_size: usize) -> BufferedStableReader {
        BufferedStableReader::with_reader(buffer_size, StableReader::default())
    }
}

impl<M: StableMemory> BufferedStableReader<M> {
    /// Creates a new `BufferedStableReader` which reads from the selected memory
    pub fn with_reader(buffer_size: usize, reader: StableReader<M>) -> BufferedStableReader<M> {
        BufferedStableReader {
            inner: io::BufReader::with_capacity(buffer_size, reader),
        }
    }

    /// Returns the offset of the reader
    pub fn offset(&self) -> u64 {
        self.inner.get_ref().offset()
    }
}

impl<M: StableMemory> io::Read for BufferedStableReader<M> {
    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {
        self.inner.read(buf)
    }
}

impl<M: StableMemory> io::Seek for BufferedStableReader<M> {
    #[inline]
    fn seek(&mut self, pos: io::SeekFrom) -> io::Result<u64> {
        io::Seek::seek(&mut self.inner, pos)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::rc::Rc;
    use std::sync::Mutex;

    #[derive(Default)]
    pub struct TestStableMemory {
        memory: Rc<Mutex<Vec<u8>>>,
    }

    impl TestStableMemory {
        pub fn new(memory: Rc<Mutex<Vec<u8>>>) -> TestStableMemory {
            let bytes_len = memory.lock().unwrap().len();
            if bytes_len > 0 {
                let pages_required = pages_required(bytes_len);
                let bytes_required = pages_required * WASM_PAGE_SIZE_IN_BYTES;
                memory
                    .lock()
                    .unwrap()
                    .resize(bytes_required.try_into().unwrap(), 0);
            }

            TestStableMemory { memory }
        }
    }

    impl StableMemory for TestStableMemory {
        fn stable_size(&self) -> u64 {
            let bytes_len = self.memory.lock().unwrap().len();
            pages_required(bytes_len)
        }

        fn stable_grow(&self, new_pages: u64) -> Result<u64, StableMemoryError> {
            let new_bytes = new_pages * WASM_PAGE_SIZE_IN_BYTES;

            let mut vec = self.memory.lock().unwrap();
            let previous_len = vec.len() as u64;
            let new_len = vec.len() as u64 + new_bytes;
            vec.resize(new_len.try_into().unwrap(), 0);
            Ok(previous_len / WASM_PAGE_SIZE_IN_BYTES)
        }

        fn stable_write(&self, offset: u64, buf: &[u8]) {
            let offset = offset as usize;

            let mut vec = self.memory.lock().unwrap();
            if offset + buf.len() > vec.len() {
                panic!("stable memory out of bounds");
            }
            vec[offset..(offset + buf.len())].clone_from_slice(buf);
        }

        fn stable_read(&self, offset: u64, buf: &mut [u8]) {
            let offset = offset as usize;

            let vec = self.memory.lock().unwrap();
            let count_to_copy = buf.len();

            buf[..count_to_copy].copy_from_slice(&vec[offset..offset + count_to_copy]);
        }
    }

    fn pages_required(bytes_len: usize) -> u64 {
        let page_size = WASM_PAGE_SIZE_IN_BYTES;
        (bytes_len as u64).div_ceil(page_size)
    }

    mod stable_writer_tests {
        use super::*;
        use rstest::rstest;
        use std::io::{Seek, Write};

        #[rstest]
        #[case(None)]
        #[case(Some(1))]
        #[case(Some(10))]
        #[case(Some(100))]
        #[case(Some(1000))]
        fn write_single_slice(#[case] buffer_size: Option<usize>) {
            let memory = Rc::new(Mutex::new(Vec::new()));
            let mut writer = build_writer(TestStableMemory::new(memory.clone()), buffer_size);

            let bytes = vec![1; 100];

            writer.write_all(&bytes).unwrap();
            writer.flush().unwrap();

            let result = &*memory.lock().unwrap();

            assert_eq!(bytes, result[..bytes.len()]);
        }

        #[rstest]
        #[case(None)]
        #[case(Some(1))]
        #[case(Some(10))]
        #[case(Some(100))]
        #[case(Some(1000))]
        fn write_many_slices(#[case] buffer_size: Option<usize>) {
            let memory = Rc::new(Mutex::new(Vec::new()));
            let mut writer = build_writer(TestStableMemory::new(memory.clone()), buffer_size);

            for i in 1..100 {
                let bytes = vec![i as u8; i];
                writer.write_all(&bytes).unwrap();
            }
            writer.flush().unwrap();

            let result = &*memory.lock().unwrap();

            let mut offset = 0;
            for i in 1..100 {
                let bytes = &result[offset..offset + i];
                assert_eq!(bytes, vec![i as u8; i]);
                offset += i;
            }
        }

        #[rstest]
        #[case(None)]
        #[case(Some(1))]
        #[case(Some(10))]
        #[case(Some(100))]
        #[case(Some(1000))]
        fn ensure_only_requests_min_number_of_pages_required(#[case] buffer_size: Option<usize>) {
            let memory = Rc::new(Mutex::new(Vec::new()));
            let mut writer = build_writer(TestStableMemory::new(memory.clone()), buffer_size);

            let mut total_bytes = 0;
            for i in 1..10000 {
                let bytes = vec![i as u8; i];
                writer.write_all(&bytes).unwrap();
                total_bytes += i;
            }
            writer.flush().unwrap();

            let capacity_pages = TestStableMemory::new(memory).stable_size();
            let min_pages_required = (total_bytes as u64).div_ceil(WASM_PAGE_SIZE_IN_BYTES);

            assert_eq!(capacity_pages, min_pages_required);
        }

        #[test]
        fn check_offset() {
            const WRITE_SIZE: usize = 1025;

            let memory = Rc::new(Mutex::new(Vec::new()));
            let mut writer = StableWriter::with_memory(TestStableMemory::new(memory.clone()), 0);
            assert_eq!(writer.offset(), 0);
            assert_eq!(writer.write(&vec![0; WRITE_SIZE]).unwrap(), WRITE_SIZE);
            assert_eq!(writer.offset(), WRITE_SIZE as u64);

            let mut writer = BufferedStableWriter::with_writer(
                WRITE_SIZE - 1,
                StableWriter::with_memory(TestStableMemory::new(memory), 0),
            );
            assert_eq!(writer.offset(), 0);
            assert_eq!(writer.write(&vec![0; WRITE_SIZE]).unwrap(), WRITE_SIZE);
            assert_eq!(writer.offset(), WRITE_SIZE as u64);
        }

        #[test]
        fn test_seek() {
            let memory = Rc::new(Mutex::new(Vec::new()));
            let mut writer = StableWriter::with_memory(TestStableMemory::new(memory.clone()), 0);
            writer
                .seek(std::io::SeekFrom::Start(WASM_PAGE_SIZE_IN_BYTES))
                .unwrap();
            assert_eq!(writer.stream_position().unwrap(), WASM_PAGE_SIZE_IN_BYTES);
            assert_eq!(writer.write(&[1_u8]).unwrap(), 1);
            assert_eq!(
                writer.seek(std::io::SeekFrom::End(0)).unwrap(),
                WASM_PAGE_SIZE_IN_BYTES * 2
            );
            let capacity_pages = TestStableMemory::new(memory).stable_size();
            assert_eq!(capacity_pages, 2);
        }

        fn build_writer(memory: TestStableMemory, buffer_size: Option<usize>) -> Box<dyn Write> {
            let writer = StableWriter::with_memory(memory, 0);
            if let Some(buffer_size) = buffer_size {
                Box::new(BufferedStableWriter::with_writer(buffer_size, writer))
            } else {
                Box::new(writer)
            }
        }
    }

    mod stable_reader_tests {
        use super::*;
        use rstest::rstest;
        use std::io::{Read, Seek};

        #[rstest]
        #[case(None)]
        #[case(Some(1))]
        #[case(Some(10))]
        #[case(Some(100))]
        #[case(Some(1000))]
        fn reads_all_bytes(#[case] buffer_size: Option<usize>) {
            let input = vec![1; 10_000];
            let memory = Rc::new(Mutex::new(input.clone()));
            let mut reader = build_reader(TestStableMemory::new(memory), buffer_size);

            let mut output = Vec::new();
            reader.read_to_end(&mut output).unwrap();

            assert_eq!(input, output[..input.len()]);
        }

        #[test]
        fn check_offset() {
            const READ_SIZE: usize = 1025;

            let memory = Rc::new(Mutex::new(vec![1; READ_SIZE]));
            let mut reader = StableReader::with_memory(TestStableMemory::new(memory.clone()), 0);
            assert_eq!(reader.offset(), 0);
            let mut bytes = vec![0; READ_SIZE];
            assert_eq!(reader.read(&mut bytes).unwrap(), READ_SIZE);
            assert_eq!(reader.offset(), READ_SIZE as u64);

            let mut reader = BufferedStableReader::with_reader(
                READ_SIZE - 1,
                StableReader::with_memory(TestStableMemory::new(memory), 0),
            );
            assert_eq!(reader.offset(), 0);
            let mut bytes = vec![0; READ_SIZE];
            assert_eq!(reader.read(&mut bytes).unwrap(), READ_SIZE);
            assert_eq!(reader.offset(), READ_SIZE as u64);
        }

        #[test]
        fn test_seek() {
            const SIZE: usize = 1025;
            let memory = Rc::new(Mutex::new((0..SIZE).map(|v| v as u8).collect::<Vec<u8>>()));
            let mut reader = StableReader::with_memory(TestStableMemory::new(memory), 0);
            let mut bytes = vec![0_u8; 1];

            const OFFSET: usize = 200;
            reader
                .seek(std::io::SeekFrom::Start(OFFSET as u64))
                .unwrap();
            assert_eq!(reader.stream_position().unwrap() as usize, OFFSET);
            assert_eq!(reader.read(&mut bytes).unwrap(), 1);
            assert_eq!(&bytes, &[OFFSET as u8]);
            assert_eq!(
                reader.seek(std::io::SeekFrom::End(0)).unwrap(),
                WASM_PAGE_SIZE_IN_BYTES
            );
            reader
                .seek(std::io::SeekFrom::Start(WASM_PAGE_SIZE_IN_BYTES * 2))
                .unwrap();
            // out of bounds so should fail
            assert!(reader.read(&mut bytes).is_err());
        }

        fn build_reader(memory: TestStableMemory, buffer_size: Option<usize>) -> Box<dyn Read> {
            let reader = StableReader::with_memory(memory, 0);
            if let Some(buffer_size) = buffer_size {
                Box::new(BufferedStableReader::with_reader(buffer_size, reader))
            } else {
                Box::new(reader)
            }
        }
    }
}



================================================
FILE: ic-cdk/src/storage.rs
================================================
//! Tools for managing stable storage of data in a canister.
use crate::stable;

/// Saves the storage into the stable memory.
///
/// This will override any value previously stored in stable memory.
pub fn stable_save<T>(t: T) -> Result<(), candid::Error>
where
    T: candid::utils::ArgumentEncoder,
{
    candid::write_args(&mut stable::StableWriter::default(), t)
}

/// Restores a value from the stable memory to the storage.
///
/// There can only be one value in stable memory, currently.
pub fn stable_restore<T>() -> Result<T, String>
where
    T: for<'de> candid::utils::ArgumentDecoder<'de>,
{
    let bytes = stable::stable_bytes();

    let mut de = candid::de::IDLDeserialize::new(bytes.as_slice()).map_err(|e| format!("{e:?}"))?;
    let res = candid::utils::ArgumentDecoder::decode(&mut de).map_err(|e| format!("{e:?}"))?;
    Ok(res)
}



================================================
FILE: ic-cdk/src/api/call.rs
================================================
//! APIs to make and manage calls in the canister.

#![allow(deprecated)]
use crate::api::trap;
use candid::utils::{ArgumentDecoder, ArgumentEncoder, decode_args_with_config_debug};
use candid::{
    CandidType, DecoderConfig, Deserialize, Principal, decode_args, encode_args, write_args,
};
use ic_cdk_executor::{MethodHandle, TaskHandle};
use serde::ser::Error;
use std::future::Future;
use std::marker::PhantomData;
use std::mem;
use std::pin::Pin;
use std::sync::{Arc, RwLock};
use std::task::{Context, Poll, Waker};

/// Rejection code from calling another canister.
///
/// These can be obtained either using `reject_code()` or `reject_result()`.
#[allow(missing_docs)]
#[deprecated(
    since = "0.18.0",
    note = "Please use `ic_cdk::call::RejectCode` instead."
)]
#[repr(usize)]
#[derive(CandidType, Deserialize, Clone, Copy, Hash, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum RejectionCode {
    NoError = 0,

    SysFatal = 1,
    SysTransient = 2,
    DestinationInvalid = 3,
    CanisterReject = 4,
    CanisterError = 5,

    Unknown,
}

impl From<usize> for RejectionCode {
    fn from(code: usize) -> Self {
        match code {
            0 => RejectionCode::NoError,
            1 => RejectionCode::SysFatal,
            2 => RejectionCode::SysTransient,
            3 => RejectionCode::DestinationInvalid,
            4 => RejectionCode::CanisterReject,
            5 => RejectionCode::CanisterError,
            _ => RejectionCode::Unknown,
        }
    }
}

impl From<u32> for RejectionCode {
    fn from(code: u32) -> Self {
        RejectionCode::from(code as usize)
    }
}

/// The result of a Call.
///
/// Errors on the IC have two components; a Code and a message associated with it.
#[deprecated(
    since = "0.18.0",
    note = "Please use `ic_cdk::call::CallResult` instead."
)]
pub type CallResult<R> = Result<R, (RejectionCode, String)>;

/// Internal state for the Future when sending a call.
#[derive(Debug, Default)]
enum CallFutureState<T: AsRef<[u8]>> {
    /// The future has been constructed, and the call has not yet been performed.
    /// Needed because futures are supposed to do nothing unless polled.
    /// Polling will attempt to fire off the request. Success returns `Pending` and transitions to `Executing`,
    /// failure returns `Ready` and transitions to `PostComplete.`
    Prepared {
        id: Principal,
        method: String,
        arg: T,
        payment: u128,
    },
    /// The call has been performed and the message is in flight. Neither callback has been called. Polling will return `Pending`.
    /// This state will transition to `Trapped` if the future is canceled because of a trap in another future.
    Executing {
        waker: Waker,
        method: MethodHandle,
        task: Option<TaskHandle>,
    },
    /// `callback` has been called, so the call has been completed. This completion state has not yet been read by the user.
    /// Polling will return `Ready` and transition to `PostComplete`.
    Complete { result: CallResult<Vec<u8>> },
    /// The completion state of `Complete` has been returned from `poll` as `Poll::Ready`. Polling again will trap.
    #[default]
    PostComplete,
    /// The future (*not* the state) was canceled because of a trap in another future during `Executing`. Polling will trap.
    Trapped,
}

struct CallFuture<T: AsRef<[u8]>> {
    state: Arc<RwLock<CallFutureState<T>>>,
}

impl<T: AsRef<[u8]>> Future for CallFuture<T> {
    type Output = CallResult<Vec<u8>>;

    fn poll(self: Pin<&mut Self>, context: &mut Context<'_>) -> Poll<Self::Output> {
        let self_ref = Pin::into_inner(self);
        let mut state = self_ref.state.write().unwrap();
        match mem::take(&mut *state) {
            CallFutureState::Prepared {
                id,
                method,
                arg,
                payment,
            } => {
                let callee = id.as_slice();
                let args = arg.as_ref();
                let state_ptr =
                    Arc::<RwLock<CallFutureState<T>>>::into_raw(Arc::clone(&self_ref.state));
                // SAFETY:
                // `callback` is intended as an entrypoint and therefore can be called as both reply and reject fn
                //      for ic0.call_new.
                // - `cleanup` is intended as an entrypoint and therefore can be called as cleanup fn for ic0.call_on_cleanup.
                // - `state_ptr` is a pointer created via Arc::<RwLock<CallFutureState<T>>>::into_raw, and can therefore be passed as the userdata for
                //      `callback` and `cleanup`.
                // - callback and cleanup are safe to parameterize with T because they will always be called in the
                //      Executing or Trapped states which do not contain a T.
                // - if-and-only-if ic0.call_perform returns 0, exactly one() of `callback` or `cleanup`
                //      receive ownership of `state_ptr`
                // - both functions deallocate `state_ptr`, and this enclosing function deallocates `state_ptr` if ic0.call_perform
                //      returns !=0, and therefore `state_ptr`'s ownership can be passed to FFI without leaking memory.
                //
                //  The flow from outside the WASM runtime is that the callback runs, it traps, state is rolled back,
                //   and the cleanup callback runs afterwards. Inside the runtime, there is no difference between
                //   'state is rolled back to before the callback was called' and 'the callback was never called'.
                //   So from the code's perspective, exactly one function is called.
                let err_code = unsafe {
                    ic0::call_new(
                        callee,
                        &method,
                        callback::<T>,
                        state_ptr as usize,
                        callback::<T>,
                        state_ptr as usize,
                    );

                    ic0::call_data_append(args);
                    add_payment(payment);
                    ic0::call_on_cleanup(cleanup::<T>, state_ptr as usize);
                    ic0::call_perform()
                };

                // 0 is a special error code meaning call succeeded.
                if err_code != 0 {
                    *state = CallFutureState::PostComplete;
                    // SAFETY: We just constructed this from Arc::into_raw.
                    // - `state_ptr_opt` is `Some` if-and-only-if ic0.call_new was called with ownership of `state`
                    // - by returning !=0, ic0.call_new relinquishes ownership of `state_ptr`; it will never be passed
                    //      to any functions
                    // therefore, there is an outstanding handle to `state`, which it is safe to deallocate
                    unsafe {
                        Arc::from_raw(state_ptr);
                    }
                    let result = Err((
                        RejectionCode::from(err_code),
                        "Couldn't send message".to_string(),
                    ));
                    return Poll::Ready(result);
                }
                *state = CallFutureState::Executing {
                    waker: context.waker().clone(),
                    method: ic_cdk_executor::extend_current_method_context(),
                    task: TaskHandle::current(),
                };
                Poll::Pending
            }
            CallFutureState::Executing { method, task, .. } => {
                *state = CallFutureState::Executing {
                    waker: context.waker().clone(),
                    method,
                    task,
                };
                Poll::Pending
            }
            CallFutureState::Complete { result } => {
                *state = CallFutureState::PostComplete;
                Poll::Ready(result)
            }
            CallFutureState::Trapped => trap("Call already trapped"),
            CallFutureState::PostComplete => trap("CallFuture polled after completing"),
        }
    }
}

impl<T: AsRef<[u8]>> Drop for CallFuture<T> {
    fn drop(&mut self) {
        // If this future is dropped while is_recovering_from_trap is true,
        // then it has been canceled due to a trap in another future.
        if is_recovering_from_trap() {
            *self.state.write().unwrap() = CallFutureState::Trapped;
        }
    }
}

/// The callback from IC dereferences the future from a raw pointer, assigns the
/// result and calls the waker. We cannot use a closure here because we pass raw
/// pointers to the System and back.
///
/// # Safety
///
/// This function must only be passed to the IC with a pointer from `Arc::<RwLock<CallFutureState<T>>>::into_raw` as userdata.
unsafe extern "C" fn callback<T: AsRef<[u8]>>(env: usize) {
    let state_ptr = env as *const RwLock<CallFutureState<T>>;
    // SAFETY: This function is only ever called by the IC, and we only ever pass an Arc as userdata.
    let state = unsafe { Arc::from_raw(state_ptr) };
    let completed_state = CallFutureState::Complete {
        result: match reject_code() {
            RejectionCode::NoError => Ok(arg_data_raw()),
            n => Err((n, reject_message())),
        },
    };
    let (waker, method) = match mem::replace(&mut *state.write().unwrap(), completed_state) {
        CallFutureState::Executing { waker, method, .. } => (waker, method),
        // This future has already been cancelled and waking it will do nothing.
        // All that's left is to explicitly trap in case this is the last call being multiplexed,
        // to replace an automatic trap from not replying.
        CallFutureState::Trapped => trap("Call already trapped"),
        _ => {
            unreachable!(
                "CallFutureState for in-flight calls should only be Executing or Trapped (legacy callback)"
            )
        }
    };
    ic_cdk_executor::in_callback_executor_context_for(method, || {
        waker.wake();
    });
}

/// This function is called when [callback] was just called with the same parameter, and trapped.
/// We can't guarantee internal consistency at this point, but we can at least e.g. drop mutex guards.
/// Waker is a very opaque API, so the best we can do is set a global flag and proceed normally.
///
/// # Safety
///
/// This function must only be passed to the IC with a pointer from `Arc::<RwLock<CallFutureState<T>>>::into_raw` as userdata.
unsafe extern "C" fn cleanup<T: AsRef<[u8]>>(env: usize) {
    let state_ptr = env as *const RwLock<CallFutureState<T>>;
    // SAFETY: This function is only ever called by the IC, and we only ever pass an Arc as userdata.
    let state = unsafe { Arc::from_raw(state_ptr) };
    // We set the call result, even though it won't be read on the
    // de
