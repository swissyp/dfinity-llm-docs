(Files content cropped to 300k characters)

================================================
FILE: README.md
================================================
# vetKeys

This repository contains a set of tools designed to help canister developers as well as frontend developers integrate **vetKeys** into their Internet Computer (ICP) applications.

**vetKeys** – Verifiable Encrypted Threshold Keys – on the Internet Computer addresses the fundamental challenge of storing secrets on-chain by allowing cryptographic key derivation without exposing private keys to anyone but the user. By leveraging **threshold cryptography**, vetKeys make it possible to generate, transport, and use encrypted keys securely, unlocking **privacy-preserving smart contracts** and **externally verifiable randomness**.

In slightly more detail, vetKeys enables use cases such as:

- **Decentralized key management**, secure threshold key derivation without relying on a traditional PKI - only the user knows the key.
- **Threshold BLS Signatures**, enabling secure, decentralized signing of messages.
- **Identity Based Encryption (IBE)**, enabling secure communication between users without exchanging public keys.
- **Verifiable Random Beacons**, providing a secure source of verifiable randomness for decentralized applications.
- **Smart contract defined vetKeys**, defining the constraints for obtaining derived keys/BLS signatures/verifiable randomness.

The management canister API for vetKeys exposes two endpoints, one for retrieving a public key and another one for deriving encrypted keys.

```
vetkd_public_key : (vetkd_public_key_args) -> (vetkd_public_key_result);
vetkd_derive_key : (vetkd_derive_key_args) -> (vetkd_derive_key_result);
```

For more documentation on vetKeys and the management canister API, see the [vetKeys documentation](https://internetcomputer.org/docs/building-apps/network-features/vetkeys/introduction).

Please share your feedback on the [developer forum](https://forum.dfinity.org/t/threshold-key-derivation-privacy-on-the-ic/16560/179).

## Key Features

### **1. vetKeys Backend Library** ([Motoko](https://mops.one/ic-vetkeys), [Rust](https://crates.io/crates/ic-vetkeys)) - Supports canister developers

Tools to help canister developers integrate vetKeys into their Internet Computer (ICP) applications.

- **KeyManager** ([Motoko](https://mops.one/ic-vetkeys/docs/key_manager/KeyManager), [Rust](https://docs.rs/ic-vetkeys/latest/ic_vetkeys/key_manager/struct.KeyManager.html)) – a library for deriving and managing encrypted cryptographic keys.
- **EncryptedMaps** ([Motoko](https://mops.one/ic-vetkeys/docs/encrypted_maps/EncryptedMaps), [Rust](https://docs.rs/ic-vetkeys/latest/ic_vetkeys/encrypted_maps/struct.EncryptedMaps.html)) – a library for encrypting using vetkeys, and securely storing and sharing encrypted key-value pairs.
- **Utils** ([Rust](https://docs.rs/ic-vetkeys/latest/)) – Utility functions for working with vetKeys.

### **2. [vetKeys Frontend Library](./frontend/ic_vetkeys)** - Supports frontend developers

Tools for frontend developers to interact with VetKD enabled canisters.

- **[KeyManager](https://dfinity.github.io/vetkeys/classes/_dfinity_vetkeys_key_manager.KeyManager.html)** – Facilitates interaction with a KeyManager-enabled canister.
- **[EncryptedMaps](https://dfinity.github.io/vetkeys/classes/_dfinity_vetkeys_encrypted_maps.EncryptedMaps.html)** – Facilitates interaction with a EncryptedMaps-enabled canister.
- **[Utils](https://dfinity.github.io/vetkeys/modules/_dfinity_vetkeys.html)** – Utility functions for working with vetKeys.

### **3. vetKeys Example Applications** - Deployable to the IC with the click of a button

- **[Basic BLS Signing](examples/basic_bls_signing)** - Demonstrates secure threshold BLS signature generation where users can only sign messages for their own identity.
- **[Basic IBE](examples/basic_ibe)** - Shows how to implement secure messaging using Identity Based Encryption with Internet Identity Principals as encryption keys.
- **[Basic Timelock IBE](examples/basic_timelock_ibe)** - Implements a secret-bid auction system where bids remain encrypted until a specified deadline.
- **[Password Manager](examples/password_manager)** - A secure, decentralized password manager using Encrypted Maps for vault-based password storage and sharing.
- **[Password Manager with Metadata](examples/password_manager_with_metadata)** - Extends the basic password manager to support unencrypted metadata alongside encrypted passwords.
- **[Encrypted Notes](examples/encrypted_notes_dapp_vetkd)** - A secure note-taking application that uses vetKeys for encryption and enables sharing notes between users without device management.



================================================
FILE: Cargo.toml
================================================
[workspace]
members = [
    "backend/rs/ic_vetkeys",
    "backend/rs/ic_vetkeys_test_utils",
    "backend/rs/canisters/ic_vetkeys_encrypted_maps_canister",
    "backend/rs/canisters/ic_vetkeys_manager_canister",
    "backend/rs/canisters/tests",
    "backend/rs/benchmarks",
]
resolver = "2"

[workspace.package]
authors = ["DFINITY Stiftung"]
version = "0.1.0"
edition = "2021"
license = "Apache-2.0"
description = "Tools and examples for development with vetKeys on the Internet Computer"
repository = "https://github.com/dfinity/vetkeys"
rust-version = "1.85.0"
documentation = "https://docs.rs/ic-vetkeys"

[workspace.dependencies]
anyhow = "1.0.95"
candid = "0.10.16"
hex = "0.4.3"
ic-cdk = "0.18.5"
ic-cdk-macros = "0.18.5"
ic-stable-structures = "0.7.0"
lazy_static = "1.5.0"
pocket-ic = "9.0.0"
rand = "0.8.5"
rand_chacha = "0.3.1"
serde = "1.0.217"
serde_bytes = "0.11.15"
serde_cbor = "0.11.2"
ic-dummy-getrandom-for-wasm = "0.1.0"

[profile.release]
lto = true
opt-level = 'z'
panic = 'abort'



================================================
FILE: dfx.json
================================================
{
  "canisters": {
    "docs": {
      "type": "assets",
      "source": ["docs"]
    }
  }
}



================================================
FILE: LICENSE
================================================
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS



================================================
FILE: package.json
================================================
{
    "private": true,
    "workspaces": [
        "frontend/ic_vetkeys"
    ],
    "scripts": {
        "build": "npm run build --workspaces --if-present; npm run bundle --workspaces --if-present"
    },
    "devDependencies": {
        "svelte-hmr": "^0.16.0"
    }
}



================================================
FILE: rust-toolchain.toml
================================================
[toolchain]
channel = "1.85.0"
targets = ["wasm32-unknown-unknown"]
profile = "default"


================================================
FILE: backend/mo/canisters/ic_vetkeys_encrypted_maps_canister/README.md
================================================
# ic-vetkeys-encrypted-maps-canister

The canister implemented in this folder directly exposes the methods of the encrypted maps.
This is useful for:

1. running canister tests
2. implementing dapps that only require encrypted maps


================================================
FILE: backend/mo/canisters/ic_vetkeys_encrypted_maps_canister/dfx.json
================================================
{
  "canisters": {
    "ic_vetkeys_encrypted_maps_canister": {
      "main": "src/Main.mo",
      "type": "motoko",
      "args": "--enhanced-orthogonal-persistence"
    }
  },
  "defaults": {
    "build": {
      "packtool": "npx ic-mops sources"
    }
  }
}



================================================
FILE: backend/mo/canisters/ic_vetkeys_encrypted_maps_canister/Makefile
================================================
PWD:=$(shell pwd)

.PHONY: compile-wasm
.SILENT: compile-wasm
compile-wasm:
	dfx build --check

# Test the APIs of this canister using the respective Rust canister tests.
# This has the advantage that the tests are consistent (less room for bugs by having only one implementation of the tests) and the checked expected behavior is consistent across Rust and Motoko.
.PHONY: test
.SILENT: test
test: compile-wasm
	CUSTOM_WASM_PATH=$(PWD)/.dfx/local/canisters/ic_vetkeys_encrypted_maps_canister/ic_vetkeys_encrypted_maps_canister.wasm cargo test -p ic-vetkeys-encrypted-maps-canister



================================================
FILE: backend/mo/canisters/ic_vetkeys_encrypted_maps_canister/mops.toml
================================================
[package]
name = "ic-vetkeys-encrypted-maps-canister"
version = "0.1.0"
repository = "https://github.com/dfinity/vetkeys/backend/mo/canisters/ic_vetkeys_encrypted_maps_canister"
keywords = [
  "vetkeys,vetkd,encryption,privacy,signature,BLS,key ",
  "derivation,IBE"
]
license = "Apache-2.0"

[dependencies]
base = "0.14.6"
ic-vetkeys = "0.4.0"



================================================
FILE: backend/mo/canisters/ic_vetkeys_encrypted_maps_canister/.prettierrc
================================================
{
    "overrides": [{
      "files": "*.mo",
      "options": {
        "tabWidth": 4
      }
    }]
  }


================================================
FILE: backend/mo/canisters/ic_vetkeys_encrypted_maps_canister/src/Main.mo
================================================
import IcVetkeys "mo:ic-vetkeys";
import Types "mo:ic-vetkeys/Types";
import Principal "mo:base/Principal";
import Text "mo:base/Text";
import Blob "mo:base/Blob";
import Result "mo:base/Result";
import Array "mo:base/Array";

persistent actor class (keyName : Text) {
    let encryptedMapsState = IcVetkeys.EncryptedMaps.newEncryptedMapsState<Types.AccessRights>({ curve = #bls12_381_g2; name = keyName }, "password_manager_example_dapp");
    transient let encryptedMaps = IcVetkeys.EncryptedMaps.EncryptedMaps<Types.AccessRights>(encryptedMapsState, Types.accessRightsOperations());

    /// In this canister, we use the `ByteBuf` type to represent blobs. The reason is that we want to be consistent with the Rust canister implementation.
    /// Unfortunately, the `Blob` type cannot be serialized/deserialized in the current Rust implementation efficiently without nesting it in another type.
    public type ByteBuf = { inner : Blob };

    public type EncryptedMapData = {
        map_owner : Principal;
        map_name : ByteBuf;
        keyvals : [(ByteBuf, ByteBuf)];
        access_control : [(Principal, Types.AccessRights)];
    };

    /// The result type compatible with Rust's `Result`.
    public type Result<Ok, Err> = {
        #Ok : Ok;
        #Err : Err;
    };

    public query (msg) func get_accessible_shared_map_names() : async [(Principal, ByteBuf)] {
        Array.map<(Principal, Blob), (Principal, ByteBuf)>(
            encryptedMaps.getAccessibleSharedMapNames(msg.caller),

            func((principal, blob) : (Principal, Blob)) {
                (principal, { inner = blob });
            },
        );
    };

    public query (msg) func get_shared_user_access_for_map(
        map_owner : Principal,
        map_name : ByteBuf,
    ) : async Result<[(Principal, Types.AccessRights)], Text> {
        convertResult(encryptedMaps.getSharedUserAccessForMap(msg.caller, (map_owner, map_name.inner)));
    };

    public query (msg) func get_encrypted_values_for_map(
        map_owner : Principal,
        map_name : ByteBuf,
    ) : async Result<[(ByteBuf, ByteBuf)], Text> {
        let result = encryptedMaps.getEncryptedValuesForMap(msg.caller, (map_owner, map_name.inner));
        switch (result) {
            case (#err(e)) { #Err(e) };
            case (#ok(values)) {
                #Ok(
                    Array.map<(Blob, Blob), (ByteBuf, ByteBuf)>(
                        values,
                        func((blob1, blob2) : (Blob, Blob)) {
                            ({ inner = blob1 }, { inner = blob2 });
                        },
                    )
                );
            };
        };
    };

    public query (msg) func get_all_accessible_encrypted_values() : async [((Principal, ByteBuf), [(ByteBuf, ByteBuf)])] {
        Array.map<((Principal, Blob), [(Blob, Blob)]), ((Principal, ByteBuf), [(ByteBuf, ByteBuf)])>(
            encryptedMaps.getAllAccessibleEncryptedValues(msg.caller),
            func(((owner, map_name), values) : ((Principal, Blob), [(Blob, Blob)])) {
                (
                    (owner, { inner = map_name }),
                    Array.map<(Blob, Blob), (ByteBuf, ByteBuf)>(
                        values,
                        func((blob1, blob2) : (Blob, Blob)) {
                            ({ inner = blob1 }, { inner = blob2 });
                        },
                    ),
                );
            },
        );
    };

    public query (msg) func get_all_accessible_encrypted_maps() : async [EncryptedMapData] {
        Array.map<IcVetkeys.EncryptedMaps.EncryptedMapData<Types.AccessRights>, EncryptedMapData>(
            encryptedMaps.getAllAccessibleEncryptedMaps(msg.caller),
            func(map : IcVetkeys.EncryptedMaps.EncryptedMapData<Types.AccessRights>) : EncryptedMapData {
                {
                    map_owner = map.map_owner;
                    map_name = { inner = map.map_name };
                    keyvals = Array.map<(Blob, Blob), (ByteBuf, ByteBuf)>(
                        map.keyvals,
                        func((blob1, blob2) : (Blob, Blob)) {
                            ({ inner = blob1 }, { inner = blob2 });
                        },
                    );
                    access_control = map.access_control;
                };
            },
        );
    };

    public query (msg) func get_encrypted_value(
        map_owner : Principal,
        map_name : ByteBuf,
        map_key : ByteBuf,
    ) : async Result<?ByteBuf, Text> {
        let result = encryptedMaps.getEncryptedValue(msg.caller, (map_owner, map_name.inner), map_key.inner);
        switch (result) {
            case (#err(e)) { #Err(e) };
            case (#ok(null)) { #Ok(null) };
            case (#ok(?blob)) { #Ok(?{ inner = blob }) };
        };
    };

    public shared (msg) func remove_map_values(
        map_owner : Principal,
        map_name : ByteBuf,
    ) : async Result<[ByteBuf], Text> {
        let result = encryptedMaps.removeMapValues(msg.caller, (map_owner, map_name.inner));
        switch (result) {
            case (#err(e)) { #Err(e) };
            case (#ok(values)) {
                #Ok(
                    Array.map<Blob, ByteBuf>(
                        values,
                        func(blob : Blob) : ByteBuf {
                            { inner = blob };
                        },
                    )
                );
            };
        };
    };

    public query (msg) func get_owned_non_empty_map_names() : async [ByteBuf] {
        Array.map<Blob, ByteBuf>(
            encryptedMaps.getOwnedNonEmptyMapNames(msg.caller),
            func(blob : Blob) : ByteBuf {
                { inner = blob };
            },
        );
    };

    public shared (msg) func insert_encrypted_value(
        map_owner : Principal,
        map_name : ByteBuf,
        map_key : ByteBuf,
        value : ByteBuf,
    ) : async Result<?ByteBuf, Text> {
        let result = encryptedMaps.insertEncryptedValue(msg.caller, (map_owner, map_name.inner), map_key.inner, value.inner);
        switch (result) {
            case (#err(e)) { #Err(e) };
            case (#ok(null)) { #Ok(null) };
            case (#ok(?blob)) { #Ok(?{ inner = blob }) };
        };
    };

    public shared (msg) func remove_encrypted_value(
        map_owner : Principal,
        map_name : ByteBuf,
        map_key : ByteBuf,
    ) : async Result<?ByteBuf, Text> {
        let result = encryptedMaps.removeEncryptedValue(msg.caller, (map_owner, map_name.inner), map_key.inner);
        switch (result) {
            case (#err(e)) { #Err(e) };
            case (#ok(null)) { #Ok(null) };
            case (#ok(?blob)) { #Ok(?{ inner = blob }) };
        };
    };

    public shared func get_vetkey_verification_key() : async ByteBuf {
        let inner = await encryptedMaps.getVetkeyVerificationKey();
        { inner };
    };

    public shared (msg) func get_encrypted_vetkey(
        map_owner : Principal,
        map_name : ByteBuf,
        transport_key : ByteBuf,
    ) : async Result<ByteBuf, Text> {
        let result = await encryptedMaps.getEncryptedVetkey(msg.caller, (map_owner, map_name.inner), transport_key.inner);
        switch (result) {
            case (#err(e)) { #Err(e) };
            case (#ok(vetkey)) { #Ok({ inner = vetkey }) };
        };
    };

    public query (msg) func get_user_rights(
        map_owner : Principal,
        map_name : ByteBuf,
        user : Principal,
    ) : async Result<?Types.AccessRights, Text> {
        convertResult(encryptedMaps.getUserRights(msg.caller, (map_owner, map_name.inner), user));
    };

    public shared (msg) func set_user_rights(
        map_owner : Principal,
        map_name : ByteBuf,
        user : Principal,
        access_rights : Types.AccessRights,
    ) : async Result<?Types.AccessRights, Text> {
        convertResult(encryptedMaps.setUserRights(msg.caller, (map_owner, map_name.inner), user, access_rights));
    };

    public shared (msg) func remove_user(
        map_owner : Principal,
        map_name : ByteBuf,
        user : Principal,
    ) : async Result<?Types.AccessRights, Text> {
        convertResult(encryptedMaps.removeUser(msg.caller, (map_owner, map_name.inner), user));
    };

    /// Convert to the result type compatible with Rust's `Result`
    private func convertResult<Ok, Err>(result : Result.Result<Ok, Err>) : Result<Ok, Err> {
        switch (result) {
            case (#err(e)) { #Err(e) };
            case (#ok(o)) { #Ok(o) };
        };
    };
};



================================================
FILE: backend/mo/canisters/ic_vetkeys_manager_canister/README.md
================================================
# ic-vetkeys-manager-canister

The canister implemented in this folder directly exposes the methods of the key manager.
This is useful for:

1. running canister tests
2. implementing dapps that only require a key manager


================================================
FILE: backend/mo/canisters/ic_vetkeys_manager_canister/dfx.json
================================================
{
  "canisters": {
    "ic_vetkeys_manager_canister": {
      "main": "src/Main.mo",
      "type": "motoko",
      "args": "--enhanced-orthogonal-persistence"
    }
  },
  "defaults": {
    "build": {
      "packtool": "npx ic-mops sources"
    }
  }
}



================================================
FILE: backend/mo/canisters/ic_vetkeys_manager_canister/Makefile
================================================
PWD:=$(shell pwd)

.PHONY: compile-wasm
.SILENT: compile-wasm
compile-wasm:
	dfx build --check

# Test the APIs of this canister using the respective Rust canister tests.
# This has the advantage that the tests are consistent (less room for bugs by having only one implementation of the tests) and the checked expected behavior is consistent across Rust and Motoko.
.PHONY: test
.SILENT: test
test: compile-wasm
	CUSTOM_WASM_PATH=$(PWD)/.dfx/local/canisters/ic_vetkeys_manager_canister/ic_vetkeys_manager_canister.wasm cargo test -p ic-vetkeys-manager-canister



================================================
FILE: backend/mo/canisters/ic_vetkeys_manager_canister/mops.toml
================================================
[package]
name = "ic-vetkeys-manager-canister"
version = "0.1.0"
repository = "https://github.com/dfinity/vetkeys/backend/mo/canisters/ic_vetkeys_manager_canister"
keywords = [
  "vetkeys,vetkd,encryption,privacy,signature,BLS,key ",
  "derivation,IBE"
]
license = "Apache-2.0"

[dependencies]
base = "0.14.6"
ic-vetkeys = "0.3.0"


================================================
FILE: backend/mo/canisters/ic_vetkeys_manager_canister/.prettierrc
================================================
{
    "overrides": [{
      "files": "*.mo",
      "options": {
        "tabWidth": 4
      }
    }]
  }


================================================
FILE: backend/mo/canisters/ic_vetkeys_manager_canister/src/Main.mo
================================================
import IcVetkeys "mo:ic-vetkeys";
import Types "mo:ic-vetkeys/Types";
import Principal "mo:base/Principal";
import Text "mo:base/Text";
import Blob "mo:base/Blob";
import Result "mo:base/Result";
import Array "mo:base/Array";

actor class (keyName : Text) {
    var keyManager = IcVetkeys.KeyManager.KeyManager<Types.AccessRights>({ curve = #bls12_381_g2; name = keyName }, "key manager", Types.accessRightsOperations());
    /// In this canister, we use the `ByteBuf` type to represent blobs. The reason is that we want to be consistent with the Rust canister implementation.
    /// Unfortunately, the `Blob` type cannot be serialized/deserialized in the current Rust implementation efficiently without nesting it in another type.
    public type ByteBuf = { inner : Blob };

    /// The result type compatible with Rust's `Result`.
    public type Result<Ok, Err> = {
        #Ok : Ok;
        #Err : Err;
    };

    public query (msg) func get_accessible_shared_key_ids() : async [(Principal, ByteBuf)] {
        Array.map<(Principal, Blob), (Principal, ByteBuf)>(
            keyManager.getAccessibleSharedKeyIds(msg.caller),
            func((principal, blob) : (Principal, Blob)) {
                (principal, { inner = blob });
            },
        );
    };

    public query (msg) func get_shared_user_access_for_key(
        key_owner : Principal,
        key_name : ByteBuf,
    ) : async Result<[(Principal, Types.AccessRights)], Text> {
        convertResult(keyManager.getSharedUserAccessForKey(msg.caller, (key_owner, key_name.inner)));
    };

    public shared func get_vetkey_verification_key() : async ByteBuf {
        let inner = await keyManager.getVetkeyVerificationKey();
        { inner };
    };

    public shared (msg) func get_encrypted_vetkey(
        key_owner : Principal,
        key_name : ByteBuf,
        transport_key : ByteBuf,
    ) : async Result<ByteBuf, Text> {
        let vetkeyBytebuf = await keyManager.getEncryptedVetkey(msg.caller, (key_owner, key_name.inner), transport_key.inner);
        switch (vetkeyBytebuf) {
            case (#err(e)) { #Err(e) };
            case (#ok(inner)) { #Ok({ inner }) };
        };
    };

    public query (msg) func get_user_rights(
        key_owner : Principal,
        key_name : ByteBuf,
        user : Principal,
    ) : async Result<?Types.AccessRights, Text> {
        convertResult(keyManager.getUserRights(msg.caller, (key_owner, key_name.inner), user));
    };

    public shared (msg) func set_user_rights(
        key_owner : Principal,
        key_name : ByteBuf,
        user : Principal,
        access_rights : Types.AccessRights,
    ) : async Result<?Types.AccessRights, Text> {
        convertResult(keyManager.setUserRights(msg.caller, (key_owner, key_name.inner), user, access_rights));
    };

    public shared (msg) func remove_user(
        key_owner : Principal,
        key_name : ByteBuf,
        user : Principal,
    ) : async Result<?Types.AccessRights, Text> {
        convertResult(keyManager.removeUserRights(msg.caller, (key_owner, key_name.inner), user));
    };

    /// Convert to the result type compatible with Rust's `Result`
    private func convertResult<Ok, Err>(result : Result.Result<Ok, Err>) : Result<Ok, Err> {
        switch (result) {
            case (#err(e)) { #Err(e) };
            case (#ok(o)) { #Ok(o) };
        };
    };
};



================================================
FILE: backend/mo/ic_vetkeys/README.md
================================================
# Internet Computer (IC) vetKeys

This package contains a set of tools designed to help canister developers integrate **vetKeys** into their Internet Computer (ICP) applications.

## [Key Manager](https://mops.one/ic-vetkeys/docs/key_manager/KeyManager)
A canister library for derivation of encrypted vetkeys from arbitrary strings. It can be used in combination with the [frontend key manager library](https://dfinity.github.io/vetkeys/classes/_dfinity_vetkeys_key_manager.KeyManager.html).

## [Encrypted Maps](https://mops.one/ic-vetkeys/docs/encrypted_maps/EncryptedMaps)
An efficient canister library facilitating access control and encrypted storage for a collection of maps contatining key-value pairs. It can be used in combination with the [frontend encrypted maps library](https://dfinity.github.io/vetkeys/classes/_dfinity_vetkeys_encrypted_maps.EncryptedMaps.html).

## Cross-language library
If Rust better suits your needs, take a look at the [Rust equivalent of this library](https://docs.rs/ic_vetkeys).



================================================
FILE: backend/mo/ic_vetkeys/CHANGELOG.md
================================================
# Change Log

## [0.4.0] - 2025-09-29

### Breaking changes

- Fixed an inconsistency with the Rust backend in the signature format returned by `ManagementCanister.signWithBls`. Before, we returned the full response from `vetkd_derive_key` while we only need the last 48 bytes, which is the signature. Also, added a check to `signWithBls` which traps if the provided vetKD key id is not `#bls12_381_g2`.

- Fixed an inconsistency with the Rust backend in the returned text error messages. Two error messages were starting with a capital instead of small letter. This is now fixed.

- Extract state to state structures to separate the data from the state. This enables enhanced orthogonal persistence by declaring actors to be `persistent`.

## [0.3.0] - 2025-06-30

### Breaking changes

- Fixed a few inconsistencies with the Rust backend of encrypted maps. 

### Changed

- Updates dependencies.

### Added
- Sign with BLS and VetKD helper functions.

## [0.2.0] - 2025-06-18

### Fixed
- Links in code docs.
- Repository in mops.toml.

## [0.1.0] - 2025-06-11

Initial release


================================================
FILE: backend/mo/ic_vetkeys/mops.toml
================================================
[package]
name = "ic-vetkeys"
version = "0.4.0"
repository = "https://github.com/dfinity/vetkeys/backend/mo/ic_vetkeys"
description = "A set of tools designed to help canister developers integrate vetKeys into their Internet Computer (ICP) applications"
keywords = [
  "vetkeys",
  "vetkd",
  "encryption",
  "privacy",
  "signature",
  "bls",
  "key-derivation",
  "ibe"
]
license = "Apache-2.0"

[dependencies]
base = "0.14.9"

[dev-dependencies]
test = "2.1.1"



================================================
FILE: backend/mo/ic_vetkeys/.prettierrc
================================================
{
    "overrides": [{
      "files": "*.mo",
      "options": {
        "tabWidth": 4
      }
    }]
  }


================================================
SYMLINK: backend/mo/ic_vetkeys/LICENSE -> LICENSE
================================================



================================================
FILE: backend/mo/ic_vetkeys/src/lib.mo
================================================
import KeyManagerModule "key_manager/KeyManager";
import EncryptedMapsModule "encrypted_maps/EncryptedMaps";
import ManagementCanisterModule "ManagementCanister";
import Types "Types";

module {
    public type AccessControlOperations<T> = Types.AccessControlOperations<T>;
    public type AccessRights = Types.AccessRights;
    public let accessRightsOperations = Types.accessRightsOperations;

    public let KeyManager = KeyManagerModule;
    public let EncryptedMaps = EncryptedMapsModule;

    public let ManagementCanister = ManagementCanisterModule;
};



================================================
FILE: backend/mo/ic_vetkeys/src/ManagementCanister.mo
================================================
import Blob "mo:base/Blob";
import Debug "mo:base/Debug";
import Nat "mo:base/Nat";
import Array "mo:base/Array";

module {
    public type VetKdKeyid = {
        curve : { #bls12_381_g2 };
        name : Text;
    };

    public type VetkdSystemApi = actor {
        vetkd_public_key : ({
            canister_id : ?Principal;
            context : Blob;
            key_id : VetKdKeyid;
        }) -> async ({ public_key : Blob });
        vetkd_derive_key : ({
            context : Blob;
            input : Blob;
            key_id : VetKdKeyid;
            transport_public_key : Blob;
        }) -> async ({ encrypted_key : Blob });
    };

    public func vetKdDeriveKey(input : Blob, context : Blob, keyId : VetKdKeyid, transportPublicKey : Blob) : async Blob {
        let request = {
            context;
            input;
            key_id = keyId;
            transport_public_key = transportPublicKey;
        };
        let (reply) = await (with cycles = 26_153_846_153) (actor ("aaaaa-aa") : VetkdSystemApi).vetkd_derive_key(request);
        reply.encrypted_key;
    };

    public func vetKdPublicKey(canisterId : ?Principal, context : Blob, VetKdKeyid : VetKdKeyid) : async Blob {
        let request = {
            canister_id = canisterId;
            context;
            key_id = VetKdKeyid;
        };
        let (reply) = await (actor ("aaaaa-aa") : VetkdSystemApi).vetkd_public_key(request);
        reply.public_key;
    };

    public func signWithBls(message : Blob, context : Blob, vetKdKeyid : VetKdKeyid) : async Blob {
        if (vetKdKeyid.curve != #bls12_381_g2) {
            Debug.trap("Only BLS12-381 G2 is supported");
        };

        // Encryption with the G1 identity element produces unencrypted vetKeys
        let pointAtInfinity : Blob = Blob.fromArray([192, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
        let vetKdDeriveKeyResponse = await vetKdDeriveKey(message, context, vetKdKeyid, pointAtInfinity);

        let RESPONSE_SIZE : Nat = 192;
        let SIGNATURE_SIZE : Nat = 48;

        if (vetKdDeriveKeyResponse.size() != RESPONSE_SIZE) {
            Debug.trap("Expected " # Nat.toText(RESPONSE_SIZE) # " signature bytes, but got " # Nat.toText(vetKdDeriveKeyResponse.size()));
        };

        Blob.fromArray(Array.subArray<Nat8>(Blob.toArray(vetKdDeriveKeyResponse), RESPONSE_SIZE - SIGNATURE_SIZE, SIGNATURE_SIZE));
    };

    public func blsPublicKey(canisterId : ?Principal, context : Blob, VetKdKeyid : VetKdKeyid) : async Blob {
        await vetKdPublicKey(canisterId, context, VetKdKeyid);
    };
};



================================================
FILE: backend/mo/ic_vetkeys/src/Types.mo
================================================
module {
    public type AccessControlOperations<T> = {
        canRead : (t : T) -> Bool;
        canWrite : (t : T) -> Bool;
        canGetUserRights : (t : T) -> Bool;
        canSetUserRights : (t : T) -> Bool;
        ownerRights : () -> T;
        toText : (t : T) -> Text;
    };

    public type AccessRights = {
        #Read;
        #ReadWrite;
        #ReadWriteManage;
    };

    public func accessRightsOperations() : AccessControlOperations<AccessRights> {
        {
            canRead = func(accessRights : AccessRights) : Bool {
                switch (accessRights) {
                    case (#Read) { true };
                    case (#ReadWrite) { true };
                    case (#ReadWriteManage) { true };
                };
            };

            canWrite = func(accessRights : AccessRights) : Bool {
                switch (accessRights) {
                    case (#Read) { false };
                    case (#ReadWrite) { true };
                    case (#ReadWriteManage) { true };
                };
            };

            canGetUserRights = func(accessRights : AccessRights) : Bool {
                switch (accessRights) {
                    case (#Read) { false };
                    case (#ReadWrite) { false };
                    case (#ReadWriteManage) { true };
                };
            };

            canSetUserRights = func(accessRights : AccessRights) : Bool {
                switch (accessRights) {
                    case (#Read) { false };
                    case (#ReadWrite) { false };
                    case (#ReadWriteManage) { true };
                };
            };

            ownerRights = func() : AccessRights {
                #ReadWriteManage;
            };

            toText = func(accessRights : AccessRights) : Text {
                switch (accessRights) {
                    case (#Read) { "Read" };
                    case (#ReadWrite) { "ReadWrite" };
                    case (#ReadWriteManage) { "ReadWriteManage" };
                };
            };
        };
    };
};



================================================
FILE: backend/mo/ic_vetkeys/src/encrypted_maps/EncryptedMaps.mo
================================================
/// The **EncryptedMaps** backend is a support library built on top of `KeyManager`.
///
/// **EncryptedMaps** is designed to facilitate secure, encrypted data sharing between users on the Internet Computer (ICP) using the **vetKeys** feature. It allows developers to store encrypted key-value pairs (**maps**) securely and to manage fine-grained user access.
///
/// For an introduction to **vetKeys**, refer to the [vetKeys Overview](https://internetcomputer.org/docs/building-apps/network-features/vetkeys/introduction).
///
/// ## Core Features
///
/// The **EncryptedMaps** library provides the following key functionalities:
///
/// - **Encrypted Key-Value Storage:** Securely store and manage encrypted key-value pairs within named maps.
/// - **User-Specific Map Access:** Control precisely which users can read or modify entries in an encrypted map.
/// - **Integrated Access Control:** Leverages the **KeyManager** library to manage and enforce user permissions.
/// - **Stable Storage:** Utilizes **OrderedMap** for reliable, persistent storage across canister upgrades.
///
/// ## EncryptedMaps Architecture
///
/// The **EncryptedMaps** library contains:
///
/// - **Encrypted Values Storage:** Maps `(KeyId, MapKey)` to `EncryptedMapValue`, securely storing encrypted data.
/// - **KeyManager Integration:** Uses **KeyManager** to handle user permissions, ensuring authorized access to maps.
///
/// ## Example Use Case
///
/// 1. **User A** initializes an encrypted map and adds values.
/// 2. **User A** shares access to this map with **User B**.
/// 3. **User B** retrieves encrypted values securely.
/// 4. **User A** revokes **User B**'s access as necessary.
///
/// ## Security Considerations
///
/// - Encrypted values are stored securely with fine-grained access control.
/// - Access rights and permissions are strictly enforced.
/// - Data persists securely across canister upgrades through stable storage.
///
/// ## Summary
/// **EncryptedMaps** simplifies secure storage, retrieval, and controlled sharing of encrypted data on the Internet Computer, complementing the robust security and permissions management provided by **KeyManager**.

import Principal "mo:base/Principal";
import Blob "mo:base/Blob";
import Buffer "mo:base/Buffer";
import Array "mo:base/Array";
import Iter "mo:base/Iter";
import Option "mo:base/Option";
import Debug "mo:base/Debug";
import OrderedMap "mo:base/OrderedMap";
import Result "mo:base/Result";
import Types "../Types";
import Text "mo:base/Text";
import KeyManager "../key_manager/KeyManager";
import ManagementCanister "../ManagementCanister";

module {
    /// The caller requesting access to encrypted maps, represented as a Principal.
    public type Caller = Principal;

    /// The name of an encrypted map, used as part of the map identifier.
    public type MapName = KeyManager.KeyName;

    /// A unique identifier for an encrypted map, consisting of the owner and map name.
    public type MapId = KeyManager.KeyId;

    /// A key within an encrypted map, used to identify specific values.
    public type MapKey = Blob;

    /// An encrypted value stored within an encrypted map.
    public type EncryptedMapValue = Blob;

    /// Represents the complete data for an encrypted map, including ownership, contents, and access control.
    public type EncryptedMapData<T> = {
        map_owner : Principal;
        map_name : MapName;
        keyvals : [(MapKey, EncryptedMapValue)];
        access_control : [(Principal, T)];
    };

    func compareMapIds(a : MapId, b : MapId) : { #less; #greater; #equal } {
        let ownersCompare = Principal.compare(a.0, b.0);
        if (ownersCompare == #equal) {
            Blob.compare(a.1, b.1);
        } else {
            ownersCompare;
        };
    };

    func mapKeyValsMapOps() : OrderedMap.Operations<(MapId, MapKey)> {
        let compare = func(a : (MapId, MapKey), b : (MapId, MapKey)) : {
            #less;
            #greater;
            #equal;
        } {
            let mapIdCompare = compareMapIds(a.0, b.0);
            if (mapIdCompare == #equal) {
                Blob.compare(a.1, b.1);
            } else {
                mapIdCompare;
            };
        };
        return OrderedMap.Make<(MapId, MapKey)>(compare);
    };

    func mapKeysMapOps() : OrderedMap.Operations<MapId> {
        return OrderedMap.Make<MapId>(compareMapIds);
    };

    public type EncryptedMapsState<T> = {
        var keyManager : KeyManager.KeyManagerState<T>;
        var mapKeyVals : OrderedMap.Map<(MapId, MapKey), EncryptedMapValue>;
        var mapKeys : OrderedMap.Map<MapId, [MapKey]>;
    };

    public func newEncryptedMapsState<T>(vetKdKeyId : ManagementCanister.VetKdKeyid, domainSeparator : Text) : EncryptedMapsState<T> {
        {
            var keyManager = KeyManager.newKeyManagerState<T>(vetKdKeyId, domainSeparator);
            var mapKeyVals = mapKeyValsMapOps().empty();
            var mapKeys = mapKeysMapOps().empty();
        };
    };

    /// See the module documentation for more information.
    public class EncryptedMaps<T>(encryptedMapsState : EncryptedMapsState<T>, accessRightsOperations : Types.AccessControlOperations<T>) {
        let keyManager = KeyManager.KeyManager<T>(encryptedMapsState.keyManager, accessRightsOperations);

        /// Lists all map names shared with the caller.
        /// Returns a vector of map IDs that the caller has access to.
        public func getAccessibleSharedMapNames(caller : Caller) : [MapId] {
            keyManager.getAccessibleSharedKeyIds(caller);
        };

        /// Retrieves all users and their access rights for a specific map.
        /// The caller must have appropriate permissions to view this information.
        public func getSharedUserAccessForMap(caller : Caller, mapId : MapId) : Result.Result<[(Caller, T)], Text> {
            keyManager.getSharedUserAccessForKey(caller, mapId);
        };

        /// Removes all values from a map if the caller has sufficient rights.
        /// Returns the removed keys.
        /// The caller must have write permissions to perform this operation.
        public func removeMapValues(caller : Caller, mapId : MapId) : Result.Result<[MapKey], Text> {
            switch (keyManager.ensureUserCanWrite(caller, mapId)) {
                case (#err(msg)) { #err(msg) };
                case (#ok(_)) {
                    let keys = switch (mapKeysMapOps().get(encryptedMapsState.mapKeys, mapId)) {
                        case (null) { [] };
                        case (?ks) { ks };
                    };
                    for (key in keys.vals()) {
                        encryptedMapsState.mapKeyVals := mapKeyValsMapOps().delete(encryptedMapsState.mapKeyVals, (mapId, key));
                    };
                    encryptedMapsState.mapKeys := mapKeysMapOps().delete(encryptedMapsState.mapKeys, mapId);
                    #ok(keys);
                };
            };
        };

        /// Retrieves all encrypted key-value pairs from a map.
        /// The caller must have read permissions to access the map values.
        public func getEncryptedValuesForMap(caller : Caller, mapId : MapId) : Result.Result<[(MapKey, EncryptedMapValue)], Text> {
            switch (keyManager.ensureUserCanRead(caller, mapId)) {
                case (#err(msg)) { #err(msg) };
                case (#ok(_)) {
                    let values = Buffer.Buffer<(MapKey, EncryptedMapValue)>(0);
                    let keys = switch (mapKeysMapOps().get(encryptedMapsState.mapKeys, mapId)) {
                        case (null) { [] };
                        case (?ks) { ks };
                    };
                    for (key in keys.vals()) {
                        switch (mapKeyValsMapOps().get(encryptedMapsState.mapKeyVals, (mapId, key))) {
                            case (null) {};
                            case (?value) {
                                values.add((key, value));
                            };
                        };
                    };
                    #ok(Buffer.toArray(values));
                };
            };
        };

        /// Retrieves a specific encrypted value from a map.
        /// The caller must have read permissions to access the value.
        public func getEncryptedValue(caller : Caller, mapId : MapId, key : MapKey) : Result.Result<?EncryptedMapValue, Text> {
            switch (keyManager.ensureUserCanRead(caller, mapId)) {
                case (#err(msg)) { #err(msg) };
                case (#ok(_)) {
                    #ok(mapKeyValsMapOps().get(encryptedMapsState.mapKeyVals, (mapId, key)));
                };
            };
        };

        /// Retrieves the non-empty map names owned by the caller.
        public func getAllAccessibleEncryptedValues(caller : Caller) : [(MapId, [(MapKey, EncryptedMapValue)])] {
            let result = Buffer.Buffer<(MapId, [(MapKey, EncryptedMapValue)])>(0);
            for (mapId in getAccessibleMapIdsIter(caller)) {
                switch (getEncryptedValuesForMap(caller, mapId)) {
                    case (#err(_)) {
                        Debug.trap("bug: failed to get encrypted values");
                    };
                    case (#ok(mapValues)) {
                        result.add((mapId, mapValues));
                    };
                };
            };
            Buffer.toArray(result);
        };

        /// Retrieves all accessible encrypted maps and their data for the caller.
        public func getAllAccessibleEncryptedMaps(caller : Caller) : [EncryptedMapData<T>] {
            let result = Buffer.Buffer<EncryptedMapData<T>>(0);
            for (mapId in getAccessibleMapIdsIter(caller)) {
                let keyvals = switch (getEncryptedValuesForMap(caller, mapId)) {
                    case (#err(_)) {
                        Debug.trap("bug: failed to get encrypted values");
                    };
                    case (#ok(mapValues)) {
                        Array.map<(MapKey, EncryptedMapValue), (Blob, EncryptedMapValue)>(
                            mapValues,
                            func((key, value)) = (key, value),
                        );
                    };
                };
                let map = {
                    map_owner = mapId.0;
                    map_name = mapId.1;
                    keyvals = keyvals;
                    access_control = switch (getSharedUserAccessForMap(caller, mapId)) {
                        case (#err(_)) { [] };
                        case (#ok(access)) { access };
                    };
                };
                result.add(map);
            };
            Buffer.toArray(result);
        };

        /// Retrieves the non-empty map names owned by the caller.
        /// Returns a list of map names that contain at least one key-value pair.
        public func getOwnedNonEmptyMapNames(caller : Caller) : [MapName] {
            let mapNames = Buffer.Buffer<MapName>(0);
            for ((mapId, _) in mapKeysMapOps().entries(encryptedMapsState.mapKeys)) {
                if (Principal.equal(mapId.0, caller)) {
                    mapNames.add(mapId.1);
                };
            };
            Buffer.toArray(mapNames);
        };

        /// Inserts or updates an encrypted value in a map.
        /// The caller must have write permissions to modify the map.
        public func insertEncryptedValue(
            caller : Caller,
            mapId : MapId,
            key : MapKey,
            encryptedValue : EncryptedMapValue,
        ) : Result.Result<?EncryptedMapValue, Text> {
            switch (keyManager.ensureUserCanWrite(caller, mapId)) {
                case (#err(msg)) { #err(msg) };
                case (#ok(_)) {
                    let oldValue = mapKeyValsMapOps().get(encryptedMapsState.mapKeyVals, (mapId, key));
                    encryptedMapsState.mapKeyVals := mapKeyValsMapOps().put(encryptedMapsState.mapKeyVals, (mapId, key), encryptedValue);

                    // Update mapKeys
                    let currentKeys = switch (mapKeysMapOps().get(encryptedMapsState.mapKeys, mapId)) {
                        case (null) { [] };
                        case (?ks) { ks };
                    };
                    if (Option.isNull(Array.find<MapKey>(currentKeys, func(k) = Blob.equal(k, key)))) {
                        encryptedMapsState.mapKeys := mapKeysMapOps().put(encryptedMapsState.mapKeys, mapId, Array.append<MapKey>(currentKeys, [key]));
                    };

                    #ok(oldValue);
                };
            };
        };

        /// Removes an encrypted value from a map.
        /// The caller must have write permissions to modify the map.
        public func removeEncryptedValue(
            caller : Caller,
            mapId : MapId,
            key : MapKey,
        ) : Result.Result<?EncryptedMapValue, Text> {
            switch (keyManager.ensureUserCanWrite(caller, mapId)) {
                case (#err(msg)) { #err(msg) };
                case (#ok(_)) {
                    let oldValue = mapKeyValsMapOps().get(encryptedMapsState.mapKeyVals, (mapId, key));
                    encryptedMapsState.mapKeyVals := mapKeyValsMapOps().delete(encryptedMapsState.mapKeyVals, (mapId, key));

                    // Update mapKeys
                    let currentKeys = switch (mapKeysMapOps().get(encryptedMapsState.mapKeys, mapId)) {
                        case (null) { [] };
                        case (?ks) { ks };
                    };
                    let newKeys = Array.filter<MapKey>(currentKeys, func(k) = not Blob.equal(k, key));
                    if (newKeys.size() == 0) {
                        encryptedMapsState.mapKeys := mapKeysMapOps().delete(encryptedMapsState.mapKeys, mapId);
                    } else {
                        encryptedMapsState.mapKeys := mapKeysMapOps().put(encryptedMapsState.mapKeys, mapId, newKeys);
                    };

                    #ok(oldValue);
                };
            };
        };

        /// Retrieves the public verification key from KeyManager.
        /// This key is used to verify the authenticity of derived keys.
        public func getVetkeyVerificationKey() : async KeyManager.VetKeyVerificationKey {
            await keyManager.getVetkeyVerificationKey();
        };

        /// Retrieves an encrypted vetkey for caller and key id.
        /// The key is secured using the provided transport key and can only be accessed by authorized users.
        public func getEncryptedVetkey(
            caller : Caller,
            mapId : MapId,
            transportKey : KeyManager.TransportKey,
        ) : async Result.Result<KeyManager.VetKey, Text> {
            await keyManager.getEncryptedVetkey(caller, mapId, transportKey);
        };

        /// Retrieves access rights for a user to a map.
        /// The caller must have appropriate permissions to view this information.
        public func getUserRights(caller : Caller, mapId : MapId, user : Principal) : Result.Result<?T, Text> {
            keyManager.getUserRights(caller, mapId, user);
        };

        /// Sets or updates access rights for a user to a map.
        /// Only the map owner or a user with management rights can perform this action.
        public func setUserRights(
            caller : Caller,
            mapId : MapId,
            user : Principal,
            accessRights : T,
        ) : Result.Result<?T, Text> {
            keyManager.setUserRights(caller, mapId, user, accessRights);
        };

        /// Removes access rights for a user from a map.
        /// Only the map owner or a user with management rights can perform this action.
        public func removeUser(caller : Caller, mapId : MapId, user : Principal) : Result.Result<?T, Text> {
            keyManager.removeUserRights(caller, mapId, user);
        };

        // Private helper functions
        func getAccessibleMapIdsIter(caller : Caller) : Iter.Iter<MapId> {
            let accessibleMapIds = Iter.fromArray(getAccessibleSharedMapNames(caller));
            let ownedMapIds = Iter.map<MapName, MapId>(
                Iter.fromArray(getOwnedNonEmptyMapNames(caller)),
                func(mapName) = (caller, mapName),
            );
            return Iter.concat(accessibleMapIds, ownedMapIds);
        };
    };
};



================================================
FILE: backend/mo/ic_vetkeys/src/key_manager/KeyManager.mo
================================================
/// The **KeyManager** backend is a support library for **vetKeys**.
///
/// **vetKeys** is a feature of the Internet Computer (ICP) that enables the derivation of **encrypted cryptographic keys**. This library simplifies the process of key retrieval, encryption, and controlled sharing, ensuring secure and efficient key management for canisters and users.
///
/// For an introduction to **vetKeys**, refer to the [vetKeys Overview](https://internetcomputer.org/docs/building-apps/network-features/vetkeys/introduction).
///
/// ## Core Features
///
/// The **KeyManager** support library provides the following core functionalities:
///
/// - **Request an Encrypted Key:** Users can derive any number of **encrypted cryptographic keys**, secured using a user-provided **public transport key**. Each vetKey is associated with a unique **key id**.
/// - **Manage vetKey Sharing:** A user can **share their vetKeys** with other users while controlling access rights.
/// - **Access Control Management:** Users can define and enforce **fine-grained permissions** (read, write, manage) for each vetKey.
/// - **Uses Stable Storage:** The library persists key access information using **OrderedMap**, ensuring reliability across canister upgrades.
///
/// ## KeyManager Architecture
///
/// The **KeyManager** consists of two primary components:
///
/// 1. **Access Control Map** (`accessControl`): Maps `(Caller, KeyId)` to `T`, defining permissions for each user.
/// 2. **Shared Keys Map** (`sharedKeys`): Tracks which users have access to shared vetKeys.
///
/// ## Example Use Case
///
/// 1. **User A** requests a vetKey from KeyManager.
/// 2. KeyManager verifies permissions and derives an **encrypted cryptographic key**.
/// 3. **User A** securely shares access with **User B** using `setUserRights`.
/// 4. **User B** retrieves the key securely via `getEncryptedVetkey`.
///
/// ## Security Considerations
///
/// - vetKeys are derived **on demand** and constructed from encrypted vetKey shares.
/// - Only authorized users can access shared vetKeys.
/// - Stable storage ensures vetKeys persist across canister upgrades.
/// - Access control logic ensures only authorized users retrieve vetKeys or modify access rights.
///
/// ## Summary
/// `KeyManager` simplifies the usage of **vetKeys** on the ICP, providing a secure and efficient mechanism for **cryptographic key derivation, sharing, and management**.

import Principal "mo:base/Principal";
import Blob "mo:base/Blob";
import Buffer "mo:base/Buffer";
import Array "mo:base/Array";
import Debug "mo:base/Debug";
import OrderedMap "mo:base/OrderedMap";
import Result "mo:base/Result";
import Types "../Types";
import Text "mo:base/Text";
import Nat8 "mo:base/Nat8";
import ManagementCanister "../ManagementCanister";

module {
    /// The public verification key used to verify the authenticity of derived vetKeys.
    public type VetKeyVerificationKey = Blob;

    /// An encrypted cryptographic key derived using vetKD.
    public type VetKey = Blob;

    /// The owner of a vetKey, represented as a Principal.
    public type Owner = Principal;

    /// The caller requesting access to a vetKey, represented as a Principal.
    public type Caller = Principal;

    /// The name of a vetKey, used as part of the key identifier.
    public type KeyName = Blob;

    /// A unique identifier for a vetKey, consisting of the owner and key name.
    public type KeyId = (Owner, KeyName);

    /// The public transport key used to encrypt vetKeys for secure transmission.
    public type TransportKey = Blob;

    func compareKeyIds(a : KeyId, b : KeyId) : { #less; #greater; #equal } {
        let ownersCompare = Principal.compare(a.0, b.0);
        if (ownersCompare == #equal) {
            Blob.compare(a.1, b.1);
        } else {
            ownersCompare;
        };
    };

    func accessControlMapOps() : OrderedMap.Operations<Caller> {
        OrderedMap.Make<Caller>(Principal.compare);
    };

    func sharedKeysMapOps() : OrderedMap.Operations<KeyId> {
        OrderedMap.Make<KeyId>(compareKeyIds);
    };

    public type KeyManagerState<T> = {
        var accessControl : OrderedMap.Map<Principal, [(KeyId, T)]>;
        var sharedKeys : OrderedMap.Map<KeyId, [Principal]>;
        var vetKdKeyId : ManagementCanister.VetKdKeyid;
        domainSeparator : Text;
    };

    public func newKeyManagerState<T>(vetKdKeyId : ManagementCanister.VetKdKeyid, domainSeparator : Text) : KeyManagerState<T> {
        {
            var accessControl = accessControlMapOps().empty();
            var sharedKeys = sharedKeysMapOps().empty();
            var vetKdKeyId = vetKdKeyId;
            domainSeparator;
        };
    };

    /// See the module documentation for more information.
    public class KeyManager<T>(keyManagerState : KeyManagerState<T>, accessRightsOperations : Types.AccessControlOperations<T>) {
        let domainSeparatorBytes = Text.encodeUtf8(keyManagerState.domainSeparator);

        /// Retrieves all vetKey IDs shared with the given caller.
        /// This method returns a list of all vetKeys that the caller has access to.
        public func getAccessibleSharedKeyIds(caller : Caller) : [KeyId] {
            switch (accessControlMapOps().get(keyManagerState.accessControl, caller)) {
                case (null) { [] };
                case (?entries) {
                    Array.map<(KeyId, T), KeyId>(entries, func((keyId, _)) = keyId);
                };
            };
        };

        /// Retrieves a list of users with whom a given vetKey has been shared, along with their access rights.
        /// The caller must have appropriate permissions to view this information.
        public func getSharedUserAccessForKey(caller : Caller, keyId : KeyId) : Result.Result<[(Caller, T)], Text> {
            let canRead = ensureUserCanRead(caller, keyId);
            switch (canRead) {
                case (#err(msg)) { return #err(msg) };
                case (_) {};
            };

            let users = switch (sharedKeysMapOps().get(keyManagerState.sharedKeys, keyId)) {
                case (null) { return #ok([]) };
                case (?users) users;
            };

            let results = Buffer.Buffer<(Caller, T)>(0);
            for (user in users.vals()) {
                switch (getUserRights(caller, keyId, user)) {
                    case (#err(msg)) { return #err(msg) };
                    case (#ok(optRights)) {
                        switch (optRights) {
                            case (null) {
                                Debug.trap("bug: missing access rights");
                            };
                            case (?rights) {
                                results.add((user, rights));
                            };
                        };
                    };
                };
            };
            #ok(Buffer.toArray(results));
        };

        /// Retrieves the vetKD verification key for this canister.
        /// This key is used to verify the authenticity of derived vetKeys.
        public func getVetkeyVerificationKey() : async VetKeyVerificationKey {
            await ManagementCanister.vetKdPublicKey(null, domainSeparatorBytes, keyManagerState.vetKdKeyId);
        };

        /// Retrieves an encrypted vetKey for caller and key id.
        /// The vetKey is secured using the provided transport key and can only be accessed by authorized users.
        /// Returns an error if the caller is not authorized to access the vetKey.
        public func getEncryptedVetkey(caller : Caller, keyId : KeyId, transportKey : TransportKey) : async Result.Result<VetKey, Text> {
            switch (ensureUserCanRead(caller, keyId)) {
                case (#err(msg)) { #err(msg) };
                case (#ok(_)) {
                    let principalBytes = Blob.toArray(Principal.toBlob(keyId.0));
                    let input = Array.flatten<Nat8>([
                        [Nat8.fromNat(Array.size<Nat8>(principalBytes))],
                        principalBytes,
                        Blob.toArray(keyId.1),
                    ]);

                    #ok(await ManagementCanister.vetKdDeriveKey(Blob.fromArray(input), domainSeparatorBytes, keyManagerState.vetKdKeyId, transportKey));
                };
            };
        };

        /// Retrieves the access rights a given user has to a specific vetKey.
        /// The caller must have appropriate permissions to view this information.
        public func getUserRights(caller : Caller, keyId : KeyId, user : Principal) : Result.Result<?T, Text> {
            switch (ensureUserCanGetUserRights(caller, keyId)) {
                case (#err(msg)) { #err(msg) };
                case (#ok(_)) {
                    #ok(
                        do ? {
                            if (Principal.equal(user, keyId.0)) {
                                accessRightsOperations.ownerRights();
                            } else {
                                let entries = accessControlMapOps().get(keyManagerState.accessControl, user)!;
                                let (k, rights) = Array.find<(KeyId, T)>(
                                    entries,
                                    func((k, rights)) = compareKeyIds(k, keyId) == #equal,
                                )!;
                                rights;
                            };
                        }
                    );
                };
            };
        };

        /// Grants or modifies access rights for a user to a given vetKey.
        /// Only the vetKey owner or a user with management rights can perform this action.
        /// The vetKey owner cannot change their own rights.
        public func setUserRights(caller : Caller, keyId : KeyId, user : Principal, accessRights : T) : Result.Result<?T, Text> {
            switch (ensureUserCanSetUserRights(caller, keyId)) {
                case (#err(msg)) { #err(msg) };
                case (#ok(_)) {
                    if (Principal.equal(caller, keyId.0) and Principal.equal(caller, user)) {
                        return #err("cannot change key owner's user rights");
                    };

                    // Update sharedKeys
                    let currentUsers = switch (sharedKeysMapOps().get(keyManagerState.sharedKeys, keyId)) {
                        case (null) { [] };
                        case (?users) { users };
                    };

                    let newUsers = switch (Array.indexOf<Principal>(user, currentUsers, Principal.equal)) {
                        case (?_) currentUsers;
                        case (null) Array.append<Principal>(currentUsers, [user]);
                    };

                    keyManagerState.sharedKeys := sharedKeysMapOps().put(keyManagerState.sharedKeys, keyId, newUsers);

                    // Update accessControl
                    let currentEntries = switch (accessControlMapOps().get(keyManagerState.accessControl, user)) {
                        case (null) { [] };
                        case (?entries) { entries };
                    };

                    var oldRights : ?T = null;
                    let newEntries = switch (
                        Array.indexOf<(KeyId, T)>(
                            (keyId, accessRightsOperations.ownerRights()),
                            currentEntries,
                            func(a, b) = compareKeyIds(a.0, b.0) == #equal,
                        )
                    ) {
                        case (?index) {
                            let mutCurrentEntries = Array.thaw<(KeyId, T)>(currentEntries);
                            oldRights := ?mutCurrentEntries[index].1;
                            mutCurrentEntries[index] := (keyId, accessRights);
                            Array.freeze(mutCurrentEntries);
                        };
                        case (null) {
                            Array.append<(KeyId, T)>(currentEntries, [(keyId, accessRights)]);
                        };
                    };
                    keyManagerState.accessControl := accessControlMapOps().put(keyManagerState.accessControl, user, newEntries);
                    #ok(oldRights);
                };
            };
        };

        /// Revokes a user's access to a shared vetKey.
        /// The vetKey owner cannot remove their own access.
        /// Only the vetKey owner or a user with management rights can perform this action.
        public func removeUserRights(caller : Caller, keyId : KeyId, user : Principal) : Result.Result<?T, Text> {
            switch (ensureUserCanSetUserRights(caller, keyId)) {
                case (#err(msg)) { #err(msg) };
                case (#ok(_)) {
                    if (Principal.equal(caller, user) and Principal.equal(caller, keyId.0)) {
                        return #err("cannot remove key owner");
                    };

                    // Update sharedKeys
                    let currentUsers = switch (sharedKeysMapOps().get(keyManagerState.sharedKeys, keyId)) {
                        case (null) { [] };
                        case (?users) { users };
                    };
                    let newUsers = Array.filter<Caller>(currentUsers, func(u) = not Principal.equal(u, user));
                    keyManagerState.sharedKeys := sharedKeysMapOps().put(keyManagerState.sharedKeys, keyId, newUsers);

                    // Update accessControl
                    let currentEntries = switch (accessControlMapOps().get(keyManagerState.accessControl, user)) {
                        case (null) { [] };
                        case (?entries) { entries };
                    };
                    let (newEntries, oldRights) = Array.foldRight<(KeyId, T), ([(KeyId, T)], ?T)>(
                        currentEntries,
                        ([], null),
                        func((k, r), (entries, rights)) {
                            if (compareKeyIds(k, keyId) == #equal) {
                                (entries, ?r);
                            } else {
                                (Array.append<(KeyId, T)>(entries, [(k, r)]), rights);
                            };
                        },
                    );
                    keyManagerState.accessControl := accessControlMapOps().put(keyManagerState.accessControl, user, newEntries);
                    #ok(oldRights);
                };
            };
        };

        /// Ensures that a user has read access to a vetKey before proceeding.
        /// Returns an error if the user is not authorized.
        public func ensureUserCanRead(user : Principal, keyId : KeyId) : Result.Result<T, Text> {
            if (Principal.equal(user, keyId.0)) {
                return #ok(accessRightsOperations.ownerRights());
            };

            switch (accessControlMapOps().get(keyManagerState.accessControl, user)) {
                case (null) { #err("unauthorized") };
                case (?entries) {
                    for ((k, rights) in entries.vals()) {
                        if (compareKeyIds(k, keyId) == #equal) {
                            if (accessRightsOperations.canRead(rights)) {
                                return #ok(rights);
                            } else {
                                return #err("unauthorized");
                            };
                        };
                    };
                    #err("unauthorized");
                };
            };
        };

        /// Ensures that a user has write access to a vetKey before proceeding.
        /// Returns an error if the user is not authorized.
        public func ensureUserCanWrite(user : Principal, keyId : KeyId) : Result.Result<T, Text> {
            if (Principal.equal(user, keyId.0)) {
                return #ok(accessRightsOperations.ownerRights());
            };

            switch (accessControlMapOps().get(keyManagerState.accessControl, user)) {
                case (null) { #err("unauthorized") };
                case (?entries) {
                    for ((k, rights) in entries.vals()) {
                        if (compareKeyIds(k, keyId) == #equal) {
                            if (accessRightsOperations.canWrite(rights)) {
                                return #ok(rights);
                            } else {
                                return #err("unauthorized");
                            };
                        };
                    };
                    #err("unauthorized");
                };
            };
        };

        /// Ensures that a user has permission to view user rights for a vetKey.
        /// Returns an error if the user is not authorized.
        private func ensureUserCanGetUserRights(user : Principal, keyId : KeyId) : Result.Result<T, Text> {
            if (Principal.equal(user, keyId.0)) {
                return #ok(accessRightsOperations.ownerRights());
            };

            switch (accessControlMapOps().get(keyManagerState.accessControl, user)) {
                case (null) { #err("unauthorized") };
                case (?entries) {
                    for ((k, rights) in entries.vals()) {
                        if (compareKeyIds(k, keyId) == #equal) {
                            if (accessRightsOperations.canGetUserRights(rights)) {
                                return #ok(rights);
                            } else {
                                return #err("unauthorized");
                            };
                        };
                    };
                    #err("unauthorized");
                };
            };
        };

        /// Ensures that a user has management access to a vetKey before proceeding.
        /// Returns an error if the user is not authorized.
        private func ensureUserCanSetUserRights(user : Principal, keyId : KeyId) : Result.Result<T, Text> {
            if (Principal.equal(user, keyId.0)) {
                return #ok(accessRightsOperations.ownerRights());
            };

            switch (accessControlMapOps().get(keyManagerState.accessControl, user)) {
                case (null) { #err("unauthorized") };
                case (?entries) {
                    for ((k, rights) in entries.vals()) {
                        if (compareKeyIds(k, keyId) == #equal) {
                            if (accessRightsOperations.canSetUserRights(rights)) {
                                return #ok(rights);
                            } else {
                                return #err("unauthorized");
                            };
                        };
                    };
                    #err("unauthorized");
                };
            };
        };
    };
};



================================================
FILE: backend/mo/ic_vetkeys/test/EncryptedMaps.test.mo
================================================
import VetKey "../src";
import { EncryptedMaps } "../src";
import Principal "mo:base/Principal";
import Debug "mo:base/Debug";
import Text "mo:base/Text";
import Blob "mo:base/Blob";
import { test } "mo:test";

type EncryptedMaps = VetKey.EncryptedMaps.EncryptedMaps<VetKey.AccessRights>;
func newEncryptedMaps() : EncryptedMaps {
    let encryptedMapsState = EncryptedMaps.newEncryptedMapsState<VetKey.AccessRights>({ curve = #bls12_381_g2; name = "dfx_test_key" }, "encrypted maps");
    EncryptedMaps.EncryptedMaps<VetKey.AccessRights>(encryptedMapsState, VetKey.accessRightsOperations());
};

let p1 = Principal.fromText("2vxsx-fae");
let p2 = Principal.fromText("aaaaa-aa");
let mapName = Text.encodeUtf8("some map");
let mapKey = Text.encodeUtf8("some key");
let mapValue = Text.encodeUtf8("some value");

test(
    "can remove map values",
    func() {
        let encryptedMaps = newEncryptedMaps();
        let result = encryptedMaps.removeMapValues(p1, (p1, mapName));
        switch (result) {
            case (#ok(keys)) {
                assert keys == [];
            };
            case (#err(e)) {
                Debug.trap("Failed to remove map values: " # e);
            };
        };
    },
);

test(
    "unauthorized delete map values fails",
    func() {
        let encryptedMaps = newEncryptedMaps();

        // Insert a value first
        switch (encryptedMaps.insertEncryptedValue(p1, (p1, mapName), mapKey, mapValue)) {
            case (#err(e)) { Debug.trap("Failed to insert value: " # e) };
            case (#ok(_)) {};
        };

        // Try to remove with unauthorized user
        let result = encryptedMaps.removeMapValues(p2, (p1, mapName));
        assert result == #err("unauthorized");
    },
);

test(
    "can add user to map",
    func() {
        let encryptedMaps = newEncryptedMaps();

        // Check initial state
        switch (encryptedMaps.getUserRights(p1, (p1, mapName), p2)) {
            case (#ok(null)) {};
            case (unexpected) {
                Debug.trap("Unexpected initial state: " # debug_show (unexpected));
            };
        };

        // Set user rights
        switch (encryptedMaps.setUserRights(p1, (p1, mapName), p2, #ReadWriteManage)) {
            case (#ok(null)) {};
            case (unexpected) {
                Debug.trap("Failed to set user rights: " # debug_show (unexpected));
            };
        };

        // Verify rights were set
        switch (encryptedMaps.getUserRights(p1, (p1, mapName), p2)) {
            case (#ok(?#ReadWriteManage)) {};
            case (unexpected) {
                Debug.trap("Failed to verify user rights: " # debug_show (unexpected));
            };
        };
    },
);

test(
    "unauthorized cannot invoke operations",
    func() {
        let encryptedMaps = newEncryptedMaps();

        // Try various operations with unauthorized user
        assert encryptedMaps.getUserRights(p2, (p1, mapName), p2) == #err("unauthorized");
        assert encryptedMaps.getEncryptedValue(p2, (p1, mapName), mapKey) == #err("unauthorized");
        assert encryptedMaps.getEncryptedValuesForMap(p2, (p1, mapName)) == #err("unauthorized");
        assert encryptedMaps.removeMapValues(p2, (p1, mapName)) == #err("unauthorized");
        assert encryptedMaps.removeUser(p2, (p1, mapName), p2) == #err("unauthorized");
        assert encryptedMaps.setUserRights(p2, (p1, mapName), p2, #Read) == #err("unauthorized");

        assert encryptedMaps.insertEncryptedValue(p2, (p1, mapName), mapKey, mapValue) == #err("unauthorized");

        // Give read access and verify still can't write
        switch (encryptedMaps.setUserRights(p1, (p1, mapName), p2, #Read)) {
            case (#ok(_)) {};
            case (#err(e)) { Debug.trap("Failed to set read access: " # e) };
        };

        assert encryptedMaps.insertEncryptedValue(p2, (p1, mapName), mapKey, mapValue) == #err("unauthorized");

        assert encryptedMaps.setUserRights(p2, (p1, mapName), p2, #Read) == #err("unauthorized");
    },
);

test(
    "can remove user from map",
    func() {
        let encryptedMaps = newEncryptedMaps();

        // Add user first
        switch (encryptedMaps.setUserRights(p1, (p1, mapName), p2, #ReadWriteManage)) {
            case (#ok(null)) {};
            case (unexpected) {
                Debug.trap("Failed to add user: " # debug_show (unexpected));
            };
        };

        // Remove user
        switch (encryptedMaps.removeUser(p1, (p1, mapName), p2)) {
            case (#ok(?#ReadWriteManage)) {};
            case (unexpected) {
                Debug.trap("Failed to remove user: " # debug_show (unexpected));
            };
        };
    },
);

test(
    "can add a key to map",
    func() {
        let encryptedMaps = newEncryptedMaps();

        switch (encryptedMaps.insertEncryptedValue(p1, (p1, mapName), mapKey, mapValue)) {
            case (#ok(null)) {};
            case (unexpected) {
                Debug.trap("Failed to add key: " # debug_show (unexpected));
            };
        };
    },
);

test(
    "can remove a key from map",
    func() {
        let encryptedMaps = newEncryptedMaps();

        // Add key first
        switch (encryptedMaps.insertEncryptedValue(p1, (p1, mapName), mapKey, mapValue)) {
            case (#ok(_)) {};
            case (#err(e)) { Debug.trap("Failed to add key: " # e) };
        };

        // Remove key
        switch (encryptedMaps.removeEncryptedValue(p1, (p1, mapName), mapKey)) {
            case (#ok(?_)) {};
            case (unexpected) {
                Debug.trap("Failed to remove key: " # debug_show (unexpected));
            };
        };
    },
);

test(
    "can access map values",
    func() {
        let encryptedMaps = newEncryptedMaps();

        // Add a key-value pair
        switch (encryptedMaps.insertEncryptedValue(p1, (p1, mapName), mapKey, mapValue)) {
            case (#ok(_)) {};
            case (#err(e)) { Debug.trap("Failed to add key-value pair: " # e) };
        };

        for (accessRights in [#Read, #ReadWrite, #ReadWriteManage].vals()) {
            // Give read access to p2
            switch (encryptedMaps.setUserRights(p1, (p1, mapName), p2, accessRights)) {
                case (#ok(_)) {};
                case (#err(e)) { Debug.trap("Failed to set read access: " # e) };
            };

            // Verify p2 can read
            switch (encryptedMaps.getEncryptedValue(p2, (p1, mapName), mapKey)) {
                case (#ok(?_)) {};
                case (unexpected) {
                    Debug.trap("Failed to read value: " # debug_show (unexpected));
                };
            };
        };
    },
);

test(
    "can modify a key value in map",
    func() {
        let encryptedMaps = newEncryptedMaps();
        let newValue = Text.encodeUtf8("new value");

        // Add initial value
        switch (encryptedMaps.insertEncryptedValue(p1, (p1, mapName), mapKey, mapValue)) {
            case (#ok(_)) {};
            case (#err(e)) { Debug.trap("Failed to add initial value: " # e) };
        };

        // Modify value
        switch (encryptedMaps.insertEncryptedValue(p1, (p1, mapName), mapKey, newValue)) {
            case (#ok(?_)) {};
            case (unexpected) {
                Debug.trap("Failed to modify value: " # debug_show (unexpected));
            };
        };

        switch (encryptedMaps.getEncryptedValue(p1, (p1, mapName), mapKey)) {
            case (#ok(?returnedNewValue)) {
                assert returnedNewValue == newValue;
            };
            case (unexpected) {
                Debug.trap("Failed to get value: " # debug_show (unexpected));
            };
        };
    },
);

test(
    "can get owned map names",
    func() {
        let encryptedMaps = newEncryptedMaps();

        // Initially no maps
        assert encryptedMaps.getOwnedNonEmptyMapNames(p1) == [];

        // Add a key-value pair
        switch (encryptedMaps.insertEncryptedValue(p1, (p1, mapName), mapKey, mapValue)) {
            case (#ok(_)) {};
            case (#err(e)) { Debug.trap("Failed to add key-value pair: " # e) };
        };

        // Verify map appears in owned maps
        let ownedMaps = encryptedMaps.getOwnedNonEmptyMapNames(p1);
        assert ownedMaps.size() == 1;
        assert Blob.equal(ownedMaps[0], mapName);
    },
);



================================================
FILE: backend/mo/ic_vetkeys/test/KeyManager.test.mo
================================================
import VetKey "../src";
import Principal "mo:base/Principal";
import Debug "mo:base/Debug";
import Text "mo:base/Text";
import { test } "mo:test";

let accessRightsOperations = VetKey.accessRightsOperations();
let p1 = Principal.fromText("2vxsx-fae");
let p2 = Principal.fromText("aaaaa-aa");
let keyName = Text.encodeUtf8("some key");

func newKeyManager() : VetKey.KeyManager.KeyManager<VetKey.AccessRights> {
    let keyManagerState = VetKey.KeyManager.newKeyManagerState<VetKey.AccessRights>({ curve = #bls12_381_g2; name = "dfx_test_key" }, "key manager");
    VetKey.KeyManager.KeyManager<VetKey.AccessRights>(keyManagerState, accessRightsOperations);
};

test(
    "accessRightsOperations",
    func() {
        assert accessRightsOperations.canRead(#Read);
        assert not accessRightsOperations.canWrite(#Read);
        assert not accessRightsOperations.canSetUserRights(#Read);
        assert not accessRightsOperations.canGetUserRights(#Read);

        assert accessRightsOperations.canRead(#ReadWrite);
        assert accessRightsOperations.canWrite(#ReadWrite);
        assert not accessRightsOperations.canSetUserRights(#ReadWrite);
        assert not accessRightsOperations.canGetUserRights(#ReadWrite);

        assert accessRightsOperations.canRead(#ReadWriteManage);
        assert accessRightsOperations.canWrite(#ReadWriteManage);
        assert accessRightsOperations.canSetUserRights(#ReadWriteManage);
        assert accessRightsOperations.canGetUserRights(#ReadWriteManage);
    },
);

test(
    "can set and get user rights",
    func() {

        let keyManager = newKeyManager();

        switch (keyManager.getUserRights(p2, (p2, keyName), p2)) {
            case (#ok(?accessRights)) {
                assert accessRights == #ReadWriteManage;
            };
            case (unexpected) {
                Debug.trap("owner should have access rights " # debug_show (unexpected));
            };
        };

        switch (keyManager.getUserRights(p2, (p1, keyName), p2)) {
            case (#err e) {
                assert e == "unauthorized";
            };
            case (unexpected) {
                Debug.trap("user should not have access rights " # debug_show (unexpected));
            };
        };

        switch (keyManager.getUserRights(p1, (p1, keyName), p2)) {
            case (#ok null) {};
            case (#ok arg) {
                Debug.trap("already some access rights" # debug_show (arg));
            };
            case (#err e) {
                Debug.trap("should set user rights: " # e);
            };
        };

        switch (keyManager.setUserRights(p1, (p1, keyName), p2, #Read)) {
            case (#ok null) {};
            case (#ok arg) {
                Debug.trap("already some access rights" # debug_show (arg));
            };
            case (#err e) {
                Debug.trap("should set user rights: " # e);
            };
        };

        switch (keyManager.getUserRights(p2, (p1, keyName), p2)) {
            case (#err e) {
                assert e == "unauthorized";
            };
            case (unexpected) {
                Debug.trap("user should not have access rights with only read rights " # debug_show (unexpected));
            };
        };

        switch (keyManager.getUserRights(p1, (p1, keyName), p2)) {
            case (#ok(?arg)) { assert arg == #Read };
            case (#ok(null)) { Debug.trap("got null user rights in getter") };
            case (#err e) {
                Debug.trap("should get #read user rights: " # e);
            };
        };

        switch (keyManager.setUserRights(p1, (p1, keyName), p2, #ReadWriteManage)) {
            case (#ok null) { Debug.trap("got null user rights in setter") };
            case (#ok arg) {
                assert arg == ?#Read;
            };
            case (#err e) {
                Debug.trap("should set user rights: " # e);
            };
        };

        switch (keyManager.getUserRights(p2, (p1, keyName), p2)) {
            case (#ok(?arg)) {
                assert arg == #ReadWriteManage;
            };
            case (#ok arg) {
                Debug.trap("wrong access rights " # debug_show (arg));
            };
            case (#err e) {
                Debug.trap("user should get user rights: " # e);
            };
        };
    },
);

test(
    "can remove user rights",
    func() {
        let keyManager = newKeyManager();

        for (remover in [p1, p2].vals()) {
            switch (keyManager.setUserRights(p1, (p1, keyName), p2, #ReadWriteManage)) {
                case (#ok null) {};
                case (unexpected) {
                    Debug.trap("unexpected result in setting user rights: " # debug_show (unexpected));
                };
            };

            switch (keyManager.removeUserRights(remover, (p1, keyName), p2)) {
                case (#ok arg) {
                    assert arg == ?#ReadWriteManage;
                };
                case (unexpected) {
                    Debug.trap("unexpected result in removing user rights: " # debug_show (unexpected));
                };
            };

            switch (keyManager.getUserRights(p2, (p1, keyName), p2)) {
                case (#err e) {
                    assert e == "unauthorized";
                };
                case (unexpected) {
                    Debug.trap("user should not have access rights after removing user rights: " # debug_show (unexpected));
                };
            };

            switch (keyManager.getUserRights(p1, (p1, keyName), p2)) {
                case (#ok(null)) {};
                case (unexpected) {
                    Debug.trap("should not have access rights after removing user rights: " # debug_show (unexpected));
                };
            };
        };
    },
);

test(
    "get accessible shared key ids",
    func() {
        let keyManager = newKeyManager();
        assert keyManager.getAccessibleSharedKeyIds(p1) == [];
        assert keyManager.getAccessibleSharedKeyIds(p2) == [];

        do {
            let result = keyManager.setUserRights(p1, (p1, keyName), p2, #ReadWriteManage);
            assert result == #ok(null);
            assert keyManager.getAccessibleSharedKeyIds(p1) == [];
            assert keyManager.getAccessibleSharedKeyIds(p2) == [(p1, keyName)];
        };

        do {
            let result = keyManager.setUserRights(p2, (p2, keyName), p1, #ReadWriteManage);
            assert result == #ok(null);
            assert keyManager.getAccessibleSharedKeyIds(p1) == [(p2, keyName)];
            assert keyManager.getAccessibleSharedKeyIds(p2) == [(p1, keyName)];
        };

        let otherKey = Text.encodeUtf8("other key");

        do {
            let result = keyManager.setUserRights(p1, (p1, otherKey), p2, #ReadWriteManage);
            assert result == #ok(null);
            assert keyManager.getAccessibleSharedKeyIds(p1) == [(p2, keyName)];
            assert keyManager.getAccessibleSharedKeyIds(p2) == [(p1, keyName), (p1, otherKey)];
        };

        do {
            let result = keyManager.removeUserRights(p1, (p1, otherKey), p2);
            assert result == #ok(?#ReadWriteManage);
            assert keyManager.getAccessibleSharedKeyIds(p1) == [(p2, keyName)];
            assert keyManager.getAccessibleSharedKeyIds(p2) == [(p1, keyName)];
        };

        do {
            let result = keyManager.removeUserRights(p1, (p1, keyName), p2);
            assert result == #ok(?#ReadWriteManage);
            assert keyManager.getAccessibleSharedKeyIds(p1) == [(p2, keyName)];
            assert keyManager.getAccessibleSharedKeyIds(p2) == [];
        };

        do {
            let result = keyManager.removeUserRights(p2, (p2, keyName), p1);
            assert result == #ok(?#ReadWriteManage);
            assert keyManager.getAccessibleSharedKeyIds(p1) == [];
            assert keyManager.getAccessibleSharedKeyIds(p2) == [];
        };
    },
);

test(
    "get shared user access for a key",
    func() {
        let keyManager = newKeyManager();

        assert keyManager.getSharedUserAccessForKey(p1, (p1, keyName)) == #ok([]);

        do {
            let result = keyManager.setUserRights(p1, (p1, keyName), p2, #ReadWriteManage);
            assert result == #ok(null);
            for (user in [p1, p2].vals()) {
                assert keyManager.getSharedUserAccessForKey(p1, (p1, keyName)) == #ok([(p2, #ReadWriteManage)]);
            };
        };

        let p3 = Principal.fromText("nfxu4-cn7qt-x7r3c-5dhnk-dcrct-gmgoz-67gcg-5glvc-2krhv-gcmsr-qqe");

        do {
            let result = keyManager.setUserRights(p1, (p1, keyName), p3, #ReadWriteManage);
            assert result == #ok(null);
            for (user in [p1, p2, p3].vals()) {
                assert keyManager.getSharedUserAccessForKey(p1, (p1, keyName)) == #ok([(p2, #ReadWriteManage), (p3, #ReadWriteManage)]);
            };
        };

        do {
            let result = keyManager.removeUserRights(p1, (p1, keyName), p3);
            assert result == #ok(?#ReadWriteManage);
            for (user in [p1, p2].vals()) {
                assert keyManager.getSharedUserAccessForKey(p1, (p1, keyName)) == #ok([(p2, #ReadWriteManage)]);
            };
        };

        do {
            let result = keyManager.removeUserRights(p1, (p1, keyName), p2);
            assert result == #ok(?#ReadWriteManage);
            assert keyManager.getSharedUserAccessForKey(p1, (p1, keyName)) == #ok([]);
        };
    },
);



================================================
FILE: backend/rs/benchmarks/Cargo.toml
================================================
[package]
edition = "2021"
name = "benchmarks"
version = "0.1.0"

[[bin]]
name = "ibe"
path = "ibe/src/main.rs"

[dependencies]
canbench-rs = { version = "0.2.1", optional = true }
candid = "0.10.0"
getrandom = { version = "0.2", features = ["custom"] }
hex = { workspace = true }
ic-cdk = "0.18.5"
ic-vetkeys = { path = "../ic_vetkeys" }




================================================
FILE: backend/rs/benchmarks/ibe/canbench.yml
================================================
build_cmd: cargo build --release --target wasm32-unknown-unknown --locked --features canbench-rs

wasm_path: ../../../../target/wasm32-unknown-unknown/release/ibe.wasm


================================================
FILE: backend/rs/benchmarks/ibe/src/main.rs
================================================
#[cfg(feature = "canbench-rs")]
mod benches {
    use canbench_rs::bench;
    use ic_vetkeys::*;

    fn setup_ibe(msg_size: usize) -> (IbeCiphertext, VetKey) {
        let tsk = TransportSecretKey::from_seed(vec![0x42; 32]).unwrap();

        let dpk = DerivedPublicKey::deserialize(&hex::decode("972c4c6cc184b56121a1d27ef1ca3a2334d1a51be93573bd18e168f78f8fe15ce44fb029ffe8e9c3ee6bea2660f4f35e0774a35a80d6236c050fd8f831475b5e145116d3e83d26c533545f64b08464e4bcc755f990a381efa89804212d4eef5f").unwrap()).unwrap();

        let ek = EncryptedVetKey::deserialize(&hex::decode("b1a13757eaae15a3c8884fc1a3453f8a29b88984418e65f1bd21042ce1d6809b2f8a49f7326c1327f2a3921e8ff1d6c3adde2a801f1f88de98ccb40c62e366a279e7aec5875a0ce2f2a9f3e109d9cb193f0197eadb2c5f5568ee4d6a87e115910662e01e604087246be8b081fc6b8a06b4b0100ed1935d8c8d18d9f70d61718c5dba23a641487e72b3b25884eeede8feb3c71599bfbcebe60d29408795c85b4bdf19588c034d898e7fc513be8dbd04cac702a1672f5625f5833d063b05df7503").unwrap()).unwrap();

        let identity = hex::decode("6d657373616765").unwrap();

        let msg = hex::decode("11".repeat(msg_size)).unwrap();
        let seed = IbeSeed::from_bytes(&[0u8; 32]).unwrap();
        let ctext = IbeCiphertext::encrypt(&dpk, &IbeIdentity::from_bytes(&identity), &msg, &seed);

        let vetkey = ek.decrypt_and_verify(&tsk, &dpk, &identity).unwrap();

        (ctext, vetkey)
    }

    #[bench(raw)]
    fn ibe_decrypt_32_bytes_msg() -> canbench_rs::BenchResult {
        // Prevent the compiler from optimizing the call and propagating constants.
        let (ctext, vetkey) = std::hint::black_box(setup_ibe(std::hint::black_box(32)));

        canbench_rs::bench_fn(move || {
            let _ptext = ctext.decrypt(&vetkey).expect("IBE decryption failed");
        })
    }

    #[bench(raw)]
    fn ibe_decrypt_1_000_bytes_msg() -> canbench_rs::BenchResult {
        // Prevent the compiler from optimizing the call and propagating constants.
        let (ctext, vetkey) = std::hint::black_box(setup_ibe(std::hint::black_box(1_000)));

        canbench_rs::bench_fn(move || {
            let _ptext = ctext.decrypt(&vetkey).expect("IBE decryption failed");
        })
    }

    #[bench(raw)]
    fn ibe_decrypt_100_000_bytes_msg() -> canbench_rs::BenchResult {
        // Prevent the compiler from optimizing the call and propagating constants.
        let (ctext, vetkey) = std::hint::black_box(setup_ibe(std::hint::black_box(100_000)));

        canbench_rs::bench_fn(move || {
            let _ptext = ctext.decrypt(&vetkey).expect("IBE decryption failed");
        })
    }

    #[bench(raw)]
    fn ibe_decrypt_2_000_000_bytes_msg() -> canbench_rs::BenchResult {
        // Prevent the compiler from optimizing the call and propagating constants.
        let (ctext, vetkey) = std::hint::black_box(setup_ibe(std::hint::black_box(2_000_000)));

        canbench_rs::bench_fn(move || {
            let _ptext = ctext.decrypt(&vetkey).expect("IBE decryption failed");
        })
    }
}

fn main() {}

// In the following, we register a custom getrandom implementation because
// otherwise getrandom (which is a dependency of some other dependencies) fails to compile.
// This is necessary because getrandom by default fails to compile for the
// wasm32-unknown-unknown target (which is required for deploying a canister).
// Our custom implementation always fails, which is sufficient here because
// the used RNGs are _manually_ seeded rather than by the system.
#[cfg(all(
    target_arch = "wasm32",
    target_vendor = "unknown",
    target_os = "unknown"
))]
getrandom::register_custom_getrandom!(always_fail);
#[cfg(all(
    target_arch = "wasm32",
    target_vendor = "unknown",
    target_os = "unknown"
))]
fn always_fail(_buf: &mut [u8]) -> Result<(), getrandom::Error> {
    Err(getrandom::Error::UNSUPPORTED)
}



================================================
FILE: backend/rs/canisters/ic_vetkeys_encrypted_maps_canister/README.md
================================================
# ic-vetkeys-encrypted-maps-canister

The canister implemented in this folder directly exposes the methods of the encrypted maps.
This is useful for:

1. running canister tests
2. implementing dapps that only require encrypted maps


================================================
FILE: backend/rs/canisters/ic_vetkeys_encrypted_maps_canister/Cargo.toml
================================================
[package]
name = "ic-vetkeys-encrypted-maps-canister"
authors = ["DFINITY Stiftung"]
version = "0.1.0"
edition = "2021"
license = "Apache-2.0"
description = "# Basic Identity Based Encryption"
repository = "https://github.com/dfinity/vetkeys"
rust-version = "1.85.0"

[lib]
path = "src/lib.rs"
crate-type = ["cdylib"]

[dependencies]
candid = "0.10.2"
ic-cdk = "0.18.3"
ic-cdk-macros = "0.18.3"
ic-dummy-getrandom-for-wasm = "0.1.0"
ic-stable-structures = "0.6.8"
ic-vetkeys = "0.3.0"
serde = "1.0.217"

[dev-dependencies]
assert_matches = "1.5.0"
pocket-ic = "9.0.0"
rand = "0.8.5"
rand_chacha = "0.3.1"
reqwest = "0.12.12"
strum = "0.27.1"



================================================
FILE: backend/rs/canisters/ic_vetkeys_encrypted_maps_canister/dfx.json
================================================
{
  "canisters": {
    "ic_vetkeys_encrypted_maps_canister": {
      "candid": "ic_vetkeys_encrypted_maps_canister.did",
      "package": "ic-vetkeys-encrypted-maps-canister",
      "type": "rust"
    }
  },
  "output_env_file": ".env"
}


================================================
FILE: backend/rs/canisters/ic_vetkeys_encrypted_maps_canister/ic_vetkeys_encrypted_maps_canister.did
================================================
type AccessRights = variant { Read; ReadWrite; ReadWriteManage };
type ByteBuf = record { inner : blob };
type EncryptedMapData = record {
  access_control : vec record { principal; AccessRights };
  keyvals : vec record { ByteBuf; ByteBuf };
  map_name : ByteBuf;
  map_owner : principal;
};
type Result = variant { Ok : opt ByteBuf; Err : text };
type Result_1 = variant { Ok : vec record { ByteBuf; ByteBuf }; Err : text };
type Result_2 = variant { Ok : ByteBuf; Err : text };
type Result_3 = variant {
  Ok : vec record { principal; AccessRights };
  Err : text;
};
type Result_4 = variant { Ok : opt AccessRights; Err : text };
type Result_5 = variant { Ok : vec ByteBuf; Err : text };
service : (text) -> {
  get_accessible_shared_map_names : () -> (
      vec record { principal; ByteBuf },
    ) query;
  get_all_accessible_encrypted_maps : () -> (vec EncryptedMapData) query;
  get_all_accessible_encrypted_values : () -> (
      vec record {
        record { principal; ByteBuf };
        vec record { ByteBuf; ByteBuf };
      },
    ) query;
  get_encrypted_value : (principal, ByteBuf, ByteBuf) -> (Result) query;
  get_encrypted_values_for_map : (principal, ByteBuf) -> (Result_1) query;
  get_encrypted_vetkey : (principal, ByteBuf, ByteBuf) -> (Result_2);
  get_owned_non_empty_map_names : () -> (vec ByteBuf) query;
  get_shared_user_access_for_map : (principal, ByteBuf) -> (Result_3) query;
  get_user_rights : (principal, ByteBuf, principal) -> (Result_4) query;
  get_vetkey_verification_key : () -> (ByteBuf);
  insert_encrypted_value : (principal, ByteBuf, ByteBuf, ByteBuf) -> (Result);
  remove_encrypted_value : (principal, ByteBuf, ByteBuf) -> (Result);
  remove_map_values : (principal, ByteBuf) -> (Result_5);
  remove_user : (principal, ByteBuf, principal) -> (Result_4);
  set_user_rights : (principal, ByteBuf, principal, AccessRights) -> (Result_4);
}



================================================
FILE: backend/rs/canisters/ic_vetkeys_encrypted_maps_canister/Makefile
================================================
ROOT_DIR := $(shell git rev-parse --show-toplevel)

.PHONY: compile-wasm
.SILENT: compile-wasm
compile-wasm:
	cargo build --release --target wasm32-unknown-unknown

.PHONY: extract-candid
.SILENT: extract-candid
extract-candid: compile-wasm
	candid-extractor $(ROOT_DIR)/target/wasm32-unknown-unknown/release/ic_vetkeys_encrypted_maps_canister.wasm > ic_vetkeys_encrypted_maps_canister.did

.PHONY: clean
.SILENT: clean
clean:
	cargo clean
	rm -rf .dfx


================================================
FILE: backend/rs/canisters/ic_vetkeys_encrypted_maps_canister/src/lib.rs
================================================
use std::cell::RefCell;

use candid::Principal;
use ic_cdk::management_canister::{VetKDCurve, VetKDKeyId};
use ic_cdk::{init, query, update};
use ic_stable_structures::memory_manager::{MemoryId, MemoryManager, VirtualMemory};
use ic_stable_structures::storable::Blob;
use ic_stable_structures::DefaultMemoryImpl;
use ic_vetkeys::encrypted_maps::{EncryptedMapData, EncryptedMaps, VetKey, VetKeyVerificationKey};
use ic_vetkeys::types::{AccessRights, ByteBuf, EncryptedMapValue, TransportKey};

type Memory = VirtualMemory<DefaultMemoryImpl>;
type MapId = (Principal, ByteBuf);

thread_local! {
    static MEMORY_MANAGER: RefCell<MemoryManager<DefaultMemoryImpl>> =
        RefCell::new(MemoryManager::init(DefaultMemoryImpl::default()));
    static ENCRYPTED_MAPS: RefCell<Option<EncryptedMaps<AccessRights>>> =
        const { RefCell::new(None) };
}

#[init]
fn init(key_name: String) {
    let key_id = VetKDKeyId {
        curve: VetKDCurve::Bls12_381_G2,
        name: key_name,
    };
    ENCRYPTED_MAPS.with_borrow_mut(|encrypted_maps| {
        encrypted_maps.replace(EncryptedMaps::init(
            "encrypted_maps_dapp",
            key_id,
            id_to_memory(0),
            id_to_memory(1),
            id_to_memory(2),
            id_to_memory(3),
        ))
    });
}

#[query]
fn get_accessible_shared_map_names() -> Vec<(Principal, ByteBuf)> {
    ENCRYPTED_MAPS.with_borrow(|encrypted_maps| {
        encrypted_maps
            .as_ref()
            .unwrap()
            .get_accessible_shared_map_names(ic_cdk::api::msg_caller())
            .into_iter()
            .map(|map_id| (map_id.0, ByteBuf::from(map_id.1.as_ref().to_vec())))
            .collect()
    })
}

#[query]
fn get_shared_user_access_for_map(
    key_owner: Principal,
    key_name: ByteBuf,
) -> Result<Vec<(Principal, AccessRights)>, String> {
    let key_name = bytebuf_to_blob(key_name)?;
    let key_id = (key_owner, key_name);
    ENCRYPTED_MAPS.with_borrow(|encrypted_maps| {
        encrypted_maps
            .as_ref()
            .unwrap()
            .get_shared_user_access_for_map(ic_cdk::api::msg_caller(), key_id)
    })
}

#[query]
fn get_encrypted_values_for_map(
    map_owner: Principal,
    map_name: ByteBuf,
) -> Result<Vec<(ByteBuf, EncryptedMapValue)>, String> {
    let map_name = bytebuf_to_blob(map_name)?;
    let map_id = (map_owner, map_name);
    let result = ENCRYPTED_MAPS.with_borrow(|encrypted_maps| {
        encrypted_maps
            .as_ref()
            .unwrap()
            .get_encrypted_values_for_map(ic_cdk::api::msg_caller(), map_id)
    });
    result.map(|map_values| {
        map_values
            .into_iter()
            .map(|(key, value)| (ByteBuf::from(key.as_slice().to_vec()), value))
            .collect()
    })
}

#[query]
fn get_all_accessible_encrypted_values() -> Vec<(MapId, Vec<(ByteBuf, EncryptedMapValue)>)> {
    ENCRYPTED_MAPS
        .with_borrow(|encrypted_maps| {
            encrypted_maps
                .as_ref()
                .unwrap()
                .get_all_accessible_encrypted_values(ic_cdk::api::msg_caller())
        })
        .into_iter()
        .map(|((owner, map_name), encrypted_values)| {
            (
                (owner, ByteBuf::from(map_name.as_ref().to_vec())),
                encrypted_values
                    .into_iter()
                    .map(|(key, value)| (ByteBuf::from(key.as_ref().to_vec()), value))
                    .collect(),
            )
        })
        .collect()
}

#[query]
fn get_all_accessible_encrypted_maps() -> Vec<EncryptedMapData<AccessRights>> {
    ENCRYPTED_MAPS.with_borrow(|encrypted_maps| {
        encrypted_maps
            .as_ref()
            .unwrap()
            .get_all_accessible_encrypted_maps(ic_cdk::api::msg_caller())
    })
}

#[query]
fn get_encrypted_value(
    map_owner: Principal,
    map_name: ByteBuf,
    map_key: ByteBuf,
) -> Result<Option<EncryptedMapValue>, String> {
    let map_name = bytebuf_to_blob(map_name)?;
    let map_id = (map_owner, map_name);
    ENCRYPTED_MAPS.with_borrow(|encrypted_maps| {
        encrypted_maps.as_ref().unwrap().get_encrypted_value(
            ic_cdk::api::msg_caller(),
            map_id,
            bytebuf_to_blob(map_key)?,
        )
    })
}

#[update]
fn remove_map_values(
    map_owner: Principal,
    map_name: ByteBuf,
) -> Result<Vec<EncryptedMapValue>, String> {
    let map_name = bytebuf_to_blob(map_name)?;
    let map_id = (map_owner, map_name);
    let result = ENCRYPTED_MAPS.with_borrow_mut(|encrypted_maps| {
        encrypted_maps
            .as_mut()
            .unwrap()
            .remove_map_values(ic_cdk::api::msg_caller(), map_id)
    });
    result.map(|removed| {
        removed
            .into_iter()
            .map(|key| ByteBuf::from(key.as_ref().to_vec()))
            .collect()
    })
}

#[query]
fn get_owned_non_empty_map_names() -> Vec<ByteBuf> {
    ENCRYPTED_MAPS.with_borrow(|encrypted_maps| {
        encrypted_maps
            .as_ref()
            .unwrap()
            .get_owned_non_empty_map_names(ic_cdk::api::msg_caller())
            .into_iter()
            .map(|map_name| ByteBuf::from(map_name.as_slice().to_vec()))
            .collect()
    })
}

#[update]
fn insert_encrypted_value(
    map_owner: Principal,
    map_name: ByteBuf,
    map_key: ByteBuf,
    value: EncryptedMapValue,
) -> Result<Option<EncryptedMapValue>, String> {
    let map_name = bytebuf_to_blob(map_name)?;
    let map_id = (map_owner, map_name);
    ENCRYPTED_MAPS.with_borrow_mut(|encrypted_maps| {
        encrypted_maps.as_mut().unwrap().insert_encrypted_value(
            ic_cdk::api::msg_caller(),
            map_id,
            bytebuf_to_blob(map_key)?,
            value,
        )
    })
}

#[update]
fn remove_encrypted_value(
    map_owner: Principal,
    map_name: ByteBuf,
    map_key: ByteBuf,
) -> Result<Option<EncryptedMapValue>, String> {
    let map_name = bytebuf_to_blob(map_name)?;
    let map_id = (map_owner, map_name);
    ENCRYPTED_MAPS.with_borrow_mut(|encrypted_maps| {
        encrypted_maps.as_mut().unwrap().remove_encrypted_value(
            ic_cdk::api::msg_caller(),
            map_id,
            bytebuf_to_blob(map_key)?,
        )
    })
}

#[update]
async fn get_vetkey_verification_key() -> VetKeyVerificationKey {
    ENCRYPTED_MAPS
        .with_borrow(|encrypted_maps| {
            encrypted_maps
                .as_ref()
                .unwrap()
                .get_vetkey_verification_key()
        })
        .await
}

#[update]
async fn get_encrypted_vetkey(
    map_owner: Principal,
    map_name: ByteBuf,
    transport_key: TransportKey,
) -> Result<VetKey, String> {
    let map_name = bytebuf_to_blob(map_name)?;
    let map_id = (map_owner, map_name);
    Ok(ENCRYPTED_MAPS
        .with_borrow(|encrypted_maps| {
            encrypted_maps.as_ref().unwrap().get_encrypted_vetkey(
                ic_cdk::api::msg_caller(),
                map_id,
                transport_key,
            )
        })?
        .await)
}

#[query]
fn get_user_rights(
    map_owner: Principal,
    map_name: ByteBuf,
    user: Principal,
) -> Result<Option<AccessRights>, String> {
    let map_name = bytebuf_to_blob(map_name)?;
    let map_id = (map_owner, map_name);
    ENCRYPTED_MAPS.with_borrow(|encrypted_maps| {
        encrypted_maps
            .as_ref()
            .unwrap()
            .get_user_rights(ic_cdk::api::msg_caller(), map_id, user)
    })
}

#[update]
fn set_user_rights(
    map_owner: Principal,
    map_name: ByteBuf,
    user: Principal,
    access_rights: AccessRights,
) -> Result<Option<AccessRights>, String> {
    let map_name = bytebuf_to_blob(map_name)?;
    let map_id = (map_owner, map_name);
    ENCRYPTED_MAPS.with_borrow_mut(|encrypted_maps| {
        encrypted_maps.as_mut().unwrap().set_user_rights(
            ic_cdk::api::msg_caller(),
            map_id,
            user,
            access_rights,
        )
    })
}

#[update]
fn remove_user(
    map_owner: Principal,
    map_name: ByteBuf,
    user: Principal,
) -> Result<Option<AccessRights>, String> {
    let map_name = bytebuf_to_blob(map_name)?;
    let map_id = (map_owner, map_name);
    ENCRYPTED_MAPS.with_borrow_mut(|encrypted_maps| {
        encrypted_maps
            .as_mut()
            .unwrap()
            .remove_user(ic_cdk::api::msg_caller(), map_id, user)
    })
}

fn bytebuf_to_blob(buf: ByteBuf) -> Result<Blob<32>, String> {
    Blob::try_from(buf.as_ref()).map_err(|_| "too large input".to_string())
}

fn id_to_memory(id: u8) -> Memory {
    MEMORY_MANAGER.with(|m| m.borrow().get(MemoryId::new(id)))
}

ic_cdk::export_candid!();



================================================
FILE: backend/rs/canisters/ic_vetkeys_encrypted_maps_canister/tests/tests.rs
================================================
use assert_matches::assert_matches;
use candid::{decode_one, encode_args, encode_one, CandidType, Principal};
// use ic_stable_structures::storable::Blob;
// use ic_vetkeys::encrypted_maps::EncryptedMapData;
use ic_vetkeys::encrypted_maps::{VetKey, VetKeyVerificationKey};
use ic_vetkeys::key_manager::key_id_to_vetkd_input;
use ic_vetkeys::types::{AccessControl, AccessRights, ByteBuf, TransportKey};
use ic_vetkeys::{DerivedPublicKey, EncryptedVetKey, TransportSecretKey};
use pocket_ic::{PocketIc, PocketIcBuilder};
use rand::{CryptoRng, Rng, SeedableRng};
use rand_chacha::ChaCha20Rng;
use std::collections::BTreeMap;
use std::path::Path;
use strum::IntoEnumIterator;

#[test]
fn should_obtain_verification_key() {
    let rng = &mut reproducible_rng();
    let env = TestEnvironment::new(rng);
    let verification_key: VetKeyVerificationKey = env.update(
        env.principal_0,
        "get_vetkey_verification_key",
        encode_one(()).unwrap(),
    );
    assert_eq!(verification_key.as_ref().len(), 96);
    assert_ne!(verification_key, VetKeyVerificationKey::from(vec![0; 96]));
}

#[test]
fn should_obtain_owned_encrypted_vetkey() {
    let rng = &mut reproducible_rng();
    let env = TestEnvironment::new(rng);
    let map_owner = env.principal_0;
    let map_name = random_map_name(rng);
    let transport_key = random_transport_key(rng);
    let transport_key_bytes = TransportKey::from(transport_key.public_key());
    let encrypted_vetkey = env
        .update::<Result<VetKey, String>>(
            env.principal_0,
            "get_encrypted_vetkey",
            encode_args((map_owner, map_name, transport_key_bytes)).unwrap(),
        )
        .unwrap();

    assert_eq!(encrypted_vetkey.as_ref().len(), 192);
    assert_ne!(encrypted_vetkey, VetKeyVerificationKey::from(vec![0; 192]));
}

#[test]
fn encrypted_vetkey_should_validate() {
    let rng = &mut reproducible_rng();
    let env = TestEnvironment::new(rng);

    let verification_key_bytes: VetKeyVerificationKey = env.update(
        env.principal_0,
        "get_vetkey_verification_key",
        encode_one(()).unwrap(),
    );

    let map_owner = env.principal_0;
    let map_name = random_map_name(rng);
    let transport_key = random_transport_key(rng);
    let transport_key_bytes = TransportKey::from(transport_key.public_key());
    let encrypted_vetkey_bytes = env
        .update::<Result<VetKey, String>>(
            env.principal_0,
            "get_encrypted_vetkey",
            encode_args((map_owner, map_name.clone(), transport_key_bytes)).unwrap(),
        )
        .unwrap();

    let derived_public_key =
        DerivedPublicKey::deserialize(verification_key_bytes.as_ref()).unwrap();
    let encrypted_vetkey = EncryptedVetKey::deserialize(encrypted_vetkey_bytes.as_ref()).unwrap();

    encrypted_vetkey
        .decrypt_and_verify(
            &transport_key,
            &derived_public_key,
            &key_id_to_vetkd_input(map_owner, map_name.as_ref()),
        )
        .expect("failed to decrypt and verify `vetkey");
}

#[test]
fn map_sharing_should_work() {
    let rng = &mut reproducible_rng();
    let env = TestEnvironment::new(rng);

    let verification_key_bytes: VetKeyVerificationKey = env.update(
        env.principal_0,
        "get_vetkey_verification_key",
        encode_one(()).unwrap(),
    );

    let map_owner = env.principal_0;
    let map_name = random_map_name(rng);

    let prev_rights = env
        .update::<Result<Option<AccessRights>, String>>(
            env.principal_0,
            "set_user_rights",
            encode_args((
                map_owner,
                map_name.clone(),
                env.principal_1,
                AccessRights::ReadWriteManage,
            ))
            .unwrap(),
        )
        .unwrap();
    assert_eq!(prev_rights, None);

    let current_rights_owner = env
        .query::<Result<Option<AccessRights>, String>>(
            env.principal_0,
            "get_user_rights",
            encode_args((map_owner, map_name.clone(), env.principal_0)).unwrap(),
        )
        .unwrap();
    assert_eq!(current_rights_owner, Some(AccessRights::ReadWriteManage));

    let current_rights_shared = env
        .query::<Result<Option<AccessRights>, String>>(
            env.principal_1,
            "get_user_rights",
            encode_args((map_owner, map_name.clone(), env.principal_1)).unwrap(),
        )
        .unwrap();
    assert_eq!(current_rights_shared, Some(AccessRights::ReadWriteManage));

    let mut get_vetkey = |caller: Principal| -> Vec<u8> {
        let transport_key = random_transport_key(rng);
        let transport_key_bytes = TransportKey::from(transport_key.public_key());
        let encrypted_vetkey_bytes = env
            .update::<Result<VetKey, String>>(
                caller,
                "get_encrypted_vetkey",
                encode_args((map_owner, map_name.clone(), transport_key_bytes)).unwrap(),
            )
            .unwrap();

        let derived_public_key =
            DerivedPublicKey::deserialize(verification_key_bytes.as_ref()).unwrap();
        let encrypted_vetkey =
            EncryptedVetKey::deserialize(encrypted_vetkey_bytes.as_ref()).unwrap();

        let vetkey = encrypted_vetkey
            .decrypt_and_verify(
                &transport_key,
                &derived_public_key,
                &key_id_to_vetkd_input(map_owner, map_name.as_ref()),
            )
            .expect("failed to decrypt and verify `vetkey");

        vetkey.signature_bytes().as_ref().to_vec()
    };

    assert_eq!(get_vetkey(env.principal_0), get_vetkey(env.principal_1));
}

#[test]
fn should_remove_map_values() {
    let rng = &mut reproducible_rng();
    let env = TestEnvironment::new(rng);
    let caller = random_self_authenticating_principal(rng);
    let map_name = random_map_name(rng);

    let result = env.update::<Result<Vec<ByteBuf>, String>>(
        caller,
        "remove_map_values",
        encode_args((caller, map_name)).unwrap(),
    );
    assert_eq!(result, Ok(vec![]));
}

#[test]
fn should_fail_to_delete_map_values_by_unauthorized() {
    let rng = &mut reproducible_rng();
    let env = TestEnvironment::new(rng);
    let caller = random_self_authenticating_principal(rng);
    let unauthorized = random_self_authenticating_principal(rng);
    let map_name = random_map_name(rng);
    let map_key = random_map_key(rng);
    let encrypted_value = random_encrypted_value(rng);

    env.update::<Result<Option<ByteBuf>, String>>(
        caller,
        "insert_encrypted_value",
        encode_args((caller, map_name.clone(), map_key.clone(), encrypted_value)).unwrap(),
    )
    .unwrap();

    let result = env.update::<Result<Vec<ByteBuf>, String>>(
        unauthorized,
        "remove_map_values",
        encode_args((caller, map_name)).unwrap(),
    );
    assert_eq!(result, Err("unauthorized".to_string()));
}

#[test]
fn should_add_user_to_map() {
    let rng = &mut reproducible_rng();
    let env = TestEnvironment::new(rng);
    let caller = random_self_authenticating_principal(rng);
    let map_name = random_map_name(rng);
    let user_to_be_added = random_self_authenticating_principal(rng);
    let access_rights = random_access_rights(rng);

    assert_eq!(
        env.query::<Result<Option<AccessRights>, String>>(
            caller,
            "get_user_rights",
            encode_args((caller, map_name.clone(), user_to_be_added)).unwrap(),
        ),
        Ok(None)
    );

    assert_eq!(
        env.update::<Result<Option<AccessRights>, String>>(
            caller,
            "set_user_rights",
            encode_args((caller, map_name.clone(), user_to_be_added, access_rights)).unwrap(),
        ),
        Ok(None)
    );

    assert_eq!(
        env.update::<Result<Option<AccessRights>, String>>(
            caller,
            "set_user_rights",
            encode_args((caller, map_name.clone(), user_to_be_added, access_rights)).unwrap(),
        ),
        Ok(Some(access_rights))
    );

    assert_eq!(
        env.query::<Result<Option<AccessRights>, String>>(
            caller,
            "get_user_rights",
            encode_args((caller, map_name.clone(), user_to_be_added)).unwrap(),
        ),
        Ok(Some(access_rights))
    );
}

#[test]
fn should_fail_to_invoke_operations_by_unauthorized() {
    let rng = &mut reproducible_rng();
    let env = TestEnvironment::new(rng);
    let unauthorized = random_self_authenticating_principal(rng);
    let owner = random_self_authenticating_principal(rng);
    let map_name = random_map_name(rng);
    let map_key = random_map_key(rng);
    let _encrypted_value = random_encrypted_value(rng);

    assert_eq!(
        env.query::<Result<Option<AccessRights>, String>>(
            unauthorized,
            "get_user_rights",
            encode_args((owner, map_name.clone(), unauthorized)).unwrap(),
        ),
        Err("unauthorized".to_string())
    );

    assert_eq!(
        env.query::<Result<Option<ByteBuf>, String>>(
            unauthorized,
            "get_encrypted_value",
            encode_args((owner, map_name.clone(), map_key)).unwrap(),
        ),
        Err("unauthorized".to_string())
    );

    assert_eq!(
        env.query::<Result<Vec<(ByteBuf, ByteBuf)>, String>>(
            unauthorized,
            "get_encrypted_values_for_map",
            encode_args((owner, map_name.clone())).unwrap(),
        ),
        Err("unauthorized".to_string())
    );

    for _ in 0..2 {
        assert_eq!(
            env.update::<Result<Vec<ByteBuf>, String>>(
                unauthorized,
                "remove_map_values",
                encode_args((owner, map_name.clone())).unwrap(),
            ),
            Err("unauthorized".to_string())
        );

        assert_eq!(
            env.update::<Result<Option<AccessRights>, String>>(
                unauthorized,
                "remove_user",
                encode_args((owner, map_name.clone(), unauthorized)).unwrap(),
            ),
            Err("unauthorized".to_string())
        );

        assert_eq!(
            env.update::<Result<Option<AccessRights>, String>>(
                unauthorized,
                "set_user_rights",
                encode_args((owner, map_name.clone(), unauthorized, AccessRights::Read)).unwrap(),
            ),
            Err("unauthorized".to_string())
        );

        env.update::<Result<Option<AccessRights>, String>>(
            owner,
            "set_user_rights",
            encode_args((owner, map_name.clone(), unauthorized, AccessRights::Read)).unwrap(),
        )
        .unwrap();
    }

    env.update::<Result<Option<AccessRights>, String>>(
        owner,
        "set_user_rights",
        encode_args((
            owner,
            map_name.clone(),
            unauthorized,
            AccessRights::ReadWrite,
        ))
        .unwrap(),
    )
    .unwrap();

    assert_eq!(
        env.update::<Result<Option<AccessRights>, String>>(
            unauthorized,
            "set_user_rights",
            encode_args((owner, map_name.clone(), unauthorized, AccessRights::Read)).unwrap(),
        ),
        Err("unauthorized".to_string())
    );
}

#[test]
fn should_remove_user_from_map() {
    let rng = &mut reproducible_rng();
    let env = TestEnvironment::new(rng);
    let caller = random_self_authenticating_principal(rng);
    let map_name = random_map_name(rng);
    let user_to_be_added = random_self_authenticating_principal(rng);
    let access_rights = random_access_rights(rng);

    assert_eq!(
        env.update::<Result<Option<AccessRights>, String>>(
            caller,
            "set_user_rights",
            encode_args((caller, map_name.clone(), user_to_be_added, access_rights)).unwrap(),
        ),
        Ok(None)
    );

    assert_eq!(
        env.update::<Result<Option<AccessRights>, String>>(
            caller,
            "remove_user",
            encode_args((caller, map_name.clone(), user_to_be_added)).unwrap(),
        ),
        Ok(Some(access_rights))
    );
}

#[test]
fn should_fail_add_or_remove_user_by_unauthorized() {
    let rng = &mut reproducible_rng();
    let env = TestEnvironment::new(rng);
    let caller = random_self_authenticating_principal(rng);
    let map_name = random_map_name(rng);
    let mut unauthorized_callers = vec![random_self_authenticating_principal(rng)];

    for access_rights in AccessRights::iter() {
        if access_rights.can_get_user_rights() {
            continue;
        }
        let user_to_be_added = random_self_authenticating_principal(rng);

        assert_matches!(
            env.update::<Result<Option<AccessRights>, String>>(
                caller,
                "set_user_rights",
                encode_args((caller, map_name.clone(), user_to_be_added, access_rights)).unwrap(),
            ),
            Ok(_)
        );

        unauthorized_callers.push(user_to_be_added);
    }

    for unauthorized_caller in unauthorized_callers {
        for target in [random_self_authenticating_principal(rng), caller] {
            assert_eq!(
                env.update::<Result<Option<AccessRights>, String>>(
                    unauthorized_caller,
                    "remove_user",
                    encode_args((caller, map_name.clone(), target)).unwrap(),
                ),
                Err("unauthorized".to_string())
            );
            assert_eq!(
                env.update::<Result<Option<AccessRights>, String>>(
                    unauthorized_caller,
                    "set_user_rights",
                    encode_args((caller, map_name.clone(), target, AccessRights::Read)).unwrap(),
                ),
                Err("unauthorized".to_string())
            );
        }
    }
}

#[test]
fn should_add_a_key_to_map() {
    let rng = &mut reproducible_rng();
    let env = TestEnvironment::new(rng);
    let caller = random_self_authenticating_principal(rng);
    let map_name = random_map_name(rng);
    let map_key = random_map_key(rng);
    let encrypted_value = random_encrypted_value(rng);

    assert_eq!(
        env.update::<Result<Option<ByteBuf>, String>>(
            caller,
            "insert_encrypted_value",
            encode_args((caller, map_name.clone(), map_key, encrypted_value)).unwrap(),
        ),
        Ok(None)
    );
}

#[test]
fn should_fail_to_add_a_key_to_map_by_unauthorized() {
    let rng = &mut reproducible_rng();
    let env = TestEnvironment::new(rng);
    let caller = random_self_authenticating_principal(rng);
    let map_name = random_map_name(rng);
    let unauthorized_caller = random_self_authenticating_principal(rng);
    let map_key = random_map_key(rng);
    let encrypted_value = random_encrypted_value(rng);

    assert_eq!(
        env.update::<Result<Option<ByteBuf>, String>>(
            unauthorized_caller,
            "insert_encrypted_value",
            encode_args((
                caller,
                map_name.clone(),
                map_key.clone(),
                encrypted_value.clone()
            ))
            .unwrap(),
        ),
        Err("unauthorized".to_string())
    );

    let readonly_caller = random_self_authenticating_principal(rng);

    assert_eq!(
        env.update::<Result<Option<AccessRights>, String>>(
            caller,
            "set_user_rights",
            encode_args((
                caller,
                map_name.clone(),
                readonly_caller,
                AccessRights::Read
            ))
            .unwrap(),
        ),
        Ok(None)
    );

    assert_eq!(
        env.update::<Result<Option<ByteBuf>, String>>(
            readonly_caller,
            "insert_encrypted_value",
            encode_args((caller, map_name.clone(), map_key.clone(), encrypted_value)).unwrap(),
        ),
        Err("unauthorized".to_string())
    );
}

#[test]
fn should_remove_key_from_map() {
    let rng = &mut reproducible_rng();
    let env = TestEnvironment::new(rng);
    let caller = random_self_authenticating_principal(rng);
    let map_name = random_map_name(rng);
    let map_key = random_map_key(rng);
    let encrypted_value = random_encrypted_value(rng);

    env.update::<Result<Option<ByteBuf>, String>>(
        caller,
        "insert_encrypted_value",
        encode_args((
            caller,
            map_name.clone(),
            map_key.clone(),
            encrypted_value.clone(),
        ))
        .unwrap(),
    )
    .unwrap();

    assert_eq!(
        env.update::<Result<Option<ByteBuf>, String>>(
            caller,
            "remove_encrypted_value",
            encode_args((caller, map_name.clone(), map_key.clone())).unwrap(),
        ),
        Ok(Some(encrypted_value))
    );
}

#[test]
fn should_fail_to_remove_a_key_from_map_by_unauthorized() {
    let rng = &mut reproducible_rng();
    let env = TestEnvironment::new(rng);
    let caller = random_self_authenticating_principal(rng);
    let map_name = random_map_name(rng);
    let map_key = random_map_key(rng);
    let encrypted_value = random_encrypted_value(rng);

    env.update::<Result<Option<ByteBuf>, String>>(
        caller,
        "insert_encrypted_value",
        encode_args((caller, map_name.clone(), map_key.clone(), encrypted_value)).unwrap(),
    )
    .unwrap();

    let unauthorized_caller = random_self_authenticating_principal(rng);
    assert_eq!(
        env.update::<Result<Option<ByteBuf>, String>>(
            unauthorized_caller,
            "remove_encrypted_value",
            encode_args((caller, map_name.clone(), map_key.clone())).unwrap(),
        ),
        Err("unauthorized".to_string())
    );

    let readonly_caller = random_self_authenticating_principal(rng);

    assert_eq!(
        env.update::<Result<Option<AccessRights>, String>>(
            caller,
            "set_user_rights",
            encode_args((
                caller,
                map_name.clone(),
                readonly_caller,
                AccessRights::Read
            ))
            .unwrap(),
        ),
        Ok(None)
    );

    assert_eq!(
        env.update::<Result<Option<ByteBuf>, String>>(
            readonly_caller,
            "remove_encrypted_value",
            encode_args((caller, map_name.clone(), map_key.clone())).unwrap(),
        ),
        Err("unauthorized".to_string())
    );
}

#[test]
fn should_access_map_values() {
    let rng = &mut reproducible_rng();
    let env = TestEnvironment::new(rng);
    let caller = random_self_authenticating_principal(rng);
    let map_name = random_map_name(rng);

    let mut authorized_users = vec![(caller, AccessRights::ReadWriteManage)];
    let mut keyvals = vec![];

    for _ in 0..3 {
        let map_key = random_map_key(rng);
        let encrypted_value = random_small_encrypted_value(rng);
        env.update::<Result<Option<ByteBuf>, String>>(
            caller,
            "insert_encrypted_value",
            encode_args((
                caller,
                map_name.clone(),
                map_key.clone(),
                encrypted_value.clone(),
            ))
            .unwrap(),
        )
        .unwrap();

        for access_rights in AccessRights::iter() {
            let user_to_be_added = random_self_authenticating_principal(rng);
            assert_eq!(
                env.update::<Result<Option<AccessRights>, String>>(
                    caller,
                    "set_user_rights",
                    encode_args((caller, map_name.clone(), user_to_be_added, access_rights))
                        .unwrap(),
                ),
                Ok(None)
            );
            authorized_users.push((user_to_be_added, access_rights));
        }

        keyvals.push((map_key, encrypted_value));
    }

    for (map_key, encrypted_value) in keyvals.clone() {
        for (user, _access_rights) in authorized_users.iter() {
            assert_eq!(
                env.query::<Result<Option<ByteBuf>, String>>(
                    *user,
                    "get_encrypted_value",
                    encode_args((caller, map_name.clone(), map_key.clone())).unwrap(),
                ),
                Ok(Some(encrypted_value.clone()))
            );
        }
    }

    for (user, _access_rights) in authorized_users.clone() {
        let expected_map = BTreeMap::from_iter(keyvals.clone());
        let computed_map_single = BTreeMap::from_iter(
            env.query::<Result<Vec<(ByteBuf, ByteBuf)>, String>>(
                user,
                "get_encrypted_values_for_map",
                encode_args((caller, map_name.clone())).unwrap(),
            )
            .expect("failed to obtain values"),
        );
        assert_eq!(expected_map.clone(), computed_map_single);

        let all_values = env.query::<Vec<((Principal, ByteBuf), Vec<(ByteBuf, ByteBuf)>)>>(
            user,
            "get_all_accessible_encrypted_values",
            encode_one(()).unwrap(),
        );
        assert_eq!(all_values.len(), 1);

        // let all_maps = env.query::<Vec<EncryptedMapData<AccessRights>>>(
        //     user,
        //     "get_all_accessible_encrypted_maps",
        //     encode_one(()).unwrap(),
        // );

        // assert_eq!(
        //     all_values,
        //     all_maps
        //         .iter()
        //         .map(|m| (
        //             (
        //                 m.map_owner,
        //                 Blob::<32>::try_from(m.map_name.as_ref()).unwrap()
        //             ),
        //             m.keyvals
        //                 .iter()
        //                 .map(|(map_key, value)| (
        //                     Blob::<32>::try_from(map_key.as_ref()).unwrap(),
        //                     value.clone()
        //                 ))
        //                 .collect::<Vec<_>>()
        //         ))
        //         .collect::<Vec<_>>()
        // );

        let all_destructured = all_values.into_iter().next().unwrap();
        assert_eq!((caller, map_name.clone()), all_destructured.0);
        let computed_map_wildcard = all_destructured.1;
        assert_eq!(
            expected_map.clone(),
            BTreeMap::from_iter(computed_map_wildcard)
        );

        // for map in all_maps {
        //     if access_rights.can_get_user_rights() {
        //         assert_eq!(
        //             BTreeMap::<Principal, AccessRights>::from_iter(
        //                 map.access_control
        //                     .into_iter()
        //                     .chain(std::iter::once((caller, access_rights)))
        //             ),
        //             BTreeMap::from_iter(authorized_users.clone().into_iter())
        //         );
        //     } else {
        //         assert_eq!(map.access_control, vec![]);
        //     }
        // }
    }
}

#[test]
fn should_modify_key_value_in_map() {
    let rng = &mut reproducible_rng();
    let env = TestEnvironment::new(rng);
    let caller = random_self_authenticating_principal(rng);
    let map_name = random_map_name(rng);
    let map_key = random_map_key(rng);
    let encrypted_value = random_encrypted_value(rng);

    env.update::<Result<Option<ByteBuf>, String>>(
        caller,
        "insert_encrypted_value",
        encode_args((
            caller,
            map_name.clone(),
            map_key.clone(),
            encrypted_value.clone(),
        ))
        .unwrap(),
    )
    .unwrap();

    let new_encrypted_value = random_encrypted_value(rng);
    assert_eq!(
        env.update::<Result<Option<ByteBuf>, String>>(
            caller,
            "insert_encrypted_value",
            encode_args((
                caller,
                map_name.clone(),
                map_key.clone(),
                new_encrypted_value
            ))
            .unwrap(),
        ),
        Ok(Some(encrypted_value))
    );
}

#[test]
fn should_fail_modify_key_value_in_map_by_unauthorized() {
    let rng = &mut reproducible_rng();
    let env = TestEnvironment::new(rng);
    let caller = random_self_authenticating_principal(rng);
    let map_name = random_map_name(rng);
    let map_key = random_map_key(rng);
    let encrypted_value = random_encrypted_value(rng);

    env.update::<Result<Option<ByteBuf>, String>>(
        caller,
        "insert_encrypted_value",
        encode_args((
            caller,
            map_name.clone(),
            map_key.clone(),
            encrypted_value.clone(),
        ))
        .unwrap(),
    )
    .unwrap();

    let unauthorized_caller = random_self_authenticating_principal(rng);
    let new_encrypted_value = random_encrypted_value(rng);
    assert_eq!(
        env.update::<Result<Option<ByteBuf>, String>>(
            unauthorized_caller,
            "insert_encrypted_value",
            encode_args((
                caller,
                map_name.clone(),
                map_key.clone(),
                new_encrypted_value.clone()
            ))
            .unwrap(),
        ),
        Err("unauthorized".to_string())
    );

    let readonly_caller = random_self_authenticating_principal(rng);

    assert_eq!(
        env.update::<Result<Option<AccessRights>, String>>(
            caller,
            "set_user_rights",
            encode_args((
                caller,
                map_name.clone(),
                readonly_caller,
                AccessRights::Read
            ))
            .unwrap(),
        ),
        Ok(None)
    );

    assert_eq!(
        env.update::<Result<Option<ByteBuf>, String>>(
            readonly_caller,
            "insert_encrypted_value",
            encode_args((caller, map_name.clone(), map_key, new_encrypted_value)).unwrap(),
        ),
        Err("unauthorized".to_string())
    );
}

#[test]
fn should_get_owned_map_names() {
    let rng = &mut reproducible_rng();
    let env = TestEnvironment::new(rng);
    let caller = random_self_authenticating_principal(rng);
    let mut expected_map_names = vec![];

    for _ in 0..7 {
        let map_names = env.query::<Vec<ByteBuf>>(
            caller,
            "get_owned_non_empty_map_names",
            encode_one(()).unwrap(),
        );
        assert_eq!(map_names.len(), expected_map_names.len());
        for map_name in expected_map_names.iter() {
            assert!(map_names.contains(map_name));
        }

        let map_name = random_map_name(rng);
        expected_map_names.push(map_name.clone());

        for _ in 1..3 {
            let map_key = random_map_key(rng);
            let encrypted_value = random_encrypted_value(rng);
            env.update::<Result<Option<ByteBuf>, String>>(
                caller,
                "insert_encrypted_value",
                encode_args((caller, map_name.clone(), map_key, encrypted_value)).unwrap(),
            )
            .unwrap();
        }

        let map_names = env.query::<Vec<ByteBuf>>(
            caller,
            "get_owned_non_empty_map_names",
            encode_one(()).unwrap(),
        );
        assert_eq!(map_names.len(), expected_map_names.len());
        for map_name in expected_map_names.iter() {
            assert!(map_names.contains(map_name));
        }

        let should_remove_map = rng.gen_bool(0.2);

        if should_remove_map {
            env.update::<Result<Vec<ByteBuf>, String>>(
                caller,
                "remove_map_values",
                encode_args((caller, map_name.clone())).unwrap(),
            )
            .unwrap();
            expected_map_names.pop();
        }
    }
}

pub fn reproducible_rng() -> ChaCha20Rng {
    let seed = rand::thread_rng().gen();
    println!("RNG seed: {seed:?}");
    ChaCha20Rng::from_seed(seed)
}

struct TestEnvironment {
    pic: PocketIc,
    example_canister_id: Principal,
    principal_0: Principal,
    principal_1: Principal,
}

impl TestEnvironment {
    fn new<R: Rng + CryptoRng>(rng: &mut R) -> Self {
        let pic = PocketIcBuilder::new()
            .with_application_subnet()
            .with_ii_subnet()
            .with_fiduciary_subnet()
            .with_nonmainnet_features(true)
            .build();

        let example_canister_id = pic.create_canister();
        pic.add_cycles(example_canister_id, 2_000_000_000_000);

        let example_wasm_bytes = load_encrypted_maps_example_canister_wasm();
        pic.install_canister(
            example_canister_id,
            example_wasm_bytes,
            encode_one("dfx_test_key").unwrap(),
            None,
        );

        // Make sure the canister is properly initialized
        fast_forward(&pic, 5);

        Self {
            pic,
            example_canister_id,
            principal_0: random_self_authenticating_principal(rng),
            principal_1: random_self_authenticating_principal(rng),
        }
    }

    fn update<T: CandidType + for<'de> candid::Deserialize<'de>>(
        &self,
        caller: Principal,
        method_name: &str,
        args: Vec<u8>,
    ) -> T {
        let reply = self
            .pic
            .update_call(self.example_canister_id, caller, method_name, args);
        match reply {
            Ok(data) => decode_one(&data).expect("failed to decode reply"),
            Err(user_error) => panic!("canister returned a user error: {user_error}"),
        }
    }

    fn query<T: CandidType + for<'de> candid::Deserialize<'de>>(
        &self,
        caller: Principal,
        method_name: &str,
        args: Vec<u8>,
    ) -> T {
        let reply = self
            .pic
            .query_call(self.example_canister_id, caller, method_name, args);
        match reply {
            Ok(data) => decode_one(&data).expect("failed to decode reply"),
            Err(user_error) => panic!("canister returned a user error: {user_error}"),
        }
    }
}

fn load_encrypted_maps_example_canister_wasm() -> Vec<u8> {
    let wasm_path_string = match std::env::var("CUSTOM_WASM_PATH") {
        Ok(path) if !path.is_empty() => path,
        _ => format!(
            "{}/target/wasm32-unknown-unknown/release/ic_vetkeys_encrypted_maps_canister.wasm",
            git_root_dir()
        ),
    };
    let wasm_path = Path::new(&wasm_path_string);
    std::fs::read(wasm_path)
        .expect("wasm does not exist - run `cargo build --release --target wasm32-unknown-unknown`")
}

fn random_transport_key<R: Rng + CryptoRng>(rng: &mut R) -> TransportSecretKey {
    let mut seed = vec![0u8; 32];
    rng.fill_bytes(&mut seed);
    TransportSecretKey::from_seed(seed).unwrap()
}

fn fast_forward(ic: &PocketIc, ticks: u64) {
    for _ in 0..ticks - 1 {
        ic.tick();
    }
}

fn random_map_name<R: Rng + CryptoRng>(rng: &mut R) -> ByteBuf {
    let length = rng.gen_range(0..32);
    let mut map_name = vec![0u8; length];
    rng.fill_bytes(&mut map_name);
    ByteBuf::from(map_name)
}

pub fn random_self_authenticating_principal<R: Rng + CryptoRng>(rng: &mut R) -> Principal {
    let mut fake_public_key = vec![0u8; 32];
    rng.fill_bytes(&mut fake_public_key);
    Principal::self_authenticating::<&[u8]>(fake_public_key.as_ref())
}

fn git_root_dir() -> String {
    let output = std::process::Command::new("git")
        .args(["rev-parse", "--show-toplevel"])
        .output()
        .expect("Failed to execute git command");
    assert!(output.status.success());
    let root_dir_with_newline =
        String::from_utf8(output.stdout).expect("Failed to convert stdout to string");
    root_dir_with_newline.trim_end_matches('\n').to_string()
}

fn random_map_key<R: Rng + CryptoRng>(rng: &mut R) -> ByteBuf {
    let length = rng.gen_range(0..32);
    let mut map_key = vec![0u8; length];
    rng.fill_bytes(&mut map_key);
    ByteBuf::from(map_key)
}

fn random_encrypted_value<R: Rng + CryptoRng>(rng: &mut R) -> ByteBuf {
    let length = rng.gen_range(0..2_000_000);
    let mut encrypted_value = vec![0u8; length];
    rng.fill_bytes(&mut encrypted_value);
    ByteBuf::from(encrypted_value)
}

fn random_small_encrypted_value<R: Rng + CryptoRng>(rng: &mut R) -> ByteBuf {
    let length = rng.gen_range(0..1_000);
    let mut encrypted_value = vec![0u8; length];
    rng.fill_bytes(&mut encrypted_value);
    ByteBuf::from(encrypted_value)
}

fn random_access_rights<R: Rng + CryptoRng>(rng: &mut R) -> AccessRights {
    loop {
        if let Some(ar) = AccessRights::from_repr(rng.gen()) {
            return ar;
        }
    }
}



================================================
FILE: backend/rs/canisters/ic_vetkeys_manager_canister/README.md
================================================
# ic-vetkeys-manager-canister

The canister implemented in this folder directly exposes the methods of the key manager.
This is useful for:

1. running canister tests
2. implementing dapps that only require a key manager


================================================
FILE: backend/rs/canisters/ic_vetkeys_manager_canister/Cargo.toml
================================================
[package]
name = "ic-vetkeys-manager-canister"
authors.workspace = true
description.workspace = true
documentation.workspace = true
edition.workspace = true
version.workspace = true
license.workspace = true

[lib]
path = "src/lib.rs"
crate-type = ["cdylib"]

[dependencies]
candid = { workspace = true }
ic-cdk = { workspace = true }
ic-cdk-macros = { workspace = true }
ic-dummy-getrandom-for-wasm = { workspace = true }
ic-stable-structures = { workspace = true }
ic-vetkeys = { path = "../../ic_vetkeys" }
serde = { workspace = true }

[dev-dependencies]
assert_matches = "1.5.0"
ic-vetkeys-test-utils = { path = "../../ic_vetkeys_test_utils" }
pocket-ic = { workspace = true }
rand = { workspace = true }
rand_chacha = { workspace = true }
reqwest = "0.12.12"



================================================
FILE: backend/rs/canisters/ic_vetkeys_manager_canister/dfx.json
================================================
{
    "canisters": {
      "ic_vetkeys_manager_canister": {
        "candid": "ic_vetkeys_manager_canister.did",
        "package": "ic-vetkeys-manager-canister",
        "type": "rust"
      }
    },
    "output_env_file": ".env"
  }


================================================
FILE: backend/rs/canisters/ic_vetkeys_manager_canister/ic_vetkeys_manager_canister.did
================================================
type AccessRights = variant { Read; ReadWrite; ReadWriteManage };
type ByteBuf = record { inner : blob };
type Result = variant { Ok : ByteBuf; Err : text };
type Result_1 = variant {
  Ok : vec record { principal; AccessRights };
  Err : text;
};
type Result_2 = variant { Ok : opt AccessRights; Err : text };
service : (text) -> {
  get_accessible_shared_key_ids : () -> (
      vec record { principal; ByteBuf },
    ) query;
  get_encrypted_vetkey : (principal, ByteBuf, ByteBuf) -> (Result);
  get_shared_user_access_for_key : (principal, ByteBuf) -> (Result_1) query;
  get_user_rights : (principal, ByteBuf, principal) -> (Result_2) query;
  get_vetkey_verification_key : () -> (ByteBuf);
  remove_user : (principal, ByteBuf, principal) -> (Result_2);
  set_user_rights : (principal, ByteBuf, principal, AccessRights) -> (Result_2);
}



================================================
FILE: backend/rs/canisters/ic_vetkeys_manager_canister/Makefile
================================================
ROOT_DIR := $(shell git rev-parse --show-toplevel)

.PHONY: compile-wasm
.SILENT: compile-wasm
compile-wasm:
	cargo build --release --target wasm32-unknown-unknown

.PHONY: extract-candid
.SILENT: extract-candid
extract-candid: compile-wasm
	candid-extractor $(ROOT_DIR)/target/wasm32-unknown-unknown/release/ic_vetkeys_manager_canister.wasm > ic_vetkeys_manager_canister.did




================================================
FILE: backend/rs/canisters/ic_vetkeys_manager_canister/src/lib.rs
================================================
use std::cell::RefCell;

use candid::Principal;
use ic_cdk::management_canister::{VetKDCurve, VetKDKeyId};
use ic_cdk::{init, query, update};
use ic_stable_structures::memory_manager::{MemoryId, MemoryManager, VirtualMemory};
use ic_stable_structures::storable::Blob;
use ic_stable_structures::DefaultMemoryImpl;
use ic_vetkeys::key_manager::{KeyManager, VetKey, VetKeyVerificationKey};
use ic_vetkeys::types::{AccessRights, ByteBuf, TransportKey};

type Memory = VirtualMemory<DefaultMemoryImpl>;

thread_local! {
    static MEMORY_MANAGER: RefCell<MemoryManager<DefaultMemoryImpl>> =
        RefCell::new(MemoryManager::init(DefaultMemoryImpl::default()));
    static KEY_MANAGER: RefCell<Option<KeyManager<AccessRights>>> =
        const { RefCell::new(None) };
}

#[init]
fn init(key_name: String) {
    let key_id = VetKDKeyId {
        curve: VetKDCurve::Bls12_381_G2,
        name: key_name,
    };
    KEY_MANAGER.with_borrow_mut(|km| {
        km.replace(KeyManager::init(
            "key_manager_dapp",
            key_id,
            id_to_memory(0),
            id_to_memory(1),
            id_to_memory(2),
        ))
    });
}

#[query]
fn get_accessible_shared_key_ids() -> Vec<(Principal, ByteBuf)> {
    KEY_MANAGER.with_borrow(|km| {
        km.as_ref()
            .unwrap()
            .get_accessible_shared_key_ids(ic_cdk::api::msg_caller())
            .into_iter()
            .map(|key_id| (key_id.0, ByteBuf::from(key_id.1.as_ref().to_vec())))
            .collect()
    })
}

#[query]
fn get_shared_user_access_for_key(
    key_owner: Principal,
    key_name: ByteBuf,
) -> Result<Vec<(Principal, AccessRights)>, String> {
    let key_name = bytebuf_to_blob(key_name)?;
    let key_id = (key_owner, key_name);
    KEY_MANAGER.with_borrow(|km| {
        km.as_ref()
            .unwrap()
            .get_shared_user_access_for_key(ic_cdk::api::msg_caller(), key_id)
    })
}

#[update]
async fn get_vetkey_verification_key() -> VetKeyVerificationKey {
    KEY_MANAGER
        .with_borrow(|km| km.as_ref().unwrap().get_vetkey_verification_key())
        .await
}

#[update]
async fn get_encrypted_vetkey(
    key_owner: Principal,
    key_name: ByteBuf,
    transport_key: TransportKey,
) -> Result<VetKey, String> {
    let key_name = bytebuf_to_blob(key_name)?;
    let key_id = (key_owner, key_name);
    Ok(KEY_MANAGER
        .with_borrow(|km| {
            km.as_ref().unwrap().get_encrypted_vetkey(
                ic_cdk::api::msg_caller(),
                key_id,
                transport_key,
            )
        })?
        .await)
}

#[query]
fn get_user_rights(
    key_owner: Principal,
    key_name: ByteBuf,
    user: Principal,
) -> Result<Option<AccessRights>, String> {
    let key_name = bytebuf_to_blob(key_name)?;
    let key_id = (key_owner, key_name);
    KEY_MANAGER.with_borrow(|km| {
        km.as_ref()
            .unwrap()
            .get_user_rights(ic_cdk::api::msg_caller(), key_id, user)
    })
}

#[update]
fn set_user_rights(
    key_owner: Principal,
    key_name: ByteBuf,
    user: Principal,
    access_rights: AccessRights,
) -> Result<Option<AccessRights>, String> {
    let key_name = bytebuf_to_blob(key_name)?;
    let key_id = (key_owner, key_name);
    KEY_MANAGER.with_borrow_mut(|km| {
        km.as_mut()
            .unwrap()
            .set_user_rights(ic_cdk::api::msg_caller(), key_id, user, access_rights)
    })
}

#[update]
fn remove_user(
    key_owner: Principal,
    key_name: ByteBuf,
    user: Principal,
) -> Result<Option<AccessRights>, String> {
    let key_name = bytebuf_to_blob(key_name)?;
    let key_id = (key_owner, key_name);
    KEY_MANAGER.with_borrow_mut(|km| {
        km.as_mut()
            .unwrap()
            .remove_user(ic_cdk::api::msg_caller(), key_id, user)
    })
}

fn bytebuf_to_blob(buf: ByteBuf) -> Result<Blob<32>, String> {
    Blob::try_from(buf.as_ref()).map_err(|_| "too large input".to_string())
}

fn id_to_memory(id: u8) -> Memory {
    MEMORY_MANAGER.with(|m| m.borrow().get(MemoryId::new(id)))
}

ic_cdk::export_candid!();



================================================
FILE: backend/rs/canisters/ic_vetkeys_manager_canister/tests/tests.rs
================================================
use assert_matches::assert_matches;
use candid::{decode_one, encode_args, encode_one, CandidType, Principal};
use ic_vetkeys::key_manager::{key_id_to_vetkd_input, VetKey, VetKeyVerificationKey};
use ic_vetkeys::types::{AccessRights, ByteBuf, TransportKey};
use ic_vetkeys::{DerivedPublicKey, EncryptedVetKey, TransportSecretKey};
use ic_vetkeys_test_utils::{git_root_dir, random_self_authenticating_principal, reproducible_rng};
use pocket_ic::{PocketIc, PocketIcBuilder};
use rand::{CryptoRng, Rng};
use std::path::Path;

#[test]
fn should_obtain_verification_key() {
    let rng = &mut reproducible_rng();
    let env = TestEnvironment::new(rng);
    let verification_key: VetKeyVerificationKey = env.update(
        env.principal_0,
        "get_vetkey_verification_key",
        encode_one(()).unwrap(),
    );
    assert_eq!(verification_key.as_ref().len(), 96);
    assert_ne!(verification_key, VetKeyVerificationKey::from(vec![0; 96]));
}

#[test]
fn should_obtain_owned_encrypted_vetkey() {
    let rng = &mut reproducible_rng();
    let env = TestEnvironment::new(rng);
    let key_owner = env.principal_0;
    let key_name = random_key_name(rng);
    let transport_key = random_transport_key(rng);
    let transport_key_bytes = TransportKey::from(transport_key.public_key());
    let encrypted_vetkey = env
        .update::<Result<VetKey, String>>(
            env.principal_0,
            "get_encrypted_vetkey",
            encode_args((key_owner, key_name, transport_key_bytes)).unwrap(),
        )
        .unwrap();

    assert_eq!(encrypted_vetkey.as_ref().len(), 192);
    assert_ne!(encrypted_vetkey, VetKeyVerificationKey::from(vec![0; 192]));
}

#[test]
fn encrypted_vetkey_should_validate() {
    let rng = &mut reproducible_rng();
    let env = TestEnvironment::new(rng);

    let verification_key_bytes: VetKeyVerificationKey = env.update(
        env.principal_0,
        "get_vetkey_verification_key",
        encode_one(()).unwrap(),
    );

    let key_owner = env.principal_0;
    let key_name = random_key_name(rng);
    let transport_key = random_transport_key(rng);
    let transport_key_bytes = TransportKey::from(transport_key.public_key());

    let vetkey = || {
        let encrypted_vetkey = env
            .update::<Result<VetKey, String>>(
                env.principal_0,
                "get_encrypted_vetkey",
                encode_args((key_owner, key_name.clone(), transport_key_bytes.clone())).unwrap(),
            )
            .unwrap();

        let derived_public_key =
            DerivedPublicKey::deserialize(verification_key_bytes.as_ref()).unwrap();
        let encrypted_vetkey = EncryptedVetKey::deserialize(encrypted_vetkey.as_ref()).unwrap();

        encrypted_vetkey
            .decrypt_and_verify(
                &transport_key,
                &derived_public_key,
                &key_id_to_vetkd_input(key_owner, key_name.as_ref()),
            )
            .expect("failed to decrypt and verify `vetkey")
    };

    assert_eq!(vetkey(), vetkey());
}

#[test]
fn key_sharing_should_work() {
    let rng = &mut reproducible_rng();
    let env = TestEnvironment::new(rng);

    let verification_key_bytes: VetKeyVerificationKey = env.update(
        env.principal_0,
        "get_vetkey_verification_key",
        encode_one(()).unwrap(),
    );

    let key_owner = env.principal_0;
    let not_key_owner = env.principal_1;
    let key_name = random_key_name(rng);

    assert_eq!(
        env.query::<Result<Option<AccessRights>, String>>(
            not_key_owner,
            "get_user_rights",
            encode_args((key_owner, key_name.clone(), not_key_owner)).unwrap(),
        ),
        Err("unauthorized".to_string())
    );

    let prev_rights = env
        .update::<Result<Option<AccessRights>, String>>(
            env.principal_0,
            "set_user_rights",
            encode_args((
                key_owner,
                key_name.clone(),
                env.principal_1,
                AccessRights::ReadWriteManage,
            ))
            .unwrap(),
        )
        .unwrap();
    assert_eq!(prev_rights, None);

    let current_rights_owner = env
        .query::<Result<Option<AccessRights>, String>>(
            key_owner,
            "get_user_rights",
            encode_args((key_owner, key_name.clone(), key_owner)).unwrap(),
        )
        .unwrap();
    assert_eq!(current_rights_owner, Some(AccessRights::ReadWriteManage));

    let current_rights_shared = env
        .query::<Result<Option<AccessRights>, String>>(
            not_key_owner,
            "get_user_rights",
            encode_args((key_owner, key_name.clone(), not_key_owner)).unwrap(),
        )
        .unwrap();
    assert_eq!(current_rights_shared, Some(AccessRights::ReadWriteManage));

    let mut get_vetkey = |caller: Principal| -> Vec<u8> {
        let transport_key = random_transport_key(rng);
        let transport_key_bytes = TransportKey::from(transport_key.public_key());
        let encrypted_vetkey = env
            .update::<Result<VetKey, String>>(
                caller,
                "get_encrypted_vetkey",
                encode_args((key_owner, key_name.clone(), transport_key_bytes)).unwrap(),
            )
            .unwrap();

        let derived_public_key =
            DerivedPublicKey::deserialize(verification_key_bytes.as_ref()).unwrap();
        let encrypted_vetkey = EncryptedVetKey::deserialize(encrypted_vetkey.as_ref()).unwrap();

        let vetkey = encrypted_vetkey
            .decrypt_and_verify(
                &transport_key,
                &derived_public_key,
                &key_id_to_vetkd_input(key_owner, key_name.as_ref()),
            )
            .expect("failed to decrypt and verify `vetkey");

        vetkey.signature_bytes().as_ref().to_vec()
    };

    assert_eq!(get_vetkey(env.principal_0), get_vetkey(env.principal_1));
}

#[test]
fn should_get_accessible_shared_key_ids() {
    let rng = &mut reproducible_rng();
    let env = TestEnvironment::new(rng);
    let user_to_be_added = random_self_authenticating_principal(rng);
    let mut map_ids = std::collections::BTreeSet::new();

    for _ in 0..10 {
        let caller = random_self_authenticating_principal(rng);
        let access_rights = random_access_rights(rng);
        let key_name = random_key_name(rng);

        assert_eq!(
            env.update::<Result<Option<AccessRights>, String>>(
                caller,
                "set_user_rights",
                encode_args((caller, key_name.clone(), user_to_be_added, access_rights)).unwrap(),
            ),
            Ok(None)
        );

        map_ids.insert((caller, key_name.clone()));
        let computed_map_ids: std::collections::BTreeSet<_> = env
            .query::<Vec<(Principal, ByteBuf)>>(
                user_to_be_added,
                "get_accessible_shared_key_ids",
                encode_one(()).unwrap(),
            )
            .into_iter()
            .map(|(principal, bytebuf)| (principal, bytebuf))
            .collect();

        assert_eq!(computed_map_ids, map_ids);
    }
}

#[test]
fn should_get_shared_user_access_for_key() {
    let rng = &mut reproducible_rng();
    let env = TestEnvironment::new(rng);
    let caller = random_self_authenticating_principal(rng);
    let key_name = random_key_name(rng);
    let mut shared_access = std::collections::BTreeSet::new();

    for _ in 0..10 {
        let user_to_be_added = random_self_authenticating_principal(rng);
        let access_rights = random_access_rights(rng);

        let computed_shared_access: std::collections::BTreeSet<_> = env
            .query::<Result<Vec<(Principal, AccessRights)>, String>>(
                caller,
                "get_shared_user_access_for_key",
                encode_args((caller, key_name.clone())).unwrap(),
            )
            .unwrap()
            .into_iter()
            .collect();

        assert_eq!(shared_access, computed_shared_access);

        assert_eq!(
            env.update::<Result<Option<AccessRights>, String>>(
                caller,
                "set_user_rights",
                encode_args((caller, key_name.clone(), user_to_be_added, access_rights)).unwrap(),
            ),
            Ok(None)
        );

        shared_access.insert((user_to_be_added, access_rights));
    }
}

#[test]
fn should_fail_get_shared_user_access_for_key_unauthorized() {
    let rng = &mut reproducible_rng();
    let env = TestEnvironment::new(rng);
    let unauthorized = random_self_authenticating_principal(rng);
    let key_owner = random_self_authenticating_principal(rng);
    let key_name = random_key_name(rng);

    assert_eq!(
        env.query::<Result<Vec<(Principal, AccessRights)>, String>>(
            unauthorized,
            "get_shared_user_access_for_key",
            encode_args((key_owner, key_name)).unwrap(),
        ),
        Err("unauthorized".to_string())
    );
}

#[test]
fn should_add_user_to_key() {
    let rng = &mut reproducible_rng();
    let env = TestEnvironment::new(rng);
    let caller = random_self_authenticating_principal(rng);
    let key_name = random_key_name(rng);
    let user_to_be_added = random_self_authenticating_principal(rng);
    let access_rights = random_access_rights(rng);

    // Initially no rights
    assert_eq!(
        env.query::<Result<Option<AccessRights>, String>>(
            caller,
            "get_user_rights",
            encode_args((caller, key_name.clone(), user_to_be_added)).unwrap(),
        ),
        Ok(None)
    );

    // Set user rights
    assert_eq!(
        env.update::<Result<Option<AccessRights>, String>>(
            caller,
            "set_user_rights",
            encode_args((caller, key_name.clone(), user_to_be_added, access_rights)).unwrap(),
        ),
        Ok(None)
    );

    // Check rights after setting
    assert_eq!(
        env.query::<Result<Option<AccessRights>, String>>(
            caller,
            "get_user_rights",
            encode_args((caller, key_name.clone(), user_to_be_added)).unwrap(),
        ),
        Ok(Some(access_rights))
    );

    // Setting same rights again should return previous rights
    assert_eq!(
        env.update::<Result<Option<AccessRights>, String>>(
            caller,
            "set_user_rights",
            encode_args((caller, key_name.clone(), user_to_be_added, access_rights)).unwrap(),
        ),
        Ok(Some(access_rights))
    );
}

#[test]
fn should_fail_get_and_set_user_rights_unauthorized() {
    let rng = &mut reproducible_rng();
    let env = TestEnvironment::new(rng);
    let unauthorized = random_self_authenticating_principal(rng);
    let key_owner = random_self_authenticating_principal(rng);
    let key_name = random_key_name(rng);

    assert_eq!(
        env.query::<Result<Option<AccessRights>, String>>(
            unauthorized,
            "get_user_rights",
            encode_args((key_owner, key_name.clone(), unauthorized)).unwrap(),
        ),
        Err("unauthorized".to_string())
    );

    assert_eq!(
        env.update::<Result<Option<AccessRights>, String>>(
            unauthorized,
            "set_user_rights",
            encode_args((
                key_owner,
                key_name.clone(),
                unauthorized,
                AccessRights::Read
            ))
            .unwrap(),
        ),
        Err("unauthorized".to_string())
    );
}

#[test]
fn should_not_alter_owner_rights() {
    let rng = &mut reproducible_rng();
    let env = TestEnvironment::new(rng);
    let caller = random_self_authenticating_principal(rng);
    let key_name = random_key_name(rng);

    assert_eq!(
        env.update::<Result<Option<AccessRights>, String>>(
            caller,
            "set_user_rights",
            encode_args((caller, key_name.clone(), caller, AccessRights::Read)).unwrap(),
        )
        .map_err(|s| s.to_ascii_lowercase()),
        Err("cannot change key owner's user rights".to_string())
    );

    assert_eq!(
        env.update::<Result<Option<AccessRights>, String>>(
            caller,
            "remove_user",
            encode_args((caller, key_name.clone(), caller)).unwrap(),
        )
        .map_err(|s| s.to_ascii_lowercase()),
        Err("cannot remove key owner".to_string())
    );
}

#[test]
fn should_allow_other_user_to_manage_key() {
    let rng = &mut reproducible_rng();
    let env = TestEnvironment::new(rng);
    let owner = random_self_authenticating_principal(rng);
    let user1 = random_self_authenticating_principal(rng);
    let user2 = random_self_authenticating_principal(rng);
    let key_name = random_key_name(rng);

    // Owner gives manage rights to users
    env.update::<Result<Option<AccessRights>, String>>(
        owner,
        "set_user_rights",
        encode_args((
            owner,
            key_name.clone(),
            user1,
            AccessRights::ReadWriteManage,
        ))
        .unwrap(),
    )
    .unwrap();

    env.update::<Result<Option<AccessRights>, String>>(
        owner,
        "set_user_rights",
        encode_args((
            owner,
            key_name.clone(),
            user2,
            AccessRights::ReadWriteManage,
        ))
        .unwrap(),
    )
    .unwrap();

    // User2 can remove user1
    env.update::<Result<Option<AccessRights>, String>>(
        user2,
        "remove_user",
        encode_args((owner, key_name.clone(), user1)).unwrap(),
    )
    .unwrap();

    // User2 can remove themselves
    env.update::<Result<Option<AccessRights>, String>>(
        user2,
        "remove_user",
        encode_args((owner, key_name.clone(), user2)).unwrap(),
    )
    .unwrap();
}

#[test]
fn should_remove_user_from_key() {
    let rng = &mut reproducible_rng();
    let env = TestEnvironment::new(rng);
    let caller = random_self_authenticating_principal(rng);
    let key_name = random_key_name(rng);
    let user_to_be_added = random_self_authenticating_principal(rng);
    let access_rights = random_access_rights(rng);

    // Add user
    assert_eq!(
        env.update::<Result<Option<AccessRights>, String>>(
            caller,
            "set_user_rights",
            encode_args((caller, key_name.clone(), user_to_be_added, access_rights)).unwrap(),
        ),
        Ok(None)
    );

    // Remove user
    assert_eq!(
        env.update::<Result<Option<AccessRights>, String>>(
            caller,
            "remove_user",
            encode_args((caller, key_name.clone(), user_to_be_added)).unwrap(),
        ),
        Ok(Some(access_rights))
    );

    // Verify user is removed
    assert_eq!(
        env.query::<Result<Option<AccessRights>, String>>(
            caller,
            "get_user_rights",
            encode_args((caller, key_name.clone(), user_to_be_added)).unwrap(),
        ),
        Ok(None)
    );
}

#[test]
fn should_fail_add_or_remove_user_by_unauthorized() {
    let rng = &mut reproducible_rng();
    let env = TestEnvironment::new(rng);
    let caller = random_self_authenticating_principal(rng);
    let key_name = random_key_name(rng);
    let mut unauthorized_callers = vec![random_self_authenticating_principal(rng)];

    for access_rights in [AccessRights::Read, AccessRights::ReadWrite] {
        let user_to_be_added = random_self_authenticating_principal(rng);

        assert_matches!(
            env.update::<Result<Option<AccessRights>, String>>(
                caller,
                "set_user_rights",
                encode_args((caller, key_name.clone(), user_to_be_added, access_rights)).unwrap(),
            ),
            Ok(_)
        );

        unauthorized_callers.push(user_to_be_added);
    }

    for unauthorized_caller in unauthorized_callers {
        for target in [random_self_authenticating_principal(rng), caller] {
            assert_eq!(
                env.update::<Result<Option<AccessRights>, String>>(
                    unauthorized_caller,
                    "remove_user",
                    encode_args((caller, key_name.clone(), target)).unwrap(),
                ),
                Err("unauthorized".to_string())
            );
            assert_eq!(
                env.update::<Result<Option<AccessRights>, String>>(
                    unauthorized_caller,
                    "set_user_rights",
                    encode_args((caller, key_name.clone(), target, AccessRights::Read)).unwrap(),
                ),
                Err("unauthorized".to_string())
            );
        }
    }
}

struct TestEnvironment {
    pic: PocketIc,
    example_canister_id: Principal,
    principal_0: Principal,
    principal_1: Principal,
}

impl TestEnvironment {
    fn new<R: Rng + CryptoRng>(rng: &mut R) -> Self {
        let pic = PocketIcBuilder::new()
            .with_application_subnet()
            .with_ii_subnet()
            .with_fiduciary_subnet()
            .with_nonmainnet_features(true)
            .build();

        let example_canister_id = pic.create_canister();
        pic.add_cycles(example_canister_id, 2_000_000_000_000);

        let example_wasm_bytes = load_key_manager_example_canister_wasm();
        pic.install_canister(
            example_canister_id,
            example_wasm_bytes,
            encode_one("dfx_test_key").unwrap(),
            None,
        );

        // Make sure the canister is properly initialized
        fast_forward(&pic, 5);

        Self {
            pic,
            example_canister_id,
            principal_0: random_self_authenticating_principal(rng),
            principal_1: random_self_authenticating_principal(rng),
        }
    }

    fn update<T: CandidType + for<'de> candid::Deserialize<'de>>(
        &self,
        caller: Principal,
        method_name: &str,
        args: Vec<u8>,
    ) -> T {
        let reply = self
            .pic
            .update_call(self.example_canister_id, caller, method_name, args);
        match reply {
            Ok(data) => decode_one(&data).expect("failed to decode reply"),
            Err(user_error) => panic!("canister returned a user error: {user_error}"),
        }
    }

    fn query<T: CandidType + for<'de> candid::Deserialize<'de>>(
        &self,
        caller: Principal,
        method_name: &str,
        args: Vec<u8>,
    ) -> T {
        let reply = self
            .pic
            .query_call(self.example_canister_id, caller, method_name, args);
        match reply {
            Ok(data) => decode_one(&data).expect("failed to decode reply"),
            Err(user_error) => panic!("canister returned a user error: {user_error}"),
        }
    }
}

fn load_key_manager_example_canister_wasm() -> Vec<u8> {
    let wasm_path_string = match std::env::var("CUSTOM_WASM_PATH") {
        Ok(path) if !path.is_empty() => path,
        _ => format!(
            "{}/target/wasm32-unknown-unknown/release/ic_vetkeys_manager_canister.wasm",
            git_root_dir()
        ),
    };
    let wasm_path = Path::new(&wasm_path_string);
    std::fs::read(wasm_path)
        .expect("wasm does not exist - run `cargo build --release --target wasm32-unknown-unknown`")
}

fn random_transport_key<R: Rng + CryptoRng>(rng: &mut R) -> TransportSecretKey {
    let mut seed = vec![0u8; 32];
    rng.fill_bytes(&mut seed);
    TransportSecretKey::from_seed(seed).unwrap()
}

fn fast_forward(ic: &PocketIc, ticks: u64) {
    for _ in 0..ticks - 1 {
        ic.tick();
    }
}

fn random_key_name<R: Rng + CryptoRng>(rng: &mut R) -> ByteBuf {
    let length = rng.gen_range(0..32);
    let mut key_name = vec![0u8; length];
    rng.fill_bytes(&mut key_name);
    ByteBuf::from(key_name)
}

fn random_access_rights<R: Rng + CryptoRng>(rng: &mut R) -> AccessRights {
    loop {
        if let Some(ar) = AccessRights::from_repr(rng.gen()) {
            return ar;
        }
    }
}



================================================
FILE: backend/rs/canisters/tests/README.md
================================================
# Canister tests

Currently, we test:
* `ic_vetkeys::management_canister::sign_with_bls`
* `ic_vetkeys::management_canister::bls_public_key`


================================================
FILE: backend/rs/canisters/tests/Cargo.toml
================================================
[package]
name = "ic-vetkeys-canisters-tests"
authors.workspace = true
description.workspace = true
documentation.workspace = true
edition.workspace = true
version.workspace = true
license.workspace = true

[lib]
path = "src/lib.rs"
crate-type = ["cdylib"]

[dependencies]
candid = { workspace = true }
ic-cdk = { workspace = true }
ic-cdk-macros = { workspace = true }
ic-dummy-getrandom-for-wasm = { workspace = true }
ic-vetkeys = { path = "../../ic_vetkeys" }
serde = { workspace = true }

[dev-dependencies]
ic-vetkeys-test-utils = { path = "../../ic_vetkeys_test_utils" }
pocket-ic = { workspace = true }
rand = { workspace = true }


================================================
FILE: backend/rs/canisters/tests/Makefile
================================================
.PHONY: build
.SILENT: build
build:
	cargo build --release --target wasm32-unknown-unknown

.PHONY: test
.SILENT: test
test: build
	cargo test



================================================
FILE: backend/rs/canisters/tests/src/lib.rs
================================================
use ic_cdk::{
    management_canister::{VetKDDeriveKeyArgs, VetKDKeyId, VetKDPublicKeyArgs},
    update,
};

#[update]
async fn sign_with_bls(input: Vec<u8>, context: Vec<u8>, key_id: VetKDKeyId) -> Vec<u8> {
    ic_vetkeys::management_canister::sign_with_bls(input, context, key_id)
        .await
        .expect("sign_with_bls call failed")
}

#[update]
async fn bls_public_key(context: Vec<u8>, key_id: VetKDKeyId) -> Vec<u8> {
    ic_vetkeys::management_canister::bls_public_key(None, context, key_id)
        .await
        .expect("bls_public_key call failed")
}

#[update]
async fn vetkd_derive_key(
    input: Vec<u8>,
    context: Vec<u8>,
    key_id: VetKDKeyId,
    transport_public_key: Vec<u8>,
) -> Vec<u8> {
    let request = VetKDDeriveKeyArgs {
        input,
        context,
        key_id,
        transport_public_key,
    };

    let reply = ic_cdk::management_canister::vetkd_derive_key(&request)
        .await
        .expect("vetkd_derive_key call failed");

    reply.encrypted_key
}

#[update]
async fn vetkd_public_key(context: Vec<u8>, key_id: VetKDKeyId) -> Vec<u8> {
    let request = VetKDPublicKeyArgs {
        canister_id: None,
        context,
        key_id,
    };

    let reply = ic_cdk::management_canister::vetkd_public_key(&request)
        .await
        .expect("vetkd_public_key call failed");

    reply.public_key
}



================================================
FILE: backend/rs/canisters/tests/tests/sign_with_bls.rs
================================================
use candid::{decode_one, encode_args, CandidType, Principal};
use ic_cdk::management_canister::{VetKDCurve, VetKDKeyId};
use ic_vetkeys::{verify_bls_signature, DerivedPublicKey, EncryptedVetKey, TransportSecretKey};
use ic_vetkeys_test_utils::{git_root_dir, reproducible_rng};
use pocket_ic::{PocketIc, PocketIcBuilder};
use rand::{CryptoRng, Rng};
use std::path::Path;

#[test]
fn bls_signature_should_be_valid_and_equal_to_decrypted_vetkey() {
    let rng = &mut reproducible_rng();
    let env = TestEnvironment::new();
    let input = random_bytes(rng, 10);
    let context = random_bytes(rng, 10);
    let key_id = VetKDKeyId {
        curve: VetKDCurve::Bls12_381_G2,
        name: "dfx_test_key".to_string(),
    };
    let transport_secret_key = random_transport_key(rng);
    let transport_public_key = transport_secret_key.public_key();

    let bls_signature: Vec<u8> = env.update(
        Principal::anonymous(),
        "sign_with_bls",
        encode_args((input.clone(), context.clone(), key_id.clone())).unwrap(),
    );

    let verification_key: Vec<u8> = env.update(
        Principal::anonymous(),
        "vetkd_public_key",
        encode_args((context.clone(), key_id.clone())).unwrap(),
    );
    let encrypted_vetkey_bytes: Vec<u8> = env.update(
        Principal::anonymous(),
        "vetkd_derive_key",
        encode_args((input.clone(), context, key_id, transport_public_key)).unwrap(),
    );
    let encrypted_vetkey = EncryptedVetKey::deserialize(encrypted_vetkey_bytes.as_ref()).unwrap();
    let derived_public_key = DerivedPublicKey::deserialize(verification_key.as_ref()).unwrap();
    let decrypted_vetkey = encrypted_vetkey
        .decrypt_and_verify(&transport_secret_key, &derived_public_key, &input)
        .unwrap();

    assert_eq!(bls_signature, decrypted_vetkey.signature_bytes().to_vec());
    assert!(verify_bls_signature(
        &derived_public_key,
        &input,
        &bls_signature
    ));
}

#[test]
fn bls_public_key_should_be_equal_to_verification_key() {
    let rng = &mut reproducible_rng();
    let env = TestEnvironment::new();
    let context = random_bytes(rng, 10);
    let key_id = VetKDKeyId {
        curve: VetKDCurve::Bls12_381_G2,
        name: "dfx_test_key".to_string(),
    };
    let bls_public_key: Vec<u8> = env.update(
        Principal::anonymous(),
        "bls_public_key",
        encode_args((context.clone(), key_id.clone())).unwrap(),
    );
    let verification_key: Vec<u8> = env.update(
        Principal::anonymous(),
        "vetkd_public_key",
        encode_args((context.clone(), key_id.clone())).unwrap(),
    );
    assert_eq!(bls_public_key, verification_key);
}
struct TestEnvironment {
    pic: PocketIc,
    canister_id: Principal,
}

impl TestEnvironment {
    fn new() -> Self {
        let pic = PocketIcBuilder::new()
            .with_application_subnet()
            .with_ii_subnet()
            .with_fiduciary_subnet()
            .with_nonmainnet_features(true)
            .build();

        let canister_id = pic.create_canister();
        pic.add_cycles(canister_id, 2_000_000_000_000);

        let wasm_bytes = load_canister_wasm();
        pic.install_canister(canister_id, wasm_bytes, vec![], None);

        // Make sure the canister is properly initialized
        fast_forward(&pic, 5);

        Self { pic, canister_id }
    }

    fn update<T: CandidType + for<'de> candid::Deserialize<'de>>(
        &self,
        caller: Principal,
        method_name: &str,
        args: Vec<u8>,
    ) -> T {
        let reply = self
            .pic
            .update_call(self.canister_id, caller, method_name, args);
        match reply {
            Ok(data) => decode_one(&data).expect("failed to decode reply"),
            Err(user_error) => panic!("canister returned a user error: {user_error}"),
        }
    }
}

fn load_canister_wasm() -> Vec<u8> {
    let wasm_path_string = match std::env::var("CUSTOM_WASM_PATH") {
        Ok(path) if !path.is_empty() => path,
        _ => format!(
            "{}/target/wasm32-unknown-unknown/release/ic_vetkeys_canisters_tests.wasm",
            git_root_dir()
        ),
    };
    let wasm_path = Path::new(&wasm_path_string);
    std::fs::read(wasm_path)
        .expect("wasm does not exist - run `cargo build --release --target wasm32-unknown-unknown`")
}

fn random_transport_key<R: Rng + CryptoRng>(rng: &mut R) -> TransportSecretKey {
    let mut seed = vec![0u8; 32];
    rng.fill_bytes(&mut seed);
    TransportSecretKey::from_seed(seed).unwrap()
}

fn random_bytes<R: Rng + CryptoRng>(rng: &mut R, max_length: usize) -> Vec<u8> {
    let length = rng.gen_range(0..max_length);
    let mut bytes = vec![0u8; length];
    rng.fill_bytes(&mut bytes);
    bytes
}

fn fast_forward(ic: &PocketIc, ticks: u64) {
    for _ in 0..ticks - 1 {
        ic.tick();
    }
}



================================================
FILE: backend/rs/ic_vetkeys/README.md
================================================
# Internet Computer (IC) vetKeys

This crate contains a set of tools designed to help canister developers integrate **vetKeys** into their Internet Computer (ICP) applications.

The current Minimum Supported Rust Version (MSRV) of this crate is 1.85. Any future increase in the MSRV will be accompanied by a bump in the minor version number.

## [Key Manager](https://docs.rs/ic-vetkeys/latest/ic_vetkeys/key_manager/struct.KeyManager.html)
A canister library for derivation of encrypted vetkeys from arbitrary strings. It can be used in combination with the [frontend key manager library](https://dfinity.github.io/vetkeys/classes/_dfinity_vetkeys_key_manager.KeyManager.html).

## [Encrypted Maps](https://docs.rs/ic-vetkeys/latest/ic_vetkeys/encrypted_maps/struct.EncryptedMaps.html)
An efficient canister library facilitating access control and encrypted storage for a collection of maps contatining key-value pairs. It can be used in combination with the [frontend encrypted maps library](https://dfinity.github.io/vetkeys/classes/_dfinity_vetkeys_encrypted_maps.EncryptedMaps.html).

## [Utils](https://docs.rs/ic-vetkeys/latest/)
For obtaining and decrypting verifiably-encrypted threshold keys via the Internet Computer vetKD system API. The API is located in the crate root.

## Cross-language library
If Motoko better suits your needs, take a look at the [Motoko equivalent of this library](https://mops.one/ic-vetkeys).



================================================
FILE: backend/rs/ic_vetkeys/Cargo.toml
================================================
[package]
name = "ic-vetkeys"
version = "0.5.0"
authors.workspace = true
edition.workspace = true
license.workspace = true
repository.workspace = true
rust-version.workspace = true
documentation = "https://docs.rs/ic-vetkeys"
homepage = "https://github.com/dfinity/vetkeys/tree/main/backend/rs/ic_vetkeys"
categories = [
    "api-bindings",
    "authentication",
    "cryptography",
    "cryptography::cryptocurrencies",
    "data-structures"
]
keywords = ["internet-computer", "ibe", "bls-signatures", "distributed-keys", "encrypted-storage"]
include = ["src", "Cargo.toml", "LICENSE", "README.md"]
description = "A set of tools designed to help canister developers integrate vetKeys into their Internet Computer (ICP) applications"
readme = "README.md"

[lib]
crate-type = ["lib"]

[dependencies]
aes-gcm = "0.10"
anyhow = { workspace = true }
candid = { workspace = true }
ic_bls12_381 = { version = "0.10.1", default-features = false, features = [
    "groups",
    "pairings",
    "alloc",
    "experimental",
    "zeroize",
] }
hkdf = { version = "0.12" }
futures = "0.3.31"
hex-literal = { version = "1" }
ic-cdk = { workspace = true }
ic-cdk-macros = { workspace = true }
ic-stable-structures = { workspace = true }
lazy_static = { workspace = true }
pairing = "0.23.0"
rand = { workspace = true }
rand_chacha = { workspace = true }
serde = { workspace = true }
serde_bytes = { workspace = true }
serde_cbor = { workspace = true }
sha2 = "0.10.9"
sha3 = "0.10.8"
subtle = "2.6.1"
strum = "0.27.1"
strum_macros = "0.27.1"
zeroize = { version = "1.8.1", features = ["zeroize_derive"] }

[dev-dependencies]
assert_matches = "1.5.0"
hex = { workspace = true }
ic-vetkeys-test-utils = { path = "../ic_vetkeys_test_utils" }
pocket-ic = { workspace = true }



================================================
FILE: backend/rs/ic_vetkeys/CHANGELOG.md
================================================
# Change Log

## [0.6.0] - Not Yet Released

### Changed

- Changes to format of the AES-GCM encryption helpers added in 0.5.0. This version can decrypt messages encrypted by 0.5.0, but 0.5.0 cannot decrypt messages encrypted by 0.6.0

## [0.5.0] - 2025-09-08

### Added

- Add AES-GCM encryption helpers ([#220](https://github.com/dfinity/vetkeys/pull/220)). The helpers are available in a `DerivedKeyMaterial` struct, which can be created using `VetKey::as_derived_key_material`. Encryption/decryption is done with `DerivedKeyMaterial::encrypt_message` and `DerivedKeyMaterial::decrypt_message`.

### Changed

- Use optimized G2 generator point multiplication ([#219](https://github.com/dfinity/vetkeys/pull/219)). This improves the performance of public key derivation (`MasterPublicKey::derive_canister_key` and `DerivedPublicKey::derive_sub_key`) and IBE encryption/decryption (`IbeCiphertext::encrypt` and `IbeCiphertext::decrypt`).

### Fixed

- Removes the modified appendix from the LICENSE file to ensure full compliance with the Apache 2.0 license, which should remain in its original, unmodified form ([#225](https://github.com/dfinity/vetkeys/pull/225)).

## [0.4.0] - 2025-08-05

### Breaking changes

- Bumped `ic-stable-structures` to `v0.7.0`.

### Added

- Added MasterPublicKey::for_mainnet_key which allows accessing the production public keys

- Added IbeCiphertext plaintext_size and ciphertext_size helpers

- Add VrfOutput type for using VetKeys as a Verifiable Random Function

- `derive(Deserialize)` for `EncryptedMapData`

### Changed

- Set MSRV to 1.85

## [0.3.0] - 2025-06-30

### Added

- An additional sanity check that the public key is not the identity.

### Changed

- Improved docs.

- Added zeroization of the used memory.

- Updated dependencies.

## [0.2.0] - 2025-06-08

### Breaking Changes

- Changed error types of `crate::management_canister::{bls_public_key, sign_with_bls}`.

### Fixed

- Links in code docs.

### Changed

- Bumped `ic_cdk` to `v0.18.3`. Due to this update, the internally dispatched `vetkd_derive_key` calls now attach exactly the needed the amount of cycles (and not sometimes more cycles as it was the case before) because the new version of `ic_cdk` determines the cost by using the `ic0_cost_vetkd_derive_key` endpoint.

## [0.1.0] - 2025-05-27

Initial release



================================================
SYMLINK: backend/rs/ic_vetkeys/LICENSE -> LICENSE
================================================



================================================
FILE: backend/rs/ic_vetkeys/src/lib.rs
================================================
#![doc = include_str!("../README.md")]
#![warn(future_incompatible)]

pub mod encrypted_maps;
pub mod key_manager;
pub mod types;

mod utils;
pub use utils::*;



================================================
FILE: backend/rs/ic_vetkeys/src/types.rs
================================================
use std::{borrow::Cow, convert::TryInto};

use candid::{CandidType, Decode, Encode};
use ic_stable_structures::{
    storable::{Blob, Bound},
    Storable,
};
use serde::{Deserialize, Serialize};

pub type CanisterId = candid::Principal;

pub type KeyName = Blob<32>;
pub type MapName = KeyName;
pub type MapId = KeyId;
pub type KeyId = (candid::Principal, KeyName);
pub type MapKey = Blob<32>;
pub type TransportKey = ByteBuf;
pub type EncryptedMapValue = ByteBuf;

#[derive(Serialize, Deserialize)]
pub struct KeyManagerConfig {
    pub domain_separator: String,
    pub key_id: ic_cdk::management_canister::VetKDKeyId,
}

impl Storable for KeyManagerConfig {
    fn into_bytes(self) -> Vec<u8> {
        self.to_bytes().into_owned()
    }

    fn to_bytes(&self) -> Cow<'_, [u8]> {
        Cow::Owned(serde_cbor::to_vec(self).unwrap())
    }

    fn from_bytes(bytes: Cow<[u8]>) -> Self {
        serde_cbor::from_slice(bytes.as_ref()).unwrap()
    }

    const BOUND: Bound = Bound::Unbounded;
}

/// Access rights of a user to a vetKey in [`crate::key_manager::KeyManager`] and/or an encrypted map in [`crate::encrypted_maps::EncryptedMaps`].
#[repr(u8)]
#[derive(
    CandidType,
    Serialize,
    Deserialize,
    Clone,
    Copy,
    PartialEq,
    Eq,
    PartialOrd,
    Ord,
    Debug,
    strum_macros::FromRepr,
    strum_macros::EnumIter,
)]
pub enum AccessRights {
    /// User can retrieve the vetKey or encrypted map.
    Read = 0,
    /// User can update values in the encrypted map.
    ReadWrite = 1,
    /// User can view/share/revoke access to the vetKey or encrypted map.
    ReadWriteManage = 2,
}

impl Storable for AccessRights {
    fn into_bytes(self) -> Vec<u8> {
        self.to_bytes().into_owned()
    }

    fn to_bytes(&self) -> Cow<'_, [u8]> {
        Cow::Owned(vec![*self as u8])
    }

    fn from_bytes(bytes: Cow<[u8]>) -> Self {
        let v = <u8>::from_be_bytes(bytes.as_ref().try_into().unwrap());
        Self::from_repr(v).unwrap()
    }

    const BOUND: Bound = Bound::Bounded {
        max_size: 1,
        is_fixed_size: true,
    };
}

impl AccessControl for AccessRights {
    fn can_read(&self) -> bool {
        matches!(
            self,
            AccessRights::Read | AccessRights::ReadWrite | AccessRights::ReadWriteManage
        )
    }

    fn can_write(&self) -> bool {
        matches!(
            self,
            AccessRights::ReadWrite | AccessRights::ReadWriteManage
        )
    }

    fn can_get_user_rights(&self) -> bool {
        matches!(self, AccessRights::ReadWriteManage)
    }

    fn can_set_user_rights(&self) -> bool {
        matches!(self, AccessRights::ReadWriteManage)
    }

    fn owner_rights() -> Self {
        AccessRights::ReadWriteManage
    }
}

pub trait AccessControl:
    CandidType
    + Serialize
    + Clone
    + Copy
    + PartialEq
    + Eq
    + PartialOrd
    + Ord
    + std::fmt::Debug
    + strum::IntoEnumIterator
    + Storable
{
    /// Returns if the user can read the vetKey or encrypted map.
    fn can_read(&self) -> bool;
    /// Returns if the user can write to the vetKey or encrypted map.
    fn can_write(&self) -> bool;
    /// Returns if the user can view the access rights to the vetKey or encrypted map.
    fn can_get_user_rights(&self) -> bool;
    /// Returns if the user can modify the access rights to the vetKey or encrypted map.
    fn can_set_user_rights(&self) -> bool;
    /// Returns the access rights of the owner of the vetKey or encrypted map.
    fn owner_rights() -> Self;
}

/// Efficiently serializable and deserializable byte vector that is `Storable` with `ic_stable_structures`.
/// See, e.g., [https://mmapped.blog/posts/01-effective-rust-canisters#serde-bytes](https://mmapped.blog/posts/01-effective-rust-canisters#serde-bytes) for more details regarding why `Vec<u8>` does not work out of the box.
/// Also, we cannot use `serde_bytes::ByteBuf` directly because it is not `Storable`.
#[derive(CandidType, Serialize, Deserialize, PartialEq, Eq, PartialOrd, Ord, Clone, Debug)]
pub struct ByteBuf {
    #[serde(with = "serde_bytes")]
    inner: Vec<u8>,
}

impl ByteBuf {
    pub fn new() -> Self {
        Self { inner: Vec::new() }
    }
}

impl From<Vec<u8>> for ByteBuf {
    fn from(inner: Vec<u8>) -> Self {
        Self { inner }
    }
}

impl From<ByteBuf> for Vec<u8> {
    fn from(buf: ByteBuf) -> Self {
        buf.inner
    }
}

impl AsRef<[u8]> for ByteBuf {
    fn as_ref(&self) -> &[u8] {
        &self.inner
    }
}

impl Default for ByteBuf {
    fn default() -> Self {
        Self::new()
    }
}

impl Storable for ByteBuf {
    fn into_bytes(self) -> Vec<u8> {
        self.to_bytes().into_owned()
    }

    fn to_bytes(&self) -> Cow<'_, [u8]> {
        Cow::Owned(Encode!(self).unwrap())
    }

    fn from_bytes(bytes: Cow<[u8]>) -> Self {
        Decode!(bytes.as_ref(), Self).unwrap()
    }
    const BOUND: Bound = Bound::Unbounded;
}



================================================
FILE: backend/rs/ic_vetkeys/src/encrypted_maps/mod.rs
================================================
//! See [`EncryptedMaps`] for the main documentation.

use candid::Principal;
use ic_stable_structures::memory_manager::VirtualMemory;
use ic_stable_structures::storable::Blob;
use ic_stable_structures::{DefaultMemoryImpl, StableBTreeMap};
use serde::Deserialize;
use std::future::Future;

use crate::key_manager::KeyId;
use crate::types::{
    AccessControl, ByteBuf, EncryptedMapValue, MapId, MapKey, MapName, TransportKey,
};
use ic_cdk::management_canister::VetKDKeyId;

pub type VetKeyVerificationKey = ByteBuf;
pub type VetKey = ByteBuf;

type Memory = VirtualMemory<DefaultMemoryImpl>;

/// The **EncryptedMaps** backend is a support library built on top of [`crate::key_manager::KeyManager`].
///
/// **EncryptedMaps** is designed to facilitate secure, encrypted data sharing between users on the Internet Computer (ICP) using the **vetKeys** feature. It allows developers to store encrypted key-value pairs (**maps**) securely and to manage fine-grained user access.
///
/// For an introduction to **vetKeys**, refer to the [vetKeys Overview](https://internetcomputer.org/docs/building-apps/network-features/vetkeys/introduction).
///
/// ## Core Features
///
/// The **EncryptedMaps** library provides the following key functionalities:
///
/// - **Encrypted Key-Value Storage:** Securely store and manage encrypted key-value pairs within named maps.
/// - **User-Specific Map Access:** Control precisely which users can read or modify entries in an encrypted map.
/// - **Integrated Access Control:** Leverages the **KeyManager** library to manage and enforce user permissions.
/// - **Stable Storage:** Utilizes **[StableBTreeMap](https://crates.io/crates/ic-stable-structures)** for reliable, persistent storage across canister upgrades.
///
/// ## EncryptedMaps Architecture
///
/// The **EncryptedMaps** library contains:
///
/// - **Encrypted Values Storage:** Maps `(KeyId, MapKey)` to `EncryptedMapValue`, securely storing encrypted data.
/// - **KeyManager Integration:** Uses **KeyManager** to handle user permissions, ensuring authorized access to maps.
///
/// ## Example Use Case
///
/// 1. **User A** initializes an encrypted map and adds values.
/// 2. **User A** shares access to this map with **User B**.
/// 3. **User B** retrieves encrypted values securely.
/// 4. **User A** revokes **User B**'s access as necessary.
///
/// ## Security Considerations
///
/// - Encrypted values are stored securely with fine-grained access control.
/// - Access rights and permissions are strictly enforced.
/// - Data persists securely across canister upgrades through stable storage.
///
/// ## Summary
/// **EncryptedMaps** simplifies secure storage, retrieval, and controlled sharing of encrypted data on the Internet Computer, complementing the robust security and permissions management provided by **KeyManager**.
pub struct EncryptedMaps<T: AccessControl> {
    pub key_manager: crate::key_manager::KeyManager<T>,
    pub mapkey_vals: StableBTreeMap<(KeyId, MapKey), EncryptedMapValue, Memory>,
}

impl<T: AccessControl> EncryptedMaps<T> {
    /// Initializes the [`EncryptedMaps`] and the underlying [`crate::key_manager::KeyManager`].
    ///
    /// # Example
    ///
    /// ```rust
    /// use ic_cdk::init;
    /// use ic_cdk::management_canister::{VetKDCurve, VetKDKeyId};
    /// use ic_stable_structures::{
    ///     memory_manager::{MemoryId, MemoryManager, VirtualMemory},
    ///     DefaultMemoryImpl,
    /// };
    /// use std::cell::RefCell;
    /// use ic_vetkeys::types::AccessRights;
    /// use ic_vetkeys::encrypted_maps::EncryptedMaps;
    ///
    /// type Memory = VirtualMemory<DefaultMemoryImpl>;
    ///
    /// thread_local! {
    ///     static MEMORY_MANAGER: RefCell<MemoryManager<DefaultMemoryImpl>> =
    ///         RefCell::new(MemoryManager::init(DefaultMemoryImpl::default()));
    ///     static ENCRYPTED_MAPS: RefCell<Option<EncryptedMaps<AccessRights>>> = const { RefCell::new(None) };
    /// }
    ///
    /// #[init]
    /// fn init(key_name: String) {
    ///     let key_id = VetKDKeyId {
    ///         curve: VetKDCurve::Bls12_381_G2,
    ///         name: key_name,
    ///     };
    ///     ENCRYPTED_MAPS.with_borrow_mut(|encrypted_maps| {
    ///         encrypted_maps.replace(EncryptedMaps::init(
    ///         "my encrypted maps dapp",
    ///         key_id,
    ///         id_to_memory(0),
    ///         id_to_memory(1),
    ///         id_to_memory(2),
    ///         id_to_memory(3),
    ///         ));
    ///     });
    /// }
    ///
    /// fn id_to_memory(id: u8) -> Memory {
    ///     MEMORY_MANAGER.with(|m| m.borrow().get(MemoryId::new(id)))
    /// }
    /// ```
    pub fn init(
        domain_separator: &str,
        key_id: VetKDKeyId,
        memory_domain_separator: Memory,
        memory_access_control: Memory,
        memory_shared_keys: Memory,
        memory_encrypted_maps: Memory,
    ) -> Self {
        let key_manager = crate::key_manager::KeyManager::init(
            domain_separator,
            key_id,
            memory_domain_separator,
            memory_access_control,
            memory_shared_keys,
        );

        let mapkey_vals = StableBTreeMap::init(memory_encrypted_maps);

        Self {
            key_manager,
            mapkey_vals,
        }
    }

    /// Lists all map names shared with the caller.
    /// Returns a vector of map IDs that the caller has access to.
    pub fn get_accessible_shared_map_names(&self, caller: Principal) -> Vec<KeyId> {
        self.key_manager.get_accessible_shared_key_ids(caller)
    }

    /// Retrieves all users and their access rights for a specific map.
    /// The caller must have appropriate permissions to view this information.
    pub fn get_shared_user_access_for_map(
        &self,
        caller: Principal,
        key_id: KeyId,
    ) -> Result<Vec<(Principal, T)>, String> {
        self.key_manager
            .get_shared_user_access_for_key(caller, key_id)
    }

    /// Removes all values from a map if the caller has sufficient rights.
    /// Returns the removed keys.
    /// The caller must have write permissions to perform this operation.
    pub fn remove_map_values(
        &mut self,
        caller: Principal,
        key_id: KeyId,
    ) -> Result<Vec<MapKey>, String> {
        self.key_manager.ensure_user_can_write(caller, key_id)?;

        let keys: Vec<_> = self
            .mapkey_vals
            .range((key_id, Blob::default())..)
            .take_while(|entry| entry.key().0 == key_id)
            .map(|entry| entry.key().1)
            .collect();

        for key in keys.iter() {
            self.mapkey_vals.remove(&(key_id, *key));
        }

        Ok(keys)
    }

    /// Retrieves all encrypted key-value pairs from a map.
    /// The caller must have read permissions to access the map values.
    pub fn get_encrypted_values_for_map(
        &self,
        caller: Principal,
        key_id: KeyId,
    ) -> Result<Vec<(MapKey, EncryptedMapValue)>, String> {
        self.key_manager.ensure_user_can_read(caller, key_id)?;

        Ok(self
            .mapkey_vals
            .range((key_id, Blob::default())..)
            .take_while(|entry| entry.key().0 == key_id)
            .map(|entry| (entry.key().1, entry.value()))
            .collect())
    }

    /// Retrieves a specific encrypted value from a map.
    /// The caller must have read permissions to access the value.
    pub fn get_encrypted_value(
        &self,
        caller: Principal,
        key_id: KeyId,
        key: MapKey,
    ) -> Result<Option<EncryptedMapValue>, String> {
        self.key_manager.ensure_user_can_read(caller, key_id)?;
        Ok(self.mapkey_vals.get(&(key_id, key)))
    }

    /// Retrieves the non-empty map names owned by the caller.
    pub fn get_all_accessible_encrypted_values(
        &self,
        caller: Principal,
    ) -> Vec<(MapId, Vec<(MapKey, EncryptedMapValue)>)> {
        let mut result = Vec::new();
        for map_id in self.get_accessible_map_ids_iter(caller) {
            let map_values = self.get_encrypted_values_for_map(caller, map_id).unwrap();
            result.push((map_id, map_values));
        }
        result
    }

    /// Retrieves all accessible encrypted maps and their data for the caller.
    pub fn get_all_accessible_encrypted_maps(&self, caller: Principal) -> Vec<EncryptedMapData<T>> {
        let mut result = Vec::new();
        for map_id in self.get_accessible_map_ids_iter(caller) {
            let keyvals = self
                .get_encrypted_values_for_map(caller, map_id)
                .unwrap()
                .into_iter()
                .map(|(key, value)| (ByteBuf::from(key.as_ref().to_vec()), value))
                .collect();
            let map = EncryptedMapData {
                map_owner: map_id.0,
                map_name: ByteBuf::from(map_id.1.as_ref().to_vec()),
                keyvals,
                access_control: self
                    .get_shared_user_access_for_map(caller, map_id)
                    .unwrap_or_default(),
            };
            result.push(map);
        }
        result
    }

    fn get_accessible_map_ids_iter(
        &self,
        caller: Principal,
    ) -> impl Iterator<Item = (Principal, MapName)> {
        let accessible_map_ids = self.get_accessible_shared_map_names(caller).into_iter();
        let owned_map_ids =
            std::iter::repeat(caller).zip(self.get_owned_non_empty_map_names(caller));
        accessible_map_ids.chain(owned_map_ids)
    }

    /// Retrieves the non-empty map names owned by the caller.
    /// Returns a list of map names that contain at least one key-value pair.
    pub fn get_owned_non_empty_map_names(&self, caller: Principal) -> Vec<MapName> {
        let map_names: std::collections::HashSet<Vec<u8>> = self
            .mapkey_vals
            .keys_range(((caller, Blob::default()), Blob::default())..)
            .take_while(|((principal, _map_name), _key_name)| principal == &caller)
            .map(|((_principal, map_name), _key_name)| map_name.as_slice().to_vec())
            .collect();
        map_names
            .into_iter()
            .map(|map_name| Blob::<32>::try_from(map_name.as_slice()).unwrap())
            .collect()
    }

    /// Inserts or updates an encrypted value in a map.
    /// The caller must have write permissions to modify the map.
    pub fn insert_encrypted_value(
        &mut self,
        caller: Principal,
        key_id: KeyId,
        key: MapKey,
        encrypted_value: EncryptedMapValue,
    ) -> Result<Option<EncryptedMapValue>, String> {
        self.key_manager.ensure_user_can_write(caller, key_id)?;
        Ok(self.mapkey_vals.insert((key_id, key), encrypted_value))
    }

    /// Removes an encrypted value from a map.
    /// The caller must have write permissions to modify the map.
    pub fn remove_encrypted_value(
        &mut self,
        caller: Principal,
        key_id: KeyId,
        key: MapKey,
    ) -> Result<Option<EncryptedMapValue>, String> {
        self.key_manager.ensure_user_can_write(caller, key_id)?;
        Ok(self.mapkey_vals.remove(&(key_id, key)))
    }

    /// Retrieves the public verification key from KeyManager.
    /// This key is used to verify the authenticity of derived keys.
    pub fn get_vetkey_verification_key(
        &self,
    ) -> impl Future<Output = VetKeyVerificationKey> + Send + Sync {
        self.key_manager.get_vetkey_verification_key()
    }

    /// Retrieves an encrypted vetkey for caller and key id.
    /// The key is secured using the provided transport key and can only be accessed by authorized users.
    pub fn get_encrypted_vetkey(
        &self,
        caller: Principal,
        key_id: KeyId,
        transport_key: TransportKey,
    ) -> Result<impl Future<Output = VetKey> + Send + Sync, String> {
        self.key_manager
            .get_encrypted_vetkey(caller, key_id, transport_key)
    }

    /// Retrieves access rights for a user to a map.
    /// The caller must have appropriate permissions to view this information.
    pub fn get_user_rights(
        &self,
        caller: Principal,
        key_id: KeyId,
        user: Principal,
    ) -> Result<Option<T>, String> {
        self.key_manager.get_user_rights(caller, key_id, user)
    }

    /// Sets or updates access rights for a user to a map.
    /// Only the map owner or a user with management rights can perform this action.
    pub fn set_user_rights(
        &mut self,
        caller: Principal,
        key_id: KeyId,
        user: Principal,
        access_rights: T,
    ) -> Result<Option<T>, String> {
        self.key_manager
            .set_user_rights(caller, key_id, user, access_rights)
    }

    /// Removes access rights for a user from a map.
    /// Only the map owner or a user with management rights can perform this action.
    pub fn remove_user(
        &mut self,
        caller: Principal,
        key_id: KeyId,
        user: Principal,
    ) -> Result<Option<T>, String> {
        self.key_manager.remove_user(caller, key_id, user)
    }
}

/// Represents the complete data for an encrypted map, including ownership, contents, and access control.
#[derive(candid::CandidType, Deserialize)]
pub struct EncryptedMapData<T: AccessControl> {
    pub map_owner: Principal,
    pub map_name: ByteBuf,
    pub keyvals: Vec<(ByteBuf, EncryptedMapValue)>,
    pub access_control: Vec<(Principal, T)>,
}



================================================
FILE: backend/rs/ic_vetkeys/src/key_manager/mod.rs
================================================
//! See [`KeyManager`] for the main documentation.

use crate::types::{AccessControl, ByteBuf, KeyManagerConfig, KeyName, TransportKey};
use candid::Principal;
use ic_stable_structures::memory_manager::VirtualMemory;
use ic_stable_structures::storable::Blob;
use ic_stable_structures::{DefaultMemoryImpl, StableBTreeMap, StableCell, Storable};
use std::future::Future;

use ic_cdk::management_canister::{VetKDDeriveKeyArgs, VetKDKeyId, VetKDPublicKeyArgs};

pub type VetKeyVerificationKey = ByteBuf;
pub type VetKey = ByteBuf;
pub type Owner = Principal;
pub type Caller = Principal;
pub type KeyId = (Owner, KeyName);

type Memory = VirtualMemory<DefaultMemoryImpl>;

/// The **KeyManager** backend is a support library for **vetKeys**.
///
/// **vetKeys** is a feature of the Internet Computer (ICP) that enables the derivation of **encrypted cryptographic keys**. This library simplifies the process of key retrieval, encryption, and controlled sharing, ensuring secure and efficient key management for canisters and users.
///
/// For an introduction to **vetKeys**, refer to the [vetKeys Overview](https://internetcomputer.org/docs/building-apps/network-features/vetkeys/introduction).
///
/// ## Core Features
///
/// The **KeyManager** support library provides the following core functionalities:
///
/// - **Request an Encrypted Key:** Users can derive any number of **encrypted cryptographic keys**, secured using a user-provided **public transport key**. Each vetKey is associated with a unique **key id**.
/// - **Manage vetKey Sharing:** A user can **share their vetKeys** with other users while controlling access rights.
/// - **Access Control Management:** Users can define and enforce **fine-grained permissions** (read, write, manage) for each vetKey.
/// - **Uses Stable Storage:** The library persists key access information using **StableBTreeMap**, ensuring reliability across canister upgrades.
///
/// ## KeyManager Architecture
///
/// The **KeyManager** consists of two primary components:
///
/// 1. **Access Control Map** (`access_control`): Maps `(Caller, KeyId)` to `T`, defining permissions for each user.
/// 2. **Shared Keys Map** (`shared_keys`): Tracks which users have access to shared vetKeys.
///
/// ## Example Use Case
///
/// 1. **User A** requests a vetKey from KeyManager.
/// 2. KeyManager verifies permissions and derives an **encrypted cryptographic key**.
/// 3. **User A** securely shares access with **User B** using `set_user_rights`.
/// 4. **User B** retrieves the key securely via `get_encrypted_vetkey`.
///
/// ## Security Considerations
///
/// - vetKeys are derived **on demand** and constructed from encrypted vetKey shares.
/// - Only authorized users can access shared vetKeys.
/// - Stable storage ensures vetKeys persist across canister upgrades.
/// - Access control logic ensures only authorized users retrieve vetKeys or modify access rights.
///
/// ## Summary
/// [`KeyManager`] simplifies the usage of **vetKeys** on the ICP, providing a secure and efficient mechanism for **cryptographic key derivation, sharing, and management**.
pub struct KeyManager<T: AccessControl> {
    pub config: StableCell<KeyManagerConfig, Memory>,
    pub access_control: StableBTreeMap<(Principal, KeyId), T, Memory>,
    pub shared_keys: StableBTreeMap<(KeyId, Principal), (), Memory>,
}

impl<T: AccessControl> KeyManager<T> {
    /// Initializes the KeyManager with stable storage.
    ///
    /// # Example
    ///
    /// ```rust
    /// use ic_cdk::init;
    /// use ic_cdk::management_canister::{VetKDCurve, VetKDKeyId};
    /// use ic_stable_structures::{
    ///     memory_manager::{MemoryId, MemoryManager, VirtualMemory},
    ///     DefaultMemoryImpl,
    /// };
    /// use ic_vetkeys::types::AccessRights;
    /// use ic_vetkeys::key_manager::KeyManager;
    /// use std::cell::RefCell;
    ///
    /// type Memory = VirtualMemory<DefaultMemoryImpl>;
    ///
    /// thread_local! {
    ///     static MEMORY_MANAGER: RefCell<MemoryManager<DefaultMemoryImpl>> =
    ///         RefCell::new(MemoryManager::init(DefaultMemoryImpl::default()));
    ///     static KEY_MANAGER: RefCell<Option<KeyManager<AccessRights>>> = const { RefCell::new(None) };
    /// }
    ///
    /// #[init]
    /// fn init(key_name: String) {
    ///     let key_id = VetKDKeyId {
    ///         curve: VetKDCurve::Bls12_381_G2,
    ///         name: key_name,
    ///     };
    ///     KEY_MANAGER.with_borrow_mut(|km| {
    ///         km.replace(KeyManager::init(
    ///             "key_manager_dapp",
    ///             key_id,
    ///             id_to_memory(0),
    ///             id_to_memory(1),
    ///             id_to_memory(2),
    ///         ))
    ///     });
    /// }
    ///
    /// fn id_to_memory(id: u8) -> Memory {
    ///     MEMORY_MANAGER.with(|m| m.borrow().get(MemoryId::new(id)))
    /// }
    /// ```
    pub fn init(
        domain_separator: &str,
        key_id: VetKDKeyId,
        memory_key_manager_config: Memory,
        memory_access_control: Memory,
        memory_shared_keys: Memory,
    ) -> Self {
        let config = StableCell::init(
            memory_key_manager_config,
            KeyManagerConfig {
                domain_separator: domain_separator.to_string(),
                key_id: key_id.clone(),
            },
        );
        KeyManager {
            config,
            access_control: StableBTreeMap::init(memory_access_control),
            shared_keys: StableBTreeMap::init(memory_shared_keys),
        }
    }

    /// Retrieves all vetKey IDs shared with the given caller.
    /// This method returns a list of all vetKeys that the caller has access to.
    pub fn get_accessible_shared_key_ids(&self, caller: Principal) -> Vec<KeyId> {
        self.access_control
            .range((caller, (Principal::management_canister(), Blob::default()))..)
            .take_while(|entry| entry.key().0 == caller)
            .map(|entry| entry.key().1)
            .collect()
    }

    /// Retrieves a list of users with whom a given vetKey has been shared, along with their access rights.
    /// The caller must have appropriate permissions to view this information.
    pub fn get_shared_user_access_for_key(
        &self,
        caller: Principal,
        key_id: KeyId,
    ) -> Result<Vec<(Principal, T)>, String> {
        self.ensure_user_can_get_user_rights(caller, key_id)?;

        let users: Vec<_> = self
            .shared_keys
            .range((key_id, Principal::management_canister())..)
            .take_while(|entry| entry.key().0 == key_id)
            .map(|entry| entry.key().1)
            .collect();

        users
            .into_iter()
            .map(|user| {
                self.get_user_rights(caller, key_id, user)
                    .map(|opt_user_rights| {
                        (user, opt_user_rights.expect("always some access rights"))
                    })
            })
            .collect::<Result<Vec<_>, _>>()
    }

    /// Retrieves the vetKD verification key for this canister.
    /// This key is used to verify the authenticity of derived vetKeys.
    pub fn get_vetkey_verification_key(
        &self,
    ) -> impl Future<Output = VetKeyVerificationKey> + Send + Sync {
        use futures::future::FutureExt;

        let domain_separator = self.config.get().domain_separator.clone();
        let key_id = self.config.get().key_id.clone();

        let future = async move {
            let request = VetKDPublicKeyArgs {
                canister_id: None,
                context: domain_separator.to_bytes().to_vec(),
                key_id,
            };

            ic_cdk::management_canister::vetkd_public_key(&request).await
        };

        future.map(|call_result| {
            let reply = call_result.expect("call to vetkd_public_key failed");
            VetKeyVerificationKey::from(reply.public_key)
        })
    }

    /// Retrieves an encrypted vetKey for caller and key id.
    /// The vetKey is secured using the provided transport key and can only be accessed by authorized users.
    /// Returns an error if the caller is not authorized to access the vetKey.
    pub fn get_encrypted_vetkey(
        &self,
        caller: Principal,
        subkey_key_id: KeyId,
        transport_key: TransportKey,
    ) -> Result<impl Future<Output = VetKey> + Send + Sync, String> {
        use futures::future::FutureExt;

        self.ensure_user_can_read(caller, subkey_key_id)?;

        let domain_separator = self.config.get().domain_separator.clone();
        let vetkd_key_id = self.config.get().key_id.clone();
        let future = async move {
            let request = VetKDDeriveKeyArgs {
                input: key_id_to_vetkd_input(subkey_key_id.0, subkey_key_id.1.as_ref()),
                context: domain_separator.to_bytes().to_vec(),
                key_id: vetkd_key_id,
                transport_public_key: transport_key.into(),
            };

            ic_cdk::management_canister::vetkd_derive_key(&request).await
        };

        Ok(future.map(|call_result| {
            let reply = call_result.expect("call to vetkd_derive_key failed");
            VetKey::from(reply.encrypted_key)
        }))
    }

    /// Retrieves the access rights a given user has to a specific vetKey.
    /// The caller must have appropriate permissions to view this information.
    pub fn get_user_rights(
        &self,
        caller: Principal,
        key_id: KeyId,
        user: Principal,
    ) -> Result<Option<T>, String> {
        self.ensure_user_can_get_user_rights(caller, key_id)?;
        Ok(self.ensure_user_can_read(user, key_id).ok())
    }

    /// Grants or modifies access rights for a user to a given vetKey.
    /// Only the vetKey owner or a user with management rights can perform this action.
    /// The vetKey owner cannot change their own rights.
    pub fn set_user_rights(
        &mut self,
        caller: Principal,
        key_id: KeyId,
        user: Principal,
        access_rights: T,
    ) -> Result<Option<T>, String> {
        self.ensure_user_can_set_user_rights(caller, key_id)?;

        if caller == key_id.0 && caller == user {
            return Err("cannot change key owner's user rights".to_string());
        }
        self.shared_keys.insert((key_id, user), ());
        Ok(self.access_control.insert((user, key_id), access_rights))
    }

    /// Revokes a user's access to a shared vetKey.
    /// The vetKey owner cannot remove their own access.
    /// Only the vetKey owner or a user with management rights can perform this action.
    pub fn remove_user(
        &mut self,
        caller: Principal,
        key_id: KeyId,
        user: Principal,
    ) -> Result<Option<T>, String> {
        self.ensure_user_can_set_user_rights(caller, key_id)?;

        if caller == user && caller == key_id.0 {
            return Err("cannot remove key owner".to_string());
        }

        self.shared_keys.remove(&(key_id, user));
        Ok(self.access_control.remove(&(user, key_id)))
    }

    /// Ensures that a user has read access to a vetKey before proceeding.
    /// Returns an error if the user is not authorized.
    pub fn ensure_user_can_read(&self, user: Principal, key_id: KeyId) -> Result<T, String> {
        let is_owner = user == key_id.0;
        if is_owner {
            return Ok(T::owner_rights());
        }

        let has_shared_access = self.access_control.get(&(user, key_id));
        match has_shared_access {
            Some(access_rights) if access_rights.can_read() => Ok(access_rights),
            _ => Err("unauthorized".to_string()),
        }
    }

    /// Ensures that a user has write access to a vetKey before proceeding.
    /// Returns an error if the user is not authorized.
    pub fn ensure_user_can_write(&self, user: Principal, key_id: KeyId) -> Result<T, String> {
        let is_owner = user == key_id.0;
        if is_owner {
            return Ok(T::owner_rights());
        }

        let has_shared_access = self.access_control.get(&(user, key_id));
        match has_shared_access {
            Some(access_rights) if access_rights.can_write() => Ok(access_rights),
            _ => Err("unauthorized".to_string()),
        }
    }

    /// Ensures that a user has permission to view user rights for a vetKey.
    /// Returns an error if the user is not authorized.
    pub fn ensure_user_can_get_user_rights(
        &self,
        user: Principal,
        key_id: KeyId,
    ) -> Result<T, String> {
        let is_owner = user == key_id.0;
        if is_owner {
            return Ok(T::owner_rights());
        }

        let has_shared_access = self.access_control.get(&(user, key_id));
        match has_shared_access {
            Some(access_rights) if access_rights.can_get_user_rights() => Ok(access_rights),
            _ => Err("unauthorized".to_string()),
        }
    }

    /// Ensures that a user has management access to a vetKey before proceeding.
    /// Returns an error if the user is not authorized.
    pub fn ensure_user_can_set_user_rights(
        &self,
        user: Principal,
        key_id: KeyId,
    ) -> Result<T, String> {
        let is_owner = user == key_id.0;
        if is_owner {
            return Ok(T::owner_rights());
        }

        let has_shared_access = self.access_control.get(&(user, key_id));
        match has_shared_access {
            Some(access_rights) if access_rights.can_set_user_rights() => Ok(access_rights),
            _ => Err("unauthorized".to_string()),
        }
    }
}

pub fn key_id_to_vetkd_input(principal: Principal, key_name: &[u8]) -> Vec<u8> {
    let mut vetkd_input = Vec::with_capacity(principal.as_slice().len() + 1 + key_name.len());
    vetkd_input.push(principal.as_slice().len() as u8);
    vetkd_input.extend(principal.as_slice());
    vetkd_input.extend(key_name);
    vetkd_input
}



================================================
FILE: backend/rs/ic_vetkeys/tests/encrypted_maps.rs
================================================
use std::{collections::BTreeMap, iter::FromIterator};

use assert_matches::assert_matches;
use candid::Principal;
use ic_cdk::management_canister::{VetKDCurve, VetKDKeyId};
use ic_stable_structures::{
    memory_manager::{MemoryId, MemoryManager},
    storable::Blob,
    DefaultMemoryImpl,
};
use ic_vetkeys_test_utils::{
    random_access_rights, random_bytebuf, random_key, random_name,
    random_self_authenticating_principal, random_unique_memory_ids, random_utf8_string,
    reproducible_rng,
};
use rand::{CryptoRng, Rng};
use strum::IntoEnumIterator;

use ic_vetkeys::encrypted_maps::EncryptedMaps;
use ic_vetkeys::types::{AccessControl, AccessRights};

#[test]
fn can_init_memory() {
    // prevent the compiler from optimizing away the function call
    std::hint::black_box(random_encrypted_maps(&mut reproducible_rng()));
}

#[test]
fn can_remove_map_values() {
    let rng = &mut reproducible_rng();
    let caller = random_self_authenticating_principal(rng);
    let name = random_name(rng);
    let mut encrypted_maps = random_encrypted_maps(rng);
    let result = encrypted_maps.remove_map_values(caller, (caller, name));
    assert_eq!(result, Ok(vec![]));
}

#[test]
fn unauthorized_delete_map_values_fails() {
    let rng = &mut reproducible_rng();
    let caller = random_self_authenticating_principal(rng);
    let unauthorized = random_self_authenticating_principal(rng);
    let name = random_name(rng);
    let key = random_key(rng);
    let encrypted_value = random_bytebuf(rng, 0..2_000_000);
    let mut encrypted_maps = random_encrypted_maps(rng);

    encrypted_maps
        .insert_encrypted_value(caller, (caller, name), key, encrypted_value)
        .unwrap();
    let result = encrypted_maps.remove_map_values(unauthorized, (caller, name));
    assert_eq!(result, Err("unauthorized".to_string()));
}

#[test]
fn can_add_user_to_map() {
    let rng = &mut reproducible_rng();
    let caller = random_self_authenticating_principal(rng);
    let name = random_name(rng);
    let mut encrypted_maps = random_encrypted_maps(rng);

    let user_to_be_added = random_self_authenticating_principal(rng);
    let access_rights = random_access_rights(rng);
    assert_eq!(
        encrypted_maps.get_user_rights(caller, (caller, name), user_to_be_added,),
        Ok(None)
    );
    assert_eq!(
        encrypted_maps.set_user_rights(caller, (caller, name), user_to_be_added, access_rights),
        Ok(None)
    );
    assert_eq!(
        encrypted_maps.set_user_rights(caller, (caller, name), user_to_be_added, access_rights),
        Ok(Some(access_rights))
    );
    assert_eq!(
        encrypted_maps.get_user_rights(caller, (caller, name), user_to_be_added,),
        Ok(Some(access_rights))
    );
}

#[test]
fn unauthorized_cannot_invoke_operations() {
    let rng = &mut reproducible_rng();
    let unauthorized = random_self_authenticating_principal(rng);
    let owner = random_self_authenticating_principal(rng);
    let map_name = random_name(rng);
    let map_id = (owner, map_name);
    let map_key = random_key(rng);
    let mut encrypted_maps = random_encrypted_maps(rng);

    assert_eq!(
        encrypted_maps.get_user_rights(unauthorized, map_id, unauthorized),
        Err("unauthorized".to_string())
    );

    assert_eq!(
        encrypted_maps.get_encrypted_value(unauthorized, map_id, map_key),
        Err("unauthorized".to_string())
    );

    assert_eq!(
        encrypted_maps.get_encrypted_values_for_map(unauthorized, map_id),
        Err("unauthorized".to_string())
    );

    for _ in 0..2 {
        assert_eq!(
            encrypted_maps.remove_map_values(unauthorized, map_id),
            Err("unauthorized".to_string())
        );

        assert_eq!(
            encrypted_maps.remove_user(unauthorized, map_id, unauthorized),
            Err("unauthorized".to_string())
        );

        assert_eq!(
            encrypted_maps.set_user_rights(unauthorized, map_id, unauthorized, AccessRights::Read),
            Err("unauthorized".to_string())
        );

        encrypted_maps
            .set_user_rights(owner, map_id, unauthorized, AccessRights::Read)
            .unwrap();
    }

    encrypted_maps
        .set_user_rights(owner, map_id, unauthorized, AccessRights::ReadWrite)
        .unwrap();

    assert_eq!(
        encrypted_maps.set_user_rights(unauthorized, map_id, unauthorized, AccessRights::Read),
        Err("unauthorized".to_string())
    );
}

#[test]
fn can_remove_user_from_map() {
    let rng = &mut reproducible_rng();
    let caller = random_self_authenticating_principal(rng);
    let name = random_name(rng);
    let mut encrypted_maps = random_encrypted_maps(rng);

    let user_to_be_added = random_self_authenticating_principal(rng);
    let access_rights = random_access_rights(rng);
    assert_eq!(
        encrypted_maps.set_user_rights(caller, (caller, name), user_to_be_added, access_rights,),
        Ok(None)
    );
    assert_eq!(
        encrypted_maps.remove_user(caller, (caller, name), user_to_be_added,),
        Ok(Some(access_rights))
    );
}

#[test]
fn add_or_remove_user_by_unauthorized_fails() {
    let rng = &mut reproducible_rng();
    let caller = random_self_authenticating_principal(rng);
    let name = random_name(rng);
    let mut encrypted_maps = random_encrypted_maps(rng);

    let mut unauthorized_callers = vec![random_self_authenticating_principal(rng)];

    for access_rights in AccessRights::iter() {
        if access_rights.can_get_user_rights() {
            continue;
        }
        let user_to_be_added = random_self_authenticating_principal(rng);

        assert_matches!(
            encrypted_maps
                .set_user_rights(caller, (caller, name), user_to_be_added, access_rights,),
            Ok(_)
        );

        unauthorized_callers.push(user_to_be_added);
    }

    for unauthorized_caller in unauthorized_callers {
        for target in [random_self_authenticating_principal(rng), caller] {
            assert_eq!(
                encrypted_maps.remove_user(unauthorized_caller, (caller, name), target),
                Err("unauthorized".to_string())
            );
            assert_eq!(
                encrypted_maps.set_user_rights(
                    unauthorized_caller,
                    (caller, name),
                    target,
                    AccessRights::Read,
                ),
                Err("unauthorized".to_string())
            );
        }
    }
}

#[test]
fn can_add_a_key_to_map() {
    let rng = &mut reproducible_rng();
    let caller = random_self_authenticating_principal(rng);
    let name = random_name(rng);
    let mut encrypted_maps = random_encrypted_maps(rng);

    let key = random_key(rng);
    let value = random_bytebuf(rng, 0..2_000_000);
    assert_eq!(
        encrypted_maps.insert_encrypted_value(caller, (caller, name), key, value),
        Ok(None)
    );
}

#[test]
fn add_a_key_to_map_by_unauthorized_fails() {
    let rng = &mut reproducible_rng();
    let caller = random_self_authenticating_principal(rng);
    let name = random_name(rng);
    let mut encrypted_maps = random_encrypted_maps(rng);

    let unauthorized_caller = random_self_authenticating_principal(rng);
    let key = random_key(rng);
    let value = random_bytebuf(rng, 0..2_000_000);
    assert_eq!(
        encrypted_maps.insert_encrypted_value(
            unauthorized_caller,
            (caller, name),
            key,
            value.clone()
        ),
        Err("unauthorized".to_string())
    );

    let readonly_caller = random_self_authenticating_principal(rng);

    assert_eq!(
        encrypted_maps
            .set_user_rights(caller, (caller, name), readonly_caller, AccessRights::Read,),
        Ok(None)
    );

    assert_eq!(
        encrypted_maps.insert_encrypted_value(readonly_caller, (caller, name), key, value),
        Err("unauthorized".to_string())
    );
}

#[test]
fn can_remove_a_key_from_map() {
    let rng = &mut reproducible_rng();
    let caller = random_self_authenticating_principal(rng);
    let name = random_name(rng);
    let mut encrypted_maps = random_encrypted_maps(rng);

    let key = random_key(rng);
    let value = random_bytebuf(rng, 0..2_000_000);
    encrypted_maps
        .insert_encrypted_value(caller, (caller, name), key, value.clone())
        .unwrap();
    assert_eq!(
        encrypted_maps.remove_encrypted_value(caller, (caller, name), key),
        Ok(Some(value))
    );
}

#[test]
fn remove_of_key_from_map_by_unauthorized_fails() {
    let rng = &mut reproducible_rng();
    let caller = random_self_authenticating_principal(rng);
    let name = random_name(rng);
    let mut encrypted_maps = random_encrypted_maps(rng);

    let key = random_key(rng);
    let value = random_bytebuf(rng, 0..2_000_000);
    encrypted_maps
        .insert_encrypted_value(caller, (caller, name), key, value)
        .unwrap();

    let unauthorized_caller = random_self_authenticating_principal(rng);
    assert_eq!(
        encrypted_maps.remove_encrypted_value(unauthorized_caller, (caller, name), key),
        Err("unauthorized".to_string())
    );

    let readonly_caller = random_self_authenticating_principal(rng);

    assert_eq!(
        encrypted_maps
            .set_user_rights(caller, (caller, name), readonly_caller, AccessRights::Read,),
        Ok(None)
    );

    assert_eq!(
        encrypted_maps.remove_encrypted_value(readonly_caller, (caller, name), key),
        Err("unauthorized".to_string())
    );
}

#[test]
fn can_access_map_values() {
    let rng = &mut reproducible_rng();
    let caller = random_self_authenticating_principal(rng);
    let name = random_name(rng);
    let mut encrypted_maps = random_encrypted_maps(rng);

    let mut authorized_users = vec![(caller, AccessRights::ReadWriteManage)];
    let mut keyvals = vec![];

    for _ in 0..3 {
        let key = random_key(rng);
        let value = random_bytebuf(rng, 0..100);
        encrypted_maps
            .insert_encrypted_value(caller, (caller, name), key, value.clone())
            .unwrap();

        for access_rights in AccessRights::iter() {
            let user_to_be_added = random_self_authenticating_principal(rng);
            assert_eq!(
                encrypted_maps.set_user_rights(
                    caller,
                    (caller, name),
                    user_to_be_added,
                    access_rights,
                ),
                Ok(None)
            );
            authorized_users.push((user_to_be_added, access_rights));
        }

        keyvals.push((key, value));
    }

    for (key, value) in keyvals.clone() {
        for (user, _access_rights) in authorized_users.iter() {
            assert_eq!(
                encrypted_maps.get_encrypted_value(*user, (caller, name), key),
                Ok(Some(value.clone()))
            );
        }
    }

    for (user, access_rights) in authorized_users.clone() {
        let expected_map = BTreeMap::from_iter(keyvals.clone().into_iter());
        let computed_map_single = BTreeMap::from_iter(
            encrypted_maps
                .get_encrypted_values_for_map(user, (caller, name))
                .expect("failed to obtain values")
                .into_iter(),
        );
        assert_eq!(expected_map, computed_map_single);

        let all_values = encrypted_maps.get_all_accessible_encrypted_values(user);
        let all_maps = encrypted_maps.get_all_accessible_encrypted_maps(user);
        assert_eq!(all_values.len(), 1);
        assert_eq!(
            all_values,
            all_maps
                .iter()
                .map(|m| (
                    (
                        m.map_owner,
                        Blob::<32>::try_from(m.map_name.as_ref()).unwrap()
                    ),
                    m.keyvals
                        .iter()
                        .map(|(map_key, value)| (
                            Blob::<32>::try_from(map_key.as_ref()).unwrap(),
                            value.clone()
                        ))
                        .collect::<Vec<_>>()
                ))
                .collect::<Vec<_>>()
        );

        let all_destructured = all_values.into_iter().next().unwrap();
        assert_eq!((caller, name), all_destructured.0);
        let computed_map_wildcard = BTreeMap::from_iter(all_destructured.1.into_iter());
        assert_eq!(expected_map, computed_map_wildcard);

        for map in all_maps {
            if access_rights.can_get_user_rights() {
                assert_eq!(
                    BTreeMap::<Principal, AccessRights>::from_iter(
                        map.access_control
                            .into_iter()
                            .chain(std::iter::once((caller, access_rights)))
                    ),
                    BTreeMap::from_iter(authorized_users.clone().into_iter())
                );
            } else {
                assert_eq!(map.access_control, vec![]);
            }
        }
    }
}

#[test]
fn can_modify_a_key_value_in_map() {
    let rng = &mut reproducible_rng();
    let caller = random_self_authenticating_principal(rng);
    let name = random_name(rng);
    let mut encrypted_maps = random_encrypted_maps(rng);

    let key = random_key(rng);
    let value = random_bytebuf(rng, 0..2_000_000);
    encrypted_maps
        .insert_encrypted_value(caller, (caller, name), key, value.clone())
        .unwrap();

    let new_value = random_bytebuf(rng, 0..2_000_000);
    assert_eq!(
        encrypted_maps.insert_encrypted_value(caller, (caller, name), key, new_value),
        Ok(Some(value))
    );
}

#[test]
fn modify_a_key_value_in_map_by_unauthorized_fails() {
    let rng = &mut reproducible_rng();
    let caller = random_self_authenticating_principal(rng);
    let name = random_name(rng);
    let mut encrypted_maps = random_encrypted_maps(rng);

    let key = random_key(rng);
    let value = random_bytebuf(rng, 0..2_000_000);
    encrypted_maps
        .insert_encrypted_value(caller, (caller, name), key, value.clone())
        .unwrap();

    let unauthorized_caller = random_self_authenticating_principal(rng);
    let new_value = random_bytebuf(rng, 0..2_000_000);
    assert_eq!(
        encrypted_maps.insert_encrypted_value(
            unauthorized_caller,
            (caller, name),
            key,
            new_value.clone()
        ),
        Err("unauthorized".to_string())
    );

    let readonly_caller = random_self_authenticating_principal(rng);

    assert_eq!(
        encrypted_maps
            .set_user_rights(caller, (caller, name), readonly_caller, AccessRights::Read,),
        Ok(None)
    );

    assert_eq!(
        encrypted_maps.insert_encrypted_value(readonly_caller, (caller, name), key, new_value),
        Err("unauthorized".to_string())
    );
}

#[test]
fn can_get_owned_map_names() {
    use rand::Rng;

    let rng = &mut reproducible_rng();
    let caller = random_self_authenticating_principal(rng);
    let mut encrypted_maps = random_encrypted_maps(rng);

    let mut expected_map_names = vec![];

    for _ in 0..7 {
        let map_names = encrypted_maps.get_owned_non_empty_map_names(caller);
        assert_eq!(map_names.len(), expected_map_names.len());
        for map_name in expected_map_names.iter() {
            assert!(map_names.contains(map_name));
        }

        let name = random_name(rng);
        expected_map_names.push(name);

        for _ in 1..3 {
            let key = random_key(rng);
            let value = random_bytebuf(rng, 0..2_000_000);
            encrypted_maps
                .insert_encrypted_value(caller, (caller, name), key, value.clone())
                .unwrap();
        }

        let map_names = encrypted_maps.get_owned_non_empty_map_names(caller);
        assert_eq!(map_names.len(), expected_map_names.len());
        for map_name in expected_map_names.iter() {
            assert!(map_names.contains(map_name));
        }

        let should_remove_map = rng.gen_bool(0.2);

        if should_remove_map {
            encrypted_maps
                .remove_map_values(caller, (caller, name))
                .unwrap();
            expected_map_names.pop();
        }
    }
}

fn random_encrypted_maps<R: Rng + CryptoRng>(rng: &mut R) -> EncryptedMaps<AccessRights> {
    let memory_manager = MemoryManager::init(DefaultMemoryImpl::default());
    let (memory_id_encrypted_maps, memory_ids_key_manager) = random_unique_memory_ids(rng);
    let domain_separator_len = rng.gen_range(0..32);
    EncryptedMaps::init(
        &random_utf8_string(rng, domain_separator_len),
        bls12_381_dfx_test_key(),
        memory_manager.get(MemoryId::new(memory_id_encrypted_maps)),
        memory_manager.get(MemoryId::new(memory_ids_key_manager[0])),
        memory_manager.get(MemoryId::new(memory_ids_key_manager[1])),
        memory_manager.get(MemoryId::new(memory_ids_key_manager[2])),
    )
}

fn bls12_381_dfx_test_key() -> VetKDKeyId {
    VetKDKeyId {
        curve: VetKDCurve::Bls12_381_G2,
        name: "dfx_test_key".to_string(),
    }
}



================================================
FILE: backend/rs/ic_vetkeys/tests/key_manager.rs
================================================
use std::collections::BTreeSet;

use assert_matches::assert_matches;
use ic_cdk::management_canister::{VetKDCurve, VetKDKeyId};
use ic_stable_structures::{
    memory_manager::{MemoryId, MemoryManager},
    DefaultMemoryImpl,
};
use ic_vetkeys::key_manager::KeyManager;
use ic_vetkeys::types::AccessRights;
use ic_vetkeys_test_utils::{
    random_access_rights, random_name, random_self_authenticating_principal,
    random_unique_memory_ids, random_utf8_string, reproducible_rng,
};
use rand::{CryptoRng, Rng};

#[test]
fn can_init_memory() {
    // prevent the compiler from optimizing away the function call
    std::hint::black_box(random_key_manager(&mut reproducible_rng()));
}

#[test]
fn get_accessible_shared_key_ids_works_correctly() {
    let rng = &mut reproducible_rng();
    let user_to_be_added = random_self_authenticating_principal(rng);
    let mut key_manager = random_key_manager(rng);

    let mut map_ids = BTreeSet::new();

    for _ in 0..10 {
        let caller = random_self_authenticating_principal(rng);
        let access_rights = random_access_rights(rng);
        let name = random_name(rng);

        assert_eq!(
            key_manager.set_user_rights(caller, (caller, name), user_to_be_added, access_rights),
            Ok(None)
        );

        map_ids.insert((caller, name));
        let computed_map_ids: BTreeSet<_> = key_manager
            .get_accessible_shared_key_ids(user_to_be_added)
            .into_iter()
            .collect();

        assert_eq!(computed_map_ids, map_ids);
    }
}

#[test]
fn can_get_shared_user_access_for_key() {
    let rng = &mut reproducible_rng();
    let caller = random_self_authenticating_principal(rng);
    let name = random_name(rng);
    let mut key_manager = random_key_manager(rng);

    let mut shared_access = BTreeSet::new();

    for _ in 0..10 {
        let user_to_be_added = random_self_authenticating_principal(rng);
        let access_rights = random_access_rights(rng);

        let computed_shared_access: BTreeSet<_> = key_manager
            .get_shared_user_access_for_key(caller, (caller, name))
            .unwrap()
            .into_iter()
            .collect();

        assert_eq!(shared_access, computed_shared_access);

        assert_eq!(
            key_manager.set_user_rights(caller, (caller, name), user_to_be_added, access_rights),
            Ok(None)
        );

        shared_access.insert((user_to_be_added, access_rights));
    }
}

#[test]
fn get_shared_user_access_for_key_fails_for_unauthorized() {
    let rng = &mut reproducible_rng();
    let unauthorized = random_self_authenticating_principal(rng);
    let key_id = (random_self_authenticating_principal(rng), random_name(rng));
    let key_manager = random_key_manager(rng);
    assert_eq!(
        key_manager.get_shared_user_access_for_key(unauthorized, key_id),
        Err("unauthorized".to_string())
    );
}

#[test]
fn can_add_user_to_key() {
    let rng = &mut reproducible_rng();
    let caller = random_self_authenticating_principal(rng);
    let name = random_name(rng);

    let mut key_manager = random_key_manager(rng);

    let user_to_be_added = random_self_authenticating_principal(rng);
    let access_rights = random_access_rights(rng);

    assert_eq!(
        key_manager.get_user_rights(caller, (caller, name), user_to_be_added),
        Ok(None)
    );

    assert_eq!(
        key_manager.set_user_rights(caller, (caller, name), user_to_be_added, access_rights),
        Ok(None)
    );

    assert_eq!(
        key_manager.get_user_rights(caller, (caller, name), user_to_be_added),
        Ok(Some(access_rights))
    );

    assert_eq!(
        key_manager.set_user_rights(caller, (caller, name), user_to_be_added, access_rights),
        Ok(Some(access_rights))
    );
}

#[test]
fn get_and_set_user_rights_fails_for_unauthorized() {
    let rng = &mut reproducible_rng();
    let unauthorized = random_self_authenticating_principal(rng);
    let key_id = (random_self_authenticating_principal(rng), random_name(rng));
    let mut key_manager = random_key_manager(rng);
    assert_eq!(
        key_manager.get_user_rights(unauthorized, key_id, unauthorized),
        Err("unauthorized".to_string())
    );
    assert_eq!(
        key_manager.set_user_rights(unauthorized, key_id, unauthorized, AccessRights::Read),
        Err("unauthorized".to_string())
    );
}

#[test]
fn cannot_alter_owner_rights() {
    let rng = &mut reproducible_rng();
    let caller = random_self_authenticating_principal(rng);
    let name = random_name(rng);
    let mut key_manager = random_key_manager(rng);

    assert_eq!(
        key_manager.set_user_rights(caller, (caller, name), caller, AccessRights::Read),
        Err("cannot change key owner's user rights".to_string())
    );

    assert_eq!(
        key_manager.remove_user(caller, (caller, name), caller),
        Err("cannot remove key owner".to_string())
    );
}

#[test]
fn other_user_can_manage_key() {
    let rng = &mut reproducible_rng();
    let owner = random_self_authenticating_principal(rng);
    let user1 = random_self_authenticating_principal(rng);
    let user2 = random_self_authenticating_principal(rng);
    let name = random_name(rng);
    let mut key_manager = random_key_manager(rng);

    let key_id = (owner, name);

    key_manager
        .set_user_rights(owner, key_id, user1, AccessRights::ReadWriteManage)
        .unwrap();
    key_manager
        .set_user_rights(owner, key_id, user2, AccessRights::ReadWriteManage)
        .unwrap();

    key_manager.remove_user(user2, key_id, user1).unwrap();
    key_manager.remove_user(user2, key_id, user2).unwrap();
}

#[test]
fn can_remove_user_from_key() {
    let rng = &mut reproducible_rng();
    let caller = random_self_authenticating_principal(rng);
    let name = random_name(rng);
    let mut key_manager = random_key_manager(rng);

    let user_to_be_added = random_self_authenticating_principal(rng);
    let access_rights = random_access_rights(rng);
    assert_eq!(
        key_manager.set_user_rights(caller, (caller, name), user_to_be_added, access_rights,),
        Ok(None)
    );
    assert_eq!(
        key_manager.remove_user(caller, (caller, name), user_to_be_added,),
        Ok(Some(access_rights))
    );
    assert_eq!(
        key_manager.get_user_rights(caller, (caller, name), user_to_be_added),
        Ok(None)
    );
}

#[test]
fn add_or_remove_user_by_unauthorized_fails() {
    let rng = &mut reproducible_rng();
    let caller = random_self_authenticating_principal(rng);
    let name = random_name(rng);
    let mut key_manager = random_key_manager(rng);

    let mut unauthorized_callers = vec![random_self_authenticating_principal(rng)];

    for access_rights in [AccessRights::Read, AccessRights::ReadWrite] {
        let user_to_be_added = random_self_authenticating_principal(rng);

        assert_matches!(
            key_manager.set_user_rights(caller, (caller, name), user_to_be_added, access_rights,),
            Ok(_)
        );

        unauthorized_callers.push(user_to_be_added);
    }

    for unauthorized_caller in unauthorized_callers {
        for target in [random_self_authenticating_principal(rng), caller] {
            assert_eq!(
                key_manager.remove_user(unauthorized_caller, (caller, name), target),
                Err("unauthorized".to_string())
            );
            assert_eq!(
                key_manager.set_user_rights(
                    unauthorized_caller,
                    (caller, name),
                    target,
                    AccessRights::Read,
                ),
                Err("unauthorized".to_string())
            );
        }
    }
}

#[test]
fn can_instantiate_two_key_managers() {
    let memory_manager = MemoryManager::init(DefaultMemoryImpl::default());
    let key_manager_1 = KeyManager::<AccessRights>::init(
        "key_manager_1",
        bls12_381_dfx_test_key(),
        memory_manager.get(MemoryId::new(0)),
        memory_manager.get(MemoryId::new(1)),
        memory_manager.get(MemoryId::new(2)),
    );
    let key_manager_2 = KeyManager::<AccessRights>::init(
        "key_manager_2",
        bls12_381_dfx_test_key(),
        memory_manager.get(MemoryId::new(3)),
        memory_manager.get(MemoryId::new(4)),
        memory_manager.get(MemoryId::new(5)),
    );
    // prevent the compiler from optimizing away the function call
    std::hint::black_box((key_manager_1, key_manager_2));
}

fn random_key_manager<R: Rng + CryptoRng>(rng: &mut R) -> KeyManager<AccessRights> {
    let memory_manager = MemoryManager::init(DefaultMemoryImpl::default());
    let (_memory_id_encrypted_maps, memory_ids_key_manager) = random_unique_memory_ids(rng);
    let domain_separator_len = rng.gen_range(0..32);
    KeyManager::<AccessRights>::init(
        &random_utf8_string(rng, domain_separator_len),
        bls12_381_dfx_test_key(),
        memory_manager.get(MemoryId::new(memory_ids_key_manager[0])),
        memory_manager.get(MemoryId::new(memory_ids_key_manager[1])),
        memory_manager.get(MemoryId::new(memory_ids_key_manager[2])),
    )
}

fn bls12_381_dfx_test_key() -> VetKDKeyId {
    VetKDKeyId {
        curve: VetKDCurve::Bls12_381_G2,
        name: "dfx_test_key".to_string(),
    }
}



================================================
FILE: backend/rs/ic_vetkeys/tests/utils.rs
================================================
use hex_literal::hex;
use ic_bls12_381::*;
use ic_cdk::management_canister::{VetKDCurve, VetKDKeyId};
use ic_vetkeys::*;
use ic_vetkeys_test_utils::*;
use rand::Rng;

#[test]
fn test_hkdf_test_vector() {
    // HKDF test vectors from wycheproof
    let test_vectors = [
        ("0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b", "", "8da4e775a563c18f715f802a063c5a31b8a11f5c5ee1879ec3454e5f3c738d2d9d201395faa4b61a96c8"),
        ("24aeff2645e3e0f5494a9a102778c43a", "", "d4cca5e416c3d9eb58bd562e922691daff76aa4d"),
        ("a23632e18ec76b59b1c87008da3f8a7e", "", "976d1590926ac35e28d7f1a29fe98a1f787703a71cee3cb2c10acb9cc1b56c0f21b55d5de37755a79b12"),
        ("a4748031a14d3e6aafe42aa20c568f5f", "", "03f5db41f4484ec9468648c9f2a7f73ec18386008691b0555a7eec165e2f8cc72a6e74fffafbfb1ead00a89ff80ba00a266a70fcac07364110c6f5707f5096aa"),
        ("fa4f94e9cdbf725c1ee98decddbe42ec06196116", "", "f32a552257d372b16c5d8c46e6c07dc9c33be9bc"),
        ("094db4e2eaae8fc9dca0d9bc14b29387fd476921", "", "41ae65892c3359f808e906bbc91c701f7e067b548e685bc02d5badad2799221bf313964f8307670d76a8"),
        ("bfbe4f1edace02b2a3afcaada5f319103996dec9", "", "93c737cdce4fe225839614393bc5ff6fd14390dc436ad6f9e13a7714e8b8b2d66cb690fd9a213c0e297ac96fda5d27e002cfc344964b86e78ff23c260cbcc82e"),
        ("7ef7d4f8c11d940471cf9a3048d66b3b3a3d9db9fed5f81419fe75dd50116f4e", "", "a370de1c822b8eb00645c18e32ad6a1f4bb17c9b"),
        ("1b6c7d5da045bf8bd4ac3083e8de2b90904bc7f7830bef876e355b74466cef91", "", "50dd5b5adbe96aa216f93c4cbb7d568d5141b3ef7214be885984629b93f07814870db846c3efc8c7db7f"),
        ("b9da242c02bfe79364aedd7a323692191092edb2094f112675c2609a387c3b21", "", "384c0ded57bf066d6665d88355aff9eab8cbd78c1c71af7b8334cde6536f21223aeddd5a84d278d5d73f5b536973575dd2993a4a857289c3b59861643c464c2c"),
    ];

    for (input, dst, expected) in &test_vectors {
        let computed = derive_symmetric_key(&hex::decode(input).unwrap(), dst, expected.len() / 2);
        assert_eq!(hex::encode(computed), *expected);
    }
}

#[test]
fn test_is_valid_transport_public_key() {
    assert!(!is_valid_transport_public_key_encoding(
        &hex::decode("F00F00F00F00").unwrap()
    ));
    assert!(is_valid_transport_public_key_encoding(&hex::decode("97f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb").unwrap()));
    assert!(is_valid_transport_public_key_encoding(&hex::decode("c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000").unwrap()));
}

#[test]
fn test_public_key_derivation() {
    let mpk = MasterPublicKey::deserialize(&hex::decode("9183b871aa141d15ba2efc5bc58a49cb6a167741364804617f48dfe11e0285696b7018f172dad1a87ed81abf27ea4c320995041e2ee4a47b2226a2439d92a38557a7e2a\
  cc72fd157283b20f1f37ba872be235214c6a9cbba1eb2ef39deec72a5").unwrap()).unwrap();

    let canister_id = b"test-canister-id";
    let context = b"test-context";

    let dk1 = mpk.derive_canister_key(canister_id);

    assert_eq!(hex::encode(dk1.serialize()),
               "af78a908589d332fc8b9d042807c483e73872e2aea7620bdb985b9289d5a99ebfd5ac0ec4844a4c542f6d0f12a716d941674953cef4f38dde601ce9792db8832557eaa051733c5541fa5017465d69b62cc4d93f2079fb8c050b4bd735ef75859");

    let dk2 = dk1.derive_sub_key(context);
    assert_eq!(hex::encode(dk2.serialize()),
                 "a20125b8cdfc57f71b6f67e557e82c1307c1af9f728573f3b682f3b1816684f3f6aed5d8dd40a309b457a25dab7d8a1416fc0e0973000321c0c1dd844d80a5708e81fdd8338ea6433f175992fa05ef343b1e7f89a09f3b5b7c0766ccb3c624cd");
}

#[test]
fn test_bls_signature_verification() {
    let dpk = DerivedPublicKey::deserialize(&hex::decode("972c4c6cc184b56121a1d27ef1ca3a2334d1a51be93573bd18e168f78f8fe15ce44fb029ffe8e9c3ee6bea2660f4f35e0774a35a80d6236c050fd8f831475b5e145116d3e83d26c533545f64b08464e4bcc755f990a381efa89804212d4eef5f").unwrap()).unwrap();

    let msg = b"message";
    let wrong_msg = b"wrong message";

    let signature = hex::decode("987db5406ce297e729c8564a106dc896943b00216a095fe9c5d32a16a330c02eb80e6f468ede83cde5462b5145b58f65").unwrap();

    assert!(verify_bls_signature(&dpk, msg, &signature));
    assert!(!verify_bls_signature(&dpk, wrong_msg, &signature));
}

#[test]
fn test_bls_signature_verification_using_identity() {
    // Check that the identity element is rejected as a public key

    let dpk =
        DerivedPublicKey::deserialize(&ic_bls12_381::G2Affine::identity().to_compressed()).unwrap();

    let msg = b"wrong message";

    let signature = ic_bls12_381::G1Affine::identity().to_compressed();

    assert!(!verify_bls_signature(&dpk, msg, &signature));
}

#[test]
fn test_derivation_using_test_key_1() {
    // This test data was generated on mainnet using test_key_1

    let key_id = VetKDKeyId {
        curve: VetKDCurve::Bls12_381_G2,
        name: "test_key_1".to_string(),
    };
    let test_key1 = MasterPublicKey::for_mainnet_key(&key_id).unwrap();

    let canister_id = candid::Principal::from_text("urq22-tyaaa-aaaag-audia-cai").unwrap();

    let canister_key = test_key1.derive_canister_key(canister_id.as_slice());

    assert_eq!(
        hex::encode(canister_key.serialize()),
        "8b961f06d392367e84136088971c4808b434e5d6b928b60fa6177f811db9930e4f2a911ef517db40f7e7897588ae0e2316500dbef3abf08ad7f63940af0cf816c2c1c234943c9bb6f4d53da121dceed093d118d0bd5552740da315eac3b59b0f",
    );

    let derived_key = canister_key.derive_sub_key(b"context-string");

    assert_eq!(
        hex::encode(derived_key.serialize()),
        "958a2700438db39cf848f99c80d4d1c0f42b5e6783c35abffe5acda4fdb09548a025fdf85aad8980fcf6e20c1082596310c2612a3f3034c56445ddfc32a0c3cd34a7d0fea8df06a2996c54e21e3f8361a6e633d706ff58e979858fe436c7edf3",
    );
}

#[test]
fn test_derivation_using_production_key() {
    // This test data was generated on mainnet using key_1

    let key_id = VetKDKeyId {
        curve: VetKDCurve::Bls12_381_G2,
        name: "key_1".to_string(),
    };
    let key1 = MasterPublicKey::for_mainnet_key(&key_id).unwrap();

    let canister_id = candid::Principal::from_text("urq22-tyaaa-aaaag-audia-cai").unwrap();

    let canister_key = key1.derive_canister_key(canister_id.as_slice());

    assert_eq!(
        hex::encode(canister_key.serialize()),
        "a4df5fb733dc53ba0b3f8dab3f7538b2f345052072f69a5749d630d9c2b2b1c4b00af09fa1d993e1ce533996961575ad027e058e2a279ab05271c115ef27d750b6b233f12bc9f1973b203e338d43b6a7617be58d5c7195dfb809d756413bc006",
    );

    let derived_key = canister_key.derive_sub_key(b"context-string");

    assert_eq!(
        hex::encode(derived_key.serialize()),
        "aa45fccb82432315e39fedb1b1f150d2e895fb1f7399cc593b826ac151b519f0966b92aef49a89efe60570ef325f0f7e1974ac3519d2e127a52c013e246aedbff2158bdd0bb9f26c763c88c0b8ec796f401d057eab276d0a34384a8a97b1937f",
    );
}

#[test]
fn test_second_level_public_key_derivation() {
    let canister_key = DerivedPublicKey::deserialize(&hex::decode("8bf165ea580742abf5fd5123eb848aa116dcf75c3ddb3cd3540c852cf99f0c5394e72dfc2f25dbcb5f9220f251cd04040a508a0bcb8b2543908d6626b46f09d614c924c5deb63a9949338ae4f4ac436bd77f8d0a392fd29de0f392a009fa61f3").unwrap()).unwrap();

    // Empty context is a no-op
    assert_eq!(canister_key, canister_key.derive_sub_key(&[]));

    let context = b"test-context";
    let derived_key = canister_key.derive_sub_key(context);

    assert_eq!(hex::encode(derived_key.serialize()),
               "80b4f1e11766d32bed0ea4e8b05e82bf84519de4a63eca0213d9e3603a946ea2968150882d1e9508701f34048fcec80919b4f493a2a254fc13dc956f1d82c6b8e641f962e1c0342c95eb58e168327d5e51e9337627ac9f1aa93d2e3058a1ff09");
}

#[test]
fn protocol_flow_with_emulated_server_side() {
    let mut rng = reproducible_rng();

    let derivation_context = DerivationContext::new(b"canister-id", b"context");
    let identity = rng.gen::<[u8; 32]>();

    let tsk_seed = rng.gen::<[u8; 32]>().to_vec();
    let tsk = TransportSecretKey::from_seed(tsk_seed).unwrap();

    let tpk_bytes: [u8; 48] = tsk.public_key().try_into().unwrap();
    let tpk = G1Affine::from_compressed(&tpk_bytes).unwrap();

    // Ordinarily the master secret key would be held as shares by
    // independent notes, with the encrypted key created by combining
    // shares. Here we simply create the master secret key and create
    // the combined encrypted key directly.

    let master_sk = random_scalar(&mut rng);
    let master_pk = G2Affine::from(G2Affine::generator() * master_sk);

    let (derived_public_key, _delta) = derivation_context.derive_key(&master_pk);

    let ek_bytes = create_encrypted_key(
        &mut rng,
        &master_pk,
        &master_sk,
        &tpk,
        &derivation_context,
        &identity,
    );

    let ek = EncryptedVetKey::deserialize(&ek_bytes).unwrap();

    let dpk_bytes = derived_public_key.to_compressed().to_vec();

    let dpk = DerivedPublicKey::deserialize(&dpk_bytes).unwrap();

    let vetkey = ek.decrypt_and_verify(&tsk, &dpk, &identity).unwrap();

    let msg = rng.gen::<[u8; 32]>().to_vec();
    let seed = IbeSeed::random(&mut rng);
    let ctext = IbeCiphertext::encrypt(&dpk, &IbeIdentity::from_bytes(&identity), &msg, &seed);

    let ptext = ctext.decrypt(&vetkey).expect("IBE decryption failed");
    assert_eq!(ptext, msg);
}

#[test]
fn derivation_matches_expected_value() {
    let vetkey = VetKey::deserialize(&hex::decode("ad19676dd92f116db11f326ff0822f295d87cc00cf65d9f132b5a618bb7381e5b0c3cb814f15e4a0f015359dcfa8a1da").unwrap()).unwrap();

    let domain_sep = "ic-test-domain-sep";

    let key = vetkey.derive_symmetric_key(domain_sep, 32);
    assert_eq!(
        hex::encode(key),
        "3b7bd854033cdc119865ba3019dc1e35010fdaf90f8ff5c9cfe9d1d557dddb29"
    );
}

#[test]
fn protocol_flow_with_fixed_rng_has_expected_outputs() {
    let tsk = TransportSecretKey::from_seed(vec![0x42; 32]).unwrap();

    assert_eq!(
        hex::encode(tsk.serialize()),
        "763e63464c55014a26ac6825616867185cc7204283ca46bd34c1a1446e737b16"
    );

    assert_eq!(
        TransportSecretKey::deserialize(&tsk.serialize())
            .unwrap()
            .serialize(),
        tsk.serialize()
    );

    let tpk = tsk.public_key();

    assert_eq!(hex::encode(tpk),
               "911969d56f42875d37a92d7eaa5d43293eff9f9a20ba4c60523e70a695eaeadeb721659b52a49d74e67841ad19033a12");

    // generated by internal library:

    let dpk = DerivedPublicKey::deserialize(&hex::decode("972c4c6cc184b56121a1d27ef1ca3a2334d1a51be93573bd18e168f78f8fe15ce44fb029ffe8e9c3ee6bea2660f4f35e0774a35a80d6236c050fd8f831475b5e145116d3e83d26c533545f64b08464e4bcc755f990a381efa89804212d4eef5f").unwrap()).unwrap();

    let ek = EncryptedVetKey::deserialize(&hex::decode("b1a13757eaae15a3c8884fc1a3453f8a29b88984418e65f1bd21042ce1d6809b2f8a49f7326c1327f2a3921e8ff1d6c3adde2a801f1f88de98ccb40c62e366a279e7aec5875a0ce2f2a9f3e109d9cb193f0197eadb2c5f5568ee4d6a87e115910662e01e604087246be8b081fc6b8a06b4b0100ed1935d8c8d18d9f70d61718c5dba23a641487e72b3b25884eeede8feb3c71599bfbcebe60d29408795c85b4bdf19588c034d898e7fc513be8dbd04cac702a1672f5625f5833d063b05df7503").unwrap()).unwrap();

    let identity = hex::decode("6d657373616765").unwrap();

    let msg = hex::decode("f00f11").unwrap();
    let seed = IbeSeed::from_bytes(&[0u8; 32]).unwrap();
    let ctext = IbeCiphertext::encrypt(&dpk, &IbeIdentity::from_bytes(&identity), &msg, &seed);

    let ctext_bytes = ctext.serialize();

    assert_eq!(hex::encode(&ctext_bytes),
               "4943204942450001a9937528bda5826cf5c7da77a5f5e46719a9748f4ea0aa491c8fba92081e5d55457ab36ec4f6335954c6d87987d0b28301bd8da166493bb537c842d20396da5a68cc9e9672fadedf1e311e0057fc906dfd37d1077ca027954c45336405e66e5e4b346b0f24bfd358a09de701654c1e0791741e4826396588440eee021df9b2399f7f98");

    assert_eq!(
        ctext,
        IbeCiphertext::deserialize(&ctext_bytes).expect("Deserializing IbeCiphertext failed")
    );

    let vetkey = ek.decrypt_and_verify(&tsk, &dpk, &identity).unwrap();

    assert_eq!(hex::encode(vetkey.signature_bytes()),
               "987db5406ce297e729c8564a106dc896943b00216a095fe9c5d32a16a330c02eb80e6f468ede83cde5462b5145b58f65");

    let ptext = ctext.decrypt(&vetkey).expect("IBE decryption failed");
    assert_eq!(ptext, msg);
}

#[test]
fn vrf_from_prod_can_be_verified() {
    let vrf_bytes = hex!("82c018756fc09660f19f9f4473820c8f047b9709e9371ae705175cb510efbfc610f0f61fb5ca8bba59e998249d466a818a62a9f32cb3dacc11941ea27256ac5b0ca710f8803d111f04b798677d9c54e127e63000c906a85bcb08c422fc81229d07a2554e7882308c6f1c3ecd07c3d72a465f741e4357144afe042c1e6d7f838ecc3f40c5e681e2b55032cfd689ebd17976726620696e707574");

    let vrf = VrfOutput::deserialize(&vrf_bytes).unwrap();

    let key_id = VetKDKeyId {
        curve: VetKDCurve::Bls12_381_G2,
        name: "key_1".to_string(),
    };
    let key1 = MasterPublicKey::for_mainnet_key(&key_id).unwrap();
    let canister_key = key1.derive_canister_key(&hex!("0000000000c0a0d00101"));
    let vrf_public_key = canister_key.derive_sub_key(b"vrf context");
    let input = "vrf input".as_bytes();

    assert_eq!(vrf.public_key().clone(), vrf_public_key);
    assert_eq!(vrf.input(), input);

    assert_eq!(
        hex::encode(vrf.output()),
        "a484fc1e8a2b0dca99beb6f4409370f5c6932a931e47a7625c3bfe9e1f9af37f"
    );
}

#[test]
fn aes_gcm_encryption() {
    let dkm = VetKey::deserialize(&hex!("ad19676dd92f116db11f326ff0822f295d87cc00cf65d9f132b5a618bb7381e5b0c3cb814f15e4a0f015359dcfa8a1da")).unwrap().as_derived_key_material();

    let test_message = b"stay calm, this is only a test";
    let domain_sep = "ic-test-domain-sep";
    let aad = b"some additional authenticated data";

    // Test string encryption path, then decryption

    let mut rng = reproducible_rng();

    let ctext = dkm
        .encrypt_message(test_message, domain_sep, aad, &mut rng)
        .unwrap();

    assert_eq!(
        dkm.decrypt_message(&ctext, domain_sep, aad).unwrap(),
        test_message,
    );

    // Test decryption of known ciphertext encrypted with the derived key

    // This checks the behavior for handling old versions that did not use a header or support AAD
    let fixed_ctext_old_format = hex!("476f440e30bb95fff1420ce41ba6a07e03c3fcc0a751cfb23e64a8dcb0fc2b1eb74e2d4768f5c4dccbf2526609156664046ad27a6e78bd93bb8b");

    assert_eq!(
        dkm.decrypt_message(&fixed_ctext_old_format, domain_sep, &[])
            .unwrap(),
        test_message,
    );

    // Test decryption of known ciphertext encrypted with the derived key
    let fixed_ctext = hex!("49432047434d76325dc1b0f5f8deec973adda66ce7cb9dc06118c738fae12027c5bae5b86e69ffd633ddfc0ea66c4df37b6e7e298d9f80170ec3d51c4238be9a63bd");

    assert_eq!(
        dkm.decrypt_message(&fixed_ctext, domain_sep, aad).unwrap(),
        test_message,
    );

    // Test decryption of various mutated or truncated ciphertexts: all should fail

    // Test sequentially flipping each bit

    for i in 0..ctext.len() * 8 {
        let mod_ctext = {
            let mut m = ctext.clone();
            m[i / 8] ^= 0x80 >> i % 8;
            m
        };

        assert!(dkm.decrypt_message(&mod_ctext, domain_sep, aad).is_err());
    }

    // Test sequentially flipping each bit of the associated data

    for i in 0..aad.len() * 8 {
        let mod_aad = {
            let mut a = aad.clone();
            a[i / 8] ^= 0x80 >> i % 8;
            a
        };

        assert!(dkm.decrypt_message(&ctext, domain_sep, &mod_aad).is_err());
    }

    // Test truncating

    for i in 0..ctext.len() - 1 {
        let mod_ctext = {
            let mut m = ctext.clone();
            m.truncate(i);
            m
        };

        assert!(dkm.decrypt_message(&mod_ctext, domain_sep, aad).is_err());
    }

    // Test appending random bytes

    for i in 1..32 {
        let mod_ctext = {
            use rand::RngCore;
            let mut m = ctext.clone();
            let mut extra = vec![0u8; i];
            rng.fill_bytes(&mut extra);
            m.extend_from_slice(&extra);
            m
        };

        assert!(dkm.decrypt_message(&mod_ctext, domain_sep, aad).is_err());
    }
}



================================================
FILE: backend/rs/ic_vetkeys_test_utils/Cargo.toml
================================================
[package]
name = "ic-vetkeys-test-utils"
authors.workspace = true
description.workspace = true
documentation.workspace = true
edition.workspace = true
version.workspace = true
license.workspace = true

[lib]
crate-type = ["lib"]

[dependencies]
anyhow = { workspace = true }
candid = { workspace = true }
hex = { workspace = true }
ic_bls12_381 = { version = "0.10.1", default-features = false, features = [
    "groups",
    "pairings",
    "alloc",
    "experimental",
    "zeroize",
] }
ic-stable-structures = { workspace = true }
ic-vetkeys = { path = "../ic_vetkeys" }
lazy_static = { workspace = true }
rand = { workspace = true }
rand_chacha = { workspace = true }
serde = { workspace = true }
serde_bytes = { workspace = true }
sha2 = "0.10.9"



================================================
FILE: backend/rs/ic_vetkeys_test_utils/src/lib.rs
================================================
use std::{convert::TryInto, ops::Range};

use candid::Principal;
use ic_bls12_381::hash_to_curve::{ExpandMsgXmd, HashToCurve};
use ic_bls12_381::*;
use ic_stable_structures::storable::Blob;
use ic_vetkeys::types::{AccessRights, ByteBuf, KeyName};
use rand::{CryptoRng, Rng, RngCore, SeedableRng};
use rand_chacha::ChaCha20Rng;
use std::convert::TryFrom;

pub fn reproducible_rng() -> ChaCha20Rng {
    let seed = rand::thread_rng().gen();
    println!("RNG seed: {seed:?}");
    ChaCha20Rng::from_seed(seed)
}

pub fn random_unique_memory_ids<R: Rng + CryptoRng>(rng: &mut R) -> (u8, [u8; 3]) {
    const MAX_MEMORY_ID: u8 = 254;
    let mut set = std::collections::HashSet::<u8>::new();
    let mut unique_memory_ids = [0; 4];
    while set.len() != unique_memory_ids.len() {
        set.insert(rng.gen_range(0..=MAX_MEMORY_ID));
    }
    unique_memory_ids = set.into_iter().collect::<Vec<u8>>().try_into().unwrap();

    let memory_id_encrypted_maps = unique_memory_ids[0];
    let memory_ids_key_manager = [
        unique_memory_ids[1],
        unique_memory_ids[2],
        unique_memory_ids[3],
    ];
    (memory_id_encrypted_maps, memory_ids_key_manager)
}

pub fn random_name<R: Rng + CryptoRng>(rng: &mut R) -> KeyName {
    random_blob(rng)
}

pub fn random_blob<R: Rng + CryptoRng, const N: usize>(rng: &mut R) -> Blob<N> {
    let mut result = [0u8; N];
    rng.fill_bytes(&mut result);
    Blob::try_from(result.as_slice()).unwrap()
}

pub fn random_bytebuf<R: Rng + CryptoRng>(rng: &mut R, range: Range<usize>) -> ByteBuf {
    let length: usize = rng.gen_range(range);
    let mut result: Vec<u8> = vec![0; length];
    rng.fill_bytes(&mut result);
    ByteBuf::from(result)
}

pub fn random_key<R: Rng + CryptoRng>(rng: &mut R) -> Blob<32> {
    random_blob(rng)
}

pub fn random_self_authenticating_principal<R: Rng + CryptoRng>(rng: &mut R) -> Principal {
    let mut fake_public_key = vec![0u8; 32];
    rng.fill_bytes(&mut fake_public_key);
    Principal::self_authenticating::<&[u8]>(fake_public_key.as_ref())
}

pub fn random_access_rights<R: Rng + CryptoRng>(rng: &mut R) -> AccessRights {
    loop {
        if let Some(ar) = AccessRights::from_repr(rng.gen()) {
            return ar;
        }
    }
}

pub fn random_utf8_string<R: Rng + CryptoRng>(rng: &mut R, len: usize) -> String {
    rng.sample_iter::<char, _>(&rand::distributions::Standard)
        .take(len)
        .collect()
}

pub fn git_root_dir() -> String {
    let output = std::process::Command::new("git")
        .args(["rev-parse", "--show-toplevel"])
        .output()
        .expect("Failed to execute git command");
    assert!(output.status.success());
    let root_dir_with_newline =
        String::from_utf8(output.stdout).expect("Failed to convert stdout to string");
    root_dir_with_newline.trim_end_matches('\n').to_string()
}

pub fn random_scalar<R: RngCore + CryptoRng>(rng: &mut R) -> Scalar {
    loop {
        /*
        A BLS12-381 scalar is 255 bits long. Generate the scalar using
        rejection sampling by creating a 255 bit random bitstring then
        checking if it is less than the group order.
         */
        let mut buf = [0u8; 32];
        rng.fill_bytes(&mut buf);
        buf[0] &= 0b0111_1111; // clear the 256th bit

        let s = Scalar::from_bytes(&buf);

        if bool::from(s.is_some()) {
            return s.unwrap();
        }
    }
}

/// See draft-irtf-cfrg-bls-signature-01 §4.2.2 for details on BLS augmented signatures
fn augmented_hash_to_g1(pk: &G2Affine, data: &[u8]) -> G1Affine {
    let domain_sep = b"BLS_SIG_BLS12381G1_XMD:SHA-256_SSWU_RO_AUG_";

    let mut signature_input = vec![];
    signature_input.extend_from_slice(&pk.to_compressed());
    signature_input.extend_from_slice(data);

    let pt = <ic_bls12_381::G1Projective as HashToCurve<ExpandMsgXmd<sha2::Sha256>>>::hash_to_curve(
        signature_input,
        domain_sep,
    );

    G1Affine::from(pt)
}

const DERIVATION_CANISTER_DST: &[u8; 33] = b"ic-vetkd-bls12-381-g2-canister-id";

const DERIVATION_CONTEXT_DST: &[u8; 29] = b"ic-vetkd-bls12-381-g2-context";

pub struct DerivationContext {
    canister_id: Vec<u8>,
    context: Option<Vec<u8>>,
}

impl DerivationContext {
    /// Create a new derivation context
    pub fn new(canister_id: &[u8], context: &[u8]) -> Self {
        Self {
            canister_id: canister_id.to_vec(),
            context: if context.is_empty() {
                None
            } else {
                Some(context.to_vec())
            },
        }
    }

    fn hash_to_scalar(input1: &[u8], input2: &[u8], domain_sep: &'static [u8]) -> Scalar {
        let combined_input = {
            let mut c = Vec::with_capacity(2 * 8 + input1.len() + input2.len());
            c.extend_from_slice(&(input1.len() as u64).to_be_bytes());
            c.extend_from_slice(input1);
            c.extend_from_slice(&(input2.len() as u64).to_be_bytes());
            c.extend_from_slice(input2);
            c
        };

        use ic_bls12_381::hash_to_curve::HashToField;

        let mut s = [ic_bls12_381::Scalar::zero()];
        <ic_bls12_381::Scalar as HashToField>::hash_to_field::<ExpandMsgXmd<sha2::Sha256>>(
            &combined_input,
            domain_sep,
            &mut s,
        );
        s[0]
    }

    pub fn derive_key(&self, master_pk: &G2Affine) -> (G2Affine, Scalar) {
        let mut offset = Self::hash_to_scalar(
            &master_pk.to_compressed(),
            &self.canister_id,
            DERIVATION_CANISTER_DST,
        );

        let canister_key = G2Affine::from(G2Affine::generator() * offset + master_pk);

        if let Some(context) = &self.context {
            let context_offset = Self::hash_to_scalar(
                &canister_key.to_compressed(),
                context,
                DERIVATION_CONTEXT_DST,
            );
            let canister_key_with_context = G2Affine::generator() * context_offset + canister_key;
            offset += context_offset;
            (G2Affine::from(canister_key_with_context), offset)
        } else {
            (canister_key, offset)
        }
    }
}

pub fn create_encrypted_key<R: CryptoRng + RngCore>(
    rng: &mut R,
    master_pk: &G2Affine,
    master_sk: &Scalar,
    transport_pk: &G1Affine,
    context: &DerivationContext,
    input: &[u8],
) -> Vec<u8> {
    let (dpk, delta) = context.derive_key(master_pk);

    let dsk = delta + master_sk;

    let r = random_scalar(rng);

    let msg = augmented_hash_to_g1(&dpk, input);

    let c1 = G1Affine::from(G1Affine::generator() * r);
    let c2 = G2Affine::from(G2Affine::generator() * r);
    let c3 = G1Affine::from(transport_pk * r + msg * dsk);

    let mut output = vec![];
    output.extend_from_slice(&c1.to_compressed());
    output.extend_from_slice(&c2.to_compressed());
    output.extend_from_slice(&c3.to_compressed());
    output
}



================================================
FILE: examples/basic_bls_signing/README.md
================================================
# Basic BLS Signing

| Motoko backend | [![](https://icp.ninja/assets/open.svg)](http://icp.ninja/editor?g=https://github.com/dfinity/vetkeys/tree/main/examples/basic_bls_signing/motoko)|
| --- | --- |
| Rust backend | [![](https://icp.ninja/assets/open.svg)](http://icp.ninja/editor?g=https://github.com/dfinity/vetkeys/tree/main/examples/basic_bls_signing/rust) |

The **Basic BLS signing** example demonstrates how to use **[vetKeys](https://internetcomputer.org/docs/building-apps/network-features/vetkeys/introduction)** to implement secure BLS signing on the **Internet Computer (IC)**, where every authenticated user can ask the canister (IC smart contract) to produce signatures, where the **Internet Identity Principal** identifies the signer. This canister ensures that users can only produce signature for their own principal and not for someone else's principal. Furthermore, the vetKeys in this dapp can only be produced upon a user request, as specified in the canister code, meaning that the canister cannot produce signatures for arbitrary users or messages.

For confirming that the canister can only produce signatures in the intended way, users need to inspect the code installed in the canister. For this, it is crucial that canisters using VetKeys have their code public.

![UI Screenshot](ui_screenshot.png)

## Features

- **Signer Authorization**: Only authorized users can produce signatures and only for their own identity.
- **Frontend Signature Verification**: Any user can publish any signature from their principal in the canister storage and the frontend automatically checks the signature validity.

## Setup

### Prerequisites

- [Internet Computer software development kit](https://internetcomputer.org/docs/building-apps/getting-started/install)
- [npm](https://www.npmjs.com/package/npm)

### (Optionally) Choose a Different Master Key

This example uses `test_key_1` by default. To use a different [available master key](https://internetcomputer.org/docs/building-apps/network-features/vetkeys/api#available-master-keys), change the `"init_arg": "(\"test_key_1\")"` line in `dfx.json` to the desired key before running `dfx deploy` in the next step.

### Deploy the Canisters Locally

If you want to deploy this project locally with a Motoko backend, then run:
```bash
dfx start --background && dfx deploy
```
from the `motoko` folder.

To use the Rust backend instead of Motoko, run the same command in the `rust` folder.

## Example Components

### Backend

The backend consists of a canister that:
* Produces signatures upon a user request.
* Allows users to retrieve the root public key that can be used to check any user's signature for this canister.
* Allows users to store signatures (real or fake) in a log datastructure.

### Frontend

The frontend is a vanilla typescript application providing a simple interface for signing, showing the signatures stored in the canister, and publishing a signature.

To run the frontend in development mode with hot reloading (after running `dfx deploy`):

```bash
npm run dev
```

## Additional Resources

- **[What are VetKeys](https://internetcomputer.org/docs/building-apps/network-features/encryption/vetkeys)** - For more information about VetKeys and VetKD.



================================================
FILE: examples/basic_bls_signing/frontend/eslint.config.mjs
================================================
// @ts-check

import eslint from "@eslint/js";
import tseslint from "typescript-eslint";
import eslintPluginPrettierRecommended from "eslint-plugin-prettier/recommended";

export default tseslint.config(
  eslint.configs.recommended,
  tseslint.configs.recommendedTypeChecked,
  eslintPluginPrettierRecommended,
  {
    languageOptions: {
      parserOptions: {
        project: true,
        tsconfigRootDir: import.meta.dirname,
      },
    },
  },
  {
    ignores: [
      "dist/",
      "src/declarations",
      "coverage/",
      "*.config.js",
      "*.config.cjs",
      "*.config.mjs",
      "*.config.ts",
    ],
  }
);



================================================
FILE: examples/basic_bls_signing/frontend/index.html
================================================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>VetKeys: Basic BLS Signing</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.ts"></script>
  </body>
</html>



================================================
FILE: examples/basic_bls_signing/frontend/package.json
================================================
{
    "name": "basic_bls_signing_frontend",
    "private": true,
    "version": "0.0.0",
    "type": "module",
    "scripts": {
        "dev": "npm run build:bindings && vite",
        "build": "npm run build:bindings && tsc && vite build",
        "build:bindings": "cd scripts && ./gen_bindings.sh",
        "preview": "vite preview",
        "lint": "eslint"
    },
    "devDependencies": {
        "@eslint/js": "^9.24.0",
        "@rollup/plugin-typescript": "^12.1.2",
        "@types/node": "^24.0.10",
        "eslint": "^9.24.0",
        "eslint-config-prettier": "^10.1.5",
        "eslint-plugin-prettier": "^5.4.0",
        "tslib": "^2.8.1",
        "typescript": "~5.7.2",
        "typescript-eslint": "^8.35.1",
        "vite": "^6.2.0",
        "vite-plugin-environment": "^1.1.3"
    },
    "dependencies": {
        "@dfinity/auth-client": "^2.4.1",
        "@dfinity/principal": "^2.4.1",
        "@dfinity/vetkeys": "^0.3.0"
    }
}



================================================
FILE: examples/basic_bls_signing/frontend/tsconfig.json
================================================
{
    "compilerOptions": {
      "target": "ES2020",
      "useDefineForClassFields": true,
      "module": "ESNext",
      "lib": ["ES2020", "DOM", "DOM.Iterable"],
      "skipLibCheck": true,
  
      /* Bundler mode */
      "moduleResolution": "bundler",
      "allowImportingTsExtensions": true,
      "isolatedModules": true,
      "moduleDetection": "force",
      "noEmit": true,
  
      /* Linting */
      "strict": true,
      "noUnusedLocals": true,
      "noUnusedParameters": true,
      "noFallthroughCasesInSwitch": true,
      "noUncheckedSideEffectImports": true
    },
    "include": ["src"]
  }
  


================================================
FILE: examples/basic_bls_signing/frontend/vite.config.ts
================================================
import { defineConfig } from 'vite'
import typescript from '@rollup/plugin-typescript';
import environment from 'vite-plugin-environment';
import path from 'path';

// https://vite.dev/config/
export default defineConfig({
  plugins: [
    typescript({
      inlineSources: true,
    }),
    environment("all", { prefix: "CANISTER_" }),
    environment("all", { prefix: "DFX_" }),
  ],
  build: {
    sourcemap: true,
    rollupOptions: {
      output: {
        inlineDynamicImports: true,
      },
    },
  },
  root: "./",
  server: {
    hmr: false
  }
})


================================================
FILE: examples/basic_bls_signing/frontend/public/.ic-assets.json5
================================================
[
  {
    match: "**/*",
    security_policy: "hardened",
    headers: {
      "Content-Security-Policy": "default-src 'self';script-src 'self';connect-src 'self' http://localhost:* https://icp0.io https://*.icp0.io https://icp-api.io;img-src 'self';object-src 'none';base-uri 'self';frame-ancestors 'none';form-action 'self';upgrade-insecure-requests;",
    },
    allow_raw_access: false
  },
]



================================================
FILE: examples/basic_bls_signing/frontend/scripts/gen_bindings.sh
================================================
#!/bin/bash

cd ../../backend && make extract-candid

cd .. && dfx generate basic_bls_signing || exit 1

rm -r frontend/src/declarations/basic_bls_signing > /dev/null 2>&1 || true

mkdir -p frontend/src/declarations/basic_bls_signing
mv src/declarations/basic_bls_signing frontend/src/declarations
rmdir -p src/declarations > /dev/null 2>&1 || true


================================================
FILE: examples/basic_bls_signing/frontend/src/main.ts
================================================
// Required to run `npm run dev`.
if (!window.global) {
  window.global = window;
}

import "./style.css";
import { createActor } from "./declarations/basic_bls_signing";
import { Principal } from "@dfinity/principal";
import { AuthClient } from "@dfinity/auth-client";
import type { ActorSubclass } from "@dfinity/agent";
import { _SERVICE } from "./declarations/basic_bls_signing/basic_bls_signing.did";
import { DerivedPublicKey, verifyBlsSignature } from "@dfinity/vetkeys";
import type { Signature } from "./declarations/basic_bls_signing/basic_bls_signing.did";

let myPrincipal: Principal | undefined = undefined;
let authClient: AuthClient | undefined;
let basicBlsSigningCanister: ActorSubclass<_SERVICE> | undefined;
// let canisterPublicKey: DerivedPublicKey | undefined;
let myVerificationKey: DerivedPublicKey | undefined;

function getBasicBlsSigningCanister(): ActorSubclass<_SERVICE> {
  if (basicBlsSigningCanister) return basicBlsSigningCanister;
  if (!process.env.CANISTER_ID_BASIC_BLS_SIGNING) {
    throw Error("CANISTER_ID_BASIC_BLS_SIGNING is not set");
  }
  if (!authClient) {
    throw Error("Auth client is not initialized");
  }
  const host =
    process.env.DFX_NETWORK === "ic"
      ? `https://${process.env.CANISTER_ID_BASIC_BLS_SIGNING}.ic0.app`
      : "http://localhost:8000";

  basicBlsSigningCanister = createActor(
    process.env.CANISTER_ID_BASIC_BLS_SIGNING,
    {
      agentOptions: {
        identity: authClient.getIdentity(),
        host,
      },
    },
  );

  return basicBlsSigningCanister;
}

export function login(client: AuthClient) {
  void client.login({
    maxTimeToLive: BigInt(1800) * BigInt(1_000_000_000),
    identityProvider:
      process.env.DFX_NETWORK === "ic"
        ? "https://identity.ic0.app/#authorize"
        : `http://rdmx6-jaaaa-aaaaa-aaadq-cai.localhost:8000/#authorize`,
    onSuccess: () => {
      myPrincipal = client.getIdentity().getPrincipal();
      updateUI(true);
    },
    onError: (error) => {
      alert("Authentication failed: " + error);
    },
  });
}

export function logout() {
  void authClient?.logout();
  myPrincipal = undefined;
  myVerificationKey = undefined;
  basicBlsSigningCanister = undefined;
  updateUI(false);
  document.getElementById("signaturesList")!.classList.toggle("hidden", true);
}

async function initAuth() {
  authClient = await AuthClient.create();
  const isAuthenticated = await authClient.isAuthenticated();

  if (isAuthenticated) {
    myPrincipal = authClient.getIdentity().getPrincipal();
    updateUI(true);
  } else {
    updateUI(false);
  }
}

function updateUI(isAuthenticated: boolean) {
  const loginButton = document.getElementById("loginButton")!;
  const principalDisplay = document.getElementById("principalDisplay")!;
  const logoutButton = document.getElementById("logoutButton")!;
  const signingActions = document.getElementById("signingActions")!;
  const customSignatureForm = document.getElementById("customSignatureForm")!;
  const signaturesList = document.getElementById("signaturesList")!;

  loginButton.classList.toggle("hidden", isAuthenticated);
  principalDisplay.classList.toggle("hidden", !isAuthenticated);
  logoutButton.classList.toggle("hidden", !isAuthenticated);
  signingActions.classList.toggle("hidden", !isAuthenticated);
  customSignatureForm.classList.toggle("hidden", true);
  signaturesList.classList.toggle("hidden", true);

  if (isAuthenticated && myPrincipal) {
    principalDisplay.textContent = `Principal: ${myPrincipal.toString()}`;
  }
}

function handleLogin() {
  if (!authClient) {
    alert("Auth client not initialized");
    return;
  }
  login(authClient);
}

document.querySelector<HTMLDivElement>("#app")!.innerHTML = `
  <div>
    <h1>Basic BLS Signing using VetKeys</h1>
    <div class="principal-container">
      <div id="principalDisplay" class="principal-display"></div>
      <button id="logoutButton">Logout</button>
    </div>
    <div class="login-container">
      <button id="loginButton">Login</button>
    </div>
    <div id="signingActions" class="buttons">
      <button id="signMessageButton">Sign Message</button>
      <button id="listSignaturesButton">List Signatures</button>
      <button id="customSignatureButton">Verify Custom Signature</button>
    </div>
    <div id="customSignatureForm">
      <h3>Verify Custom Signature</h3>
      <form id="submitSignatureForm">
        <div>
          <label for="message">Message</label>
          <input type="text" id="message" required>
        </div>
        <div>
          <label for="signature">Signature (hex)</label>
          <input type="text" id="signature" required>
        </div>
        <div>
          <label for="pubkey">Public key (hex)</label>
          <input type="text" id="pubkey" required>
        </div>
        <button type="submit">Submit</button>
      </form>
    </div>
    <div id="signaturesList">
      <h3>My Signatures</h3>
      <div id="signatures"></div>
    </div>
  </div>
`;

// Add event listeners
document.getElementById("loginButton")!.addEventListener("click", handleLogin);
document.getElementById("logoutButton")!.addEventListener("click", logout);
document.getElementById("signMessageButton")!.addEventListener("click", () => {
  void (async () => {
    const message = prompt("Enter message to sign:");
    if (message) {
      try {
        await getBasicBlsSigningCanister().sign_message(message);
        alert("Created and stored signature successfully.");
      } catch (error) {
        alert(`Error: ${error as Error}`);
      }
    }
  })();
});

document
  .getElementById("customSignatureButton")!
  .addEventListener("click", () => {
    document
      .getElementById("customSignatureForm")!
      .classList.toggle("hidden", false);
    document.getElementById("signaturesList")!.classList.toggle("hidden", true);
  });

document
  .getElementById("listSignaturesButton")!
  .addEventListener("click", () => {
    void listSignatures();
  });

document
  .getElementById("submitSignatureForm")!
  .addEventListener("submit", (e) => {
    e.preventDefault();
    const message = (document.getElementById("message") as HTMLInputElement)
      .value;
    const signatureHex = (
      document.getElementById("signature") as HTMLInputElement
    ).value;
    const pubkeyHex = (document.getElementById("pubkey") as HTMLInputElement)
      .value;
    const messageBytes = new TextEncoder().encode(message);

    try {
      const signatureBytes = new Uint8Array(
        signatureHex.match(/.{1,2}/g)!.map((byte) => parseInt(byte, 16)),
      );
      const pubkeyBytes = new Uint8Array(
        pubkeyHex.match(/.{1,2}/g)!.map((byte) => parseInt(byte, 16)),
      );

      const verificationKey = DerivedPublicKey.deserialize(pubkeyBytes);

      const result = verifyBlsSignature(
        verificationKey,
        messageBytes,
        signatureBytes,
      );
      alert(`Verification result: ${result ? "Valid" : "INVALID"}`);
    } catch {
      alert("Verification failed.");
    }
  });

async function listSignatures() {
  const signatures: Array<Signature> =
    await getBasicBlsSigningCanister().get_my_signatures();
  const signaturesDiv = document.getElementById("signatures")!;
  signaturesDiv.innerHTML = "";

  if (signatures.length === 0) {
    signaturesDiv.innerHTML = `
        <div class="no-signatures">
          <p>No signatures have been published yet.</p>
        </div>
      `;
  } else {
    if (!myVerificationKey) {
      const myVerificationKeyRaw =
        await getBasicBlsSigningCanister().get_my_verification_key();
      myVerificationKey = DerivedPublicKey.deserialize(
        Uint8Array.from(myVerificationKeyRaw),
      );
    }
    const myVerificationKeyHex = Array.from(myVerificationKey.publicKeyBytes())
      .map((b) => b.toString(16).padStart(2, "0"))
      .join("");

    for (const signatureData of signatures.slice().reverse()) {
      const signatureHex = Array.from(signatureData.signature)
        .map((b) => b.toString(16).padStart(2, "0"))
        .join("");

      // Convert nanoseconds to milliseconds and create a Date object
      const timestamp = new Date(Number(signatureData.timestamp) / 1_000_000);
      const formattedDate = timestamp.toLocaleString();

      const signatureElement = document.createElement("div");
      signatureElement.className = "signature";

      const isValid = verifyBlsSignature(
        myVerificationKey,
        new TextEncoder().encode(signatureData.message),
        Uint8Array.from(signatureData.signature),
      );

      signatureElement.innerHTML = `
        <h5>Signed message: ${signatureData.message}</h5>
        <p class="signature-hex">Signature: ${signatureHex}</p>
        <p class="verification-key-hex">Public key: ${myVerificationKeyHex}</p>
        <p class="verification-status ${isValid ? "valid" : "invalid"}">Verification: ${isValid ? "Valid" : "Invalid"}</p>
        <p class="timestamp">Added: ${formattedDate}</p>
          `;

      signaturesDiv.appendChild(signatureElement);
    }
  }

  document.getElementById("signaturesList")!.classList.toggle("hidden", false);
  document
    .getElementById("customSignatureForm")!
    .classList.toggle("hidden", true);
}

// Initialize auth
void initAuth();



================================================
FILE: examples/basic_bls_signing/frontend/src/style.css
================================================
/* Base styles */
:root {
  font-family: Inter, system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #242424;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

body {
  margin: 0;
  display: flex;
  place-items: center;
  min-width: 320px;
  min-height: 100vh;
}

#app {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

h1 {
  font-size: 2.2em;
  line-height: 1.1;
  margin-bottom: 2rem;
}

h3 {
  color: var(--text-color);
  font-size: 1.5rem;
  margin-bottom: 1.5rem;
  font-weight: 600;
}

h4 {
  color: var(--text-color);
  font-size: 1.25rem;
  margin-bottom: 1rem;
  font-weight: 600;
}

h5 {
  color: var(--text-color);
  font-size: 1.1rem;
  margin-bottom: 0.5rem;
  font-weight: 600;
}

/* Principal container */
.principal-container {
  display: flex;
  align-items: center;
  gap: 1rem;
  margin-bottom: 1rem;
  justify-content: center;
}

.principal-display {
  font-family: monospace;
  background-color: rgba(0, 0, 0, 0.2);
  padding: 0.5rem 1rem;
  border-radius: 8px;
  color: #a8a6a6;
  white-space: pre-wrap;
  word-break: break-all;
  max-width: 600px;
}

/* Buttons */
button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #1a1a1a;
  cursor: pointer;
  transition: border-color 0.25s;
}

button:hover {
  border-color: #646cff;
}

button:focus,
button:focus-visible {
  outline: 4px auto -webkit-focus-ring-color;
}

#loginButton {
  background-color: #28a745;
  color: white;
  min-width: 120px;
}

#loginButton:hover {
  background-color: #218838;
}

#logoutButton {
  background-color: #dc3545;
  color: white;
}

#logoutButton:hover {
  background-color: #c82333;
}

/* Signing actions */
#signingActions {
  display: flex;
  gap: 1rem;
  justify-content: center;
  margin: 2rem 0;
}

#signingActions button {
  background-color: #1a1a1a;
  color: white;
}

#signingActions button:hover {
  background-color: #2a2a2a;
}

/* Custom signature form */
#customSignatureForm {
  max-width: 600px;
  margin: 2rem auto;
  padding: 2rem 3rem;
  background-color: #1a1a1a;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

#customSignatureForm div {
  margin-bottom: 1.5rem;
}

#customSignatureForm label {
  display: block;
  margin-bottom: 0.5rem;
  font-weight: 500;
  color: rgba(255, 255, 255, 0.87);
}

#customSignatureForm input {
  width: 100%;
  padding: 0.75rem;
  background-color: #242424;
  border: 1px solid #333;
  border-radius: 8px;
  font-size: 1rem;
}

#customSignatureForm input:focus {
  outline: none;
  border-color: #646cff;
}

#customSignatureForm button {
  width: 100%;
  background-color: #28a745;
  color: white;
}

#customSignatureForm button:hover {
  background-color: #218838;
}

/* Signatures list */
#signaturesList {
  margin: 2rem 0;
}

.signature {
  margin: 1.5rem 0;
  padding: 1.5rem;
  background-color: #1a1a1a;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
  transition: transform 0.2s ease;
  position: relative;
}

.signature:hover {
  transform: translateY(-2px);
}

.signature h5 {
  margin: 0 0 1rem 0;
  color: rgba(255, 255, 255, 0.87);
}

.signature p {
  margin: 0.5rem 0;
  color: #a8a6a6;
}

.signature-hex {
  font-family: monospace;
  word-break: break-all;
  background-color: rgba(0, 0, 0, 0.2);
  padding: 0.5rem;
  border-radius: 4px;
}

.verification-key-hex {
  font-family: monospace;
  word-break: break-all;
  background-color: rgba(0, 0, 0, 0.2);
  padding: 0.5rem;
  border-radius: 4px;
}

.verification-status {
  font-weight: 500;
}

.verification-status.valid {
  color: #2ecc71;
  font-weight: bold;
}

.verification-status.invalid {
  color: #e03926;
  font-weight: bold;
}

.principal {
  font-family: monospace;
  color: #a8a6a6;
}

.login-container {
  display: flex;
  justify-content: center;
  margin: 2rem 0;
  width: 100%;
}

/* Responsive design */
@media (max-width: 768px) {
  #app {
    padding: 1rem;
  }

  h1 {
    font-size: 1.8em;
  }

  .principal-container {
    flex-direction: column;
  }

  #signingActions {
    flex-direction: column;
  }
}

/* Light theme */
@media (prefers-color-scheme: light) {
  :root {
    color: #213547;
    background-color: #ffffff;
  }

  button {
    background-color: #f9f9f9;
  }

  .principal-display {
    background-color: rgba(0, 0, 0, 0.05);
  }

  #customSignatureForm {
    background-color: #f9f9f9;
  }

  #customSignatureForm label {
    color: #213547;
  }

  #customSignatureForm input {
    background-color: #ffffff;
    border-color: #ddd;
  }

  .signature {
    background-color: #f9f9f9;
  }

  .signature h5 {
    color: #213547;
  }

  .signature p {
    color: #666;
  }

  .signature-hex {
    background-color: rgba(0, 0, 0, 0.05);
  }

  .verification-key-hex {
    background-color: rgba(0, 0, 0, 0.05);
  }

  .principal {
    color: #666;
  }
}

.no-signatures {
  text-align: center;
  padding: 2rem;
  background-color: #1a1a1a;
  border-radius: 8px;
  margin: 1rem 0;
}

.no-signatures p {
  color: #a8a6a6;
  font-size: 1.1rem;
  margin: 0;
}

.timestamp {
  color: #a8a6a6;
  font-size: 0.9rem;
  margin-top: 0.5rem;
  font-style: italic;
}

/* Auth state classes */
.hidden {
  display: none !important;
}

/* Initial state classes for auth elements */
#loginButton {
  display: block;
}

#signingActions {
  display: flex;
}

#principalDisplay {
  display: block;
}

#logoutButton {
  display: block;
}

#customSignatureForm {
  display: block;
}

#signaturesList {
  display: block;
}


================================================
FILE: examples/basic_bls_signing/frontend/src/vite-end.d.ts
================================================
/// <reference types="vite/client" />



================================================
FILE: examples/basic_bls_signing/motoko/dfx.json
================================================
{
  "canisters": {
    "basic_bls_signing": {
      "main": "backend/src/Main.mo",
      "type": "motoko",
      "args": "--enhanced-orthogonal-persistence",
      "init_arg": "(\"test_key_1\")",
      "metadata": [
        {
          "name": "candid:service",
          "visibility": "public"
        }
      ]
    },
    "internet-identity": {
      "candid": "https://github.com/dfinity/internet-identity/releases/latest/download/internet_identity.did",
      "type": "custom",
      "specified_id": "rdmx6-jaaaa-aaaaa-aaadq-cai",
      "remote": {
        "id": {
          "ic": "rdmx6-jaaaa-aaaaa-aaadq-cai"
        }
      },
      "wasm": "https://github.com/dfinity/internet-identity/releases/latest/download/internet_identity_dev.wasm.gz"
    },
    "www": {
      "dependencies": ["basic_bls_signing", "internet-identity"],
      "build": [
        "cd frontend && npm i --include=dev && npm run build && cd - && rm -r dist > /dev/null 2>&1; mv frontend/dist ./"
      ],
      "frontend": {
        "entrypoint": "dist/index.html"
      },
      "source": ["dist/"],
      "type": "assets",
      "output_env_file": "frontend/.env"
    }
  },
  "defaults": {
    "build": {
      "packtool": "npx ic-mops sources",
      "args": ""
    }
  },
  "networks": {
    "local": {
      "bind": "127.0.0.1:8000",
      "type": "ephemeral"
    }
  }
}



================================================
FILE: examples/basic_bls_signing/motoko/mops.toml
================================================
[dependencies]
core = "1.0.0"
ic-vetkeys = "0.3.0"
sha2 = "0.1.2"


================================================
FILE: examples/basic_bls_signing/motoko/backend/src/Main.mo
================================================
import Principal "mo:core/Principal";
import Text "mo:core/Text";
import Blob "mo:core/Blob";
import Nat64 "mo:core/Nat64";
import Time "mo:core/Time";
import Map "mo:core/Map";
import Array "mo:core/Array";
import List "mo:core/List";
import Nat8 "mo:core/Nat8";
import Runtime "mo:core/Runtime";
import Nat "mo:core/Nat";
import VetKeys "mo:ic-vetkeys";
import Order "mo:core/Order";

shared persistent actor class (keyName : Text) = {
    // Types
    type Signature = {
        message : Text;
        signature : Blob;
        timestamp : Nat64;
    };

    type SignatureKey = {
        signer : Principal;
        timestamp : Nat64;
    };

    type VetKdKeyid = {
        curve : { #bls12_381_g2 };
        name : Text;
    };

    // Compare function for SignatureKey
    private func signatureKeyCompare(a : SignatureKey, b : SignatureKey) : Order.Order {
        switch (Principal.compare(a.signer, b.signer)) {
            case (#equal) { Nat64.compare(a.timestamp, b.timestamp) };
            case (other) { other };
        }
    };

    // Stable storage for signatures
    private var signatures = Map.empty<SignatureKey, Signature>();

    // Helper function to get current timestamp
    private func getTimestamp() : Nat64 {
        Nat64.fromIntWrap(Time.now());
    };

    // Helper function to create context for vetKD
    private func context(signer : Principal) : Blob {
        // Domain separator for this dapp
        let domainSeparator : [Nat8] = Blob.toArray(Text.encodeUtf8("basic_bls_signing_dapp"));
        let domainSeparatorLength : [Nat8] = [Nat8.fromNat(domainSeparator.size())]; // Length of domain separator

        // Combine domain separator length, domain separator, and signer principal
        let signerBytes = Principal.toBlob(signer);
    
